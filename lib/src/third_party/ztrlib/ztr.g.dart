// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'package:oracle_drive/src/third_party/common.g.dart' as common;
import 'dart:ffi' as ffi;

@ffi.Native<ffi.Void Function(common.Result)>()
external void free_result(common.Result result);

@ffi.Native<ffi.Void Function(common.LogCallback)>()
external void register_async_callback(common.LogCallback cb);

@ffi.Native<ffi.Void Function(common.LogCallback)>()
external void register_sync_callback(common.LogCallback cb);

@ffi.Native<ffi.Void Function(common.LogCallback, ffi.UnsignedInt)>(
  symbol: 'register_async_callback_with_level',
)
external void _register_async_callback_with_level(
  common.LogCallback cb,
  int level,
);

void register_async_callback_with_level(
  common.LogCallback cb,
  LogLevel level,
) => _register_async_callback_with_level(cb, level.value);

@ffi.Native<ffi.Void Function(common.LogCallback, ffi.UnsignedInt)>(
  symbol: 'register_sync_callback_with_level',
)
external void _register_sync_callback_with_level(
  common.LogCallback cb,
  int level,
);

void register_sync_callback_with_level(common.LogCallback cb, LogLevel level) =>
    _register_sync_callback_with_level(cb, level.value);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>()
external void free_log_memory(ffi.Pointer<ffi.Void> ptr);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Int)>()
external void free_log_memory_batch(
  ffi.Pointer<ffi.Pointer<ffi.Void>> ptr,
  int count,
);

/// Initializes the ZTR tool library (registers code pages).
@ffi.Native<ffi.Void Function()>()
external void ztr_init();

/// Extracts a ZTR file to TXT (on disk).
/// @param inZtrFile Path to the input .ztr file.
/// @param gameCode Game code switch.
/// @param encodingSwitch Encoding switch.
/// @return Result object (success or error).
@ffi.Native<common.Result Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int)>()
external common.Result ztr_extract(
  ffi.Pointer<ffi.Char> inZtrFile,
  int gameCode,
  int encodingSwitch,
);

/// Extracts a ZTR file and returns the parsed data in memory.
/// @param inZtrFile Path to the input .ztr file.
/// @param gameCode Game code switch.
/// @param encodingSwitch Encoding switch.
/// @return Result containing pointer to ZtrResultData.
/// Use free_result() to free the entire structure.
@ffi.Native<common.Result Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int)>()
external common.Result ztr_extract_data(
  ffi.Pointer<ffi.Char> inZtrFile,
  int gameCode,
  int encodingSwitch,
);

/// Converts a TXT file to ZTR.
/// @param inTxtFile Path to the input .txt file.
/// @param gameCode Game code switch.
/// @param encodingSwitch Encoding switch.
/// @param actionSwitch Action switch (compress/uncompress).
/// @return Result object (success or error).
@ffi.Native<
  common.Result Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int, ffi.Int)
>()
external common.Result ztr_convert(
  ffi.Pointer<ffi.Char> inTxtFile,
  int gameCode,
  int encodingSwitch,
  int actionSwitch,
);

/// Packs ZtrResultData into a .ZTR file.
/// @param data Pointer to ZtrResultData structure.
/// @param outZtrFile Path to the output .ztr file.
/// @param gameCode Game code switch.
/// @param encodingSwitch Encoding switch.
/// @param actionSwitch Action switch (compress/uncompress).
/// @return Result object (success or error).
@ffi.Native<
  common.Result Function(
    ffi.Pointer<ZtrResultData>,
    ffi.Pointer<ffi.Char>,
    ffi.Int,
    ffi.Int,
    ffi.Int,
  )
>()
external common.Result ztr_pack_data(
  ffi.Pointer<ZtrResultData> data,
  ffi.Pointer<ffi.Char> outZtrFile,
  int gameCode,
  int encodingSwitch,
  int actionSwitch,
);

/// Dumps ZtrResultData to a text file (ID |:| Text).
/// @param data Pointer to ZtrResultData structure.
/// @param outTxtFile Path to the output .txt file.
/// @return Result object (success or error).
@ffi.Native<
  common.Result Function(ffi.Pointer<ZtrResultData>, ffi.Pointer<ffi.Char>)
>()
external common.Result ztr_dump_data(
  ffi.Pointer<ZtrResultData> data,
  ffi.Pointer<ffi.Char> outTxtFile,
);

enum LogLevel {
  Finest(0),
  Fine(1),
  Info(2),
  Warn(3),
  Fatal(4);

  final int value;
  const LogLevel(this.value);

  static LogLevel fromValue(int value) => switch (value) {
    0 => Finest,
    1 => Fine,
    2 => Info,
    3 => Warn,
    4 => Fatal,
    _ => throw ArgumentError('Unknown value for LogLevel: $value'),
  };
}

enum ZTRAction {
  ZTR_ACTION_X(0),
  ZTR_ACTION_C(1),
  ZTR_ACTION_C2(2);

  final int value;
  const ZTRAction(this.value);

  static ZTRAction fromValue(int value) => switch (value) {
    0 => ZTR_ACTION_X,
    1 => ZTR_ACTION_C,
    2 => ZTR_ACTION_C2,
    _ => throw ArgumentError('Unknown value for ZTRAction: $value'),
  };
}

enum ZTRGameCode {
  ZTR_GAME_FF13_1(0),
  ZTR_GAME_FF13_2(1),
  ZTR_GAME_FF13_3(2);

  final int value;
  const ZTRGameCode(this.value);

  static ZTRGameCode fromValue(int value) => switch (value) {
    0 => ZTR_GAME_FF13_1,
    1 => ZTR_GAME_FF13_2,
    2 => ZTR_GAME_FF13_3,
    _ => throw ArgumentError('Unknown value for ZTRGameCode: $value'),
  };
}

enum ZTREncoding {
  ZTR_ENCODING_AUTO(0),
  ZTR_ENCODING_CH(1),
  ZTR_ENCODING_KR(2),
  ZTR_ENCODING_LJ(3);

  final int value;
  const ZTREncoding(this.value);

  static ZTREncoding fromValue(int value) => switch (value) {
    0 => ZTR_ENCODING_AUTO,
    1 => ZTR_ENCODING_CH,
    2 => ZTR_ENCODING_KR,
    3 => ZTR_ENCODING_LJ,
    _ => throw ArgumentError('Unknown value for ZTREncoding: $value'),
  };
}

final class ZtrEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Char> id;

  external ffi.Pointer<ffi.Char> text;
}

final class ZtrKeyMapping extends ffi.Struct {
  external ffi.Pointer<ffi.Char> key;

  external ffi.Pointer<ffi.Char> value;
}

final class ZtrResultData extends ffi.Struct {
  external ffi.Pointer<ZtrEntry> entries;

  @ffi.Int()
  external int entry_count;

  external ffi.Pointer<ZtrKeyMapping> mappings;

  @ffi.Int()
  external int mapping_count;
}

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'package:oracle_drive/src/third_party/common.g.dart' as common;
import 'dart:ffi' as ffi;

@ffi.Native<ffi.Void Function(common.Result)>()
external void free_result(common.Result result);

@ffi.Native<ffi.Void Function(common.LogCallback)>()
external void register_async_callback(common.LogCallback cb);

@ffi.Native<ffi.Void Function(common.LogCallback)>()
external void register_sync_callback(common.LogCallback cb);

@ffi.Native<ffi.Void Function(common.LogCallback, ffi.UnsignedInt)>(
  symbol: 'register_async_callback_with_level',
)
external void _register_async_callback_with_level(
  common.LogCallback cb,
  int level,
);

void register_async_callback_with_level(
  common.LogCallback cb,
  LogLevel level,
) => _register_async_callback_with_level(cb, level.value);

@ffi.Native<ffi.Void Function(common.LogCallback, ffi.UnsignedInt)>(
  symbol: 'register_sync_callback_with_level',
)
external void _register_sync_callback_with_level(
  common.LogCallback cb,
  int level,
);

void register_sync_callback_with_level(common.LogCallback cb, LogLevel level) =>
    _register_sync_callback_with_level(cb, level.value);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>()
external void free_log_memory(ffi.Pointer<ffi.Void> ptr);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Int)>()
external void free_log_memory_batch(
  ffi.Pointer<ffi.Pointer<ffi.Void>> ptr,
  int count,
);

/// @brief Repacks all files from a directory into a new WhiteBin.
/// Corresponds to RepackTypeA.
@ffi.Native<
  common.Result Function(
    ffi.UnsignedInt,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Bool,
  )
>(symbol: 'repack_all')
external common.Result _repack_all(
  int game_code,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> src_dir,
  bool make_backup,
);

common.Result repack_all(
  GameCode game_code,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> src_dir,
  bool make_backup,
) => _repack_all(game_code.value, filelist_path, src_dir, make_backup);

/// @brief Repacks a single file into an existing WhiteBin.
/// Corresponds to RepackTypeB.
@ffi.Native<
  common.Result Function(
    ffi.UnsignedInt,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Bool,
  )
>(symbol: 'repack_single')
external common.Result _repack_single(
  int game_code,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> bin_path,
  ffi.Pointer<ffi.Char> target_file,
  bool make_backup,
);

common.Result repack_single(
  GameCode game_code,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> bin_path,
  ffi.Pointer<ffi.Char> target_file,
  bool make_backup,
) => _repack_single(
  game_code.value,
  filelist_path,
  bin_path,
  target_file,
  make_backup,
);

/// @brief Repacks multiple detected files into an existing WhiteBin.
/// Corresponds to RepackTypeC.
@ffi.Native<
  common.Result Function(
    ffi.UnsignedInt,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Bool,
  )
>(symbol: 'repack_multiple')
external common.Result _repack_multiple(
  int game_code,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> bin_path,
  ffi.Pointer<ffi.Char> extract_dir,
  bool make_backup,
);

common.Result repack_multiple(
  GameCode game_code,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> bin_path,
  ffi.Pointer<ffi.Char> extract_dir,
  bool make_backup,
) => _repack_multiple(
  game_code.value,
  filelist_path,
  bin_path,
  extract_dir,
  make_backup,
);

/// @brief Repacks a filelist from raw Text Chunk files.
/// Corresponds to RepackTypeD.
@ffi.Native<
  common.Result Function(ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Bool)
>(symbol: 'repack_filelist_from_chunks')
external common.Result _repack_filelist_from_chunks(
  int game_code,
  ffi.Pointer<ffi.Char> chunk_dir,
  bool make_backup,
);

common.Result repack_filelist_from_chunks(
  GameCode game_code,
  ffi.Pointer<ffi.Char> chunk_dir,
  bool make_backup,
) => _repack_filelist_from_chunks(game_code.value, chunk_dir, make_backup);

/// @brief Repacks a filelist from a JSON source file.
/// Corresponds to RepackTypeE.
@ffi.Native<
  common.Result Function(ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Bool)
>(symbol: 'repack_filelist_from_json')
external common.Result _repack_filelist_from_json(
  int game_code,
  ffi.Pointer<ffi.Char> json_path,
  bool make_backup,
);

common.Result repack_filelist_from_json(
  GameCode game_code,
  ffi.Pointer<ffi.Char> json_path,
  bool make_backup,
) => _repack_filelist_from_json(game_code.value, json_path, make_backup);

/// @brief Parses the filelist and returns metadata for all files.
/// @warning You MUST call free_result() on the result to avoid memory leaks.
@ffi.Native<common.Result Function(ffi.UnsignedInt, ffi.Pointer<ffi.Char>)>(
  symbol: 'get_file_metadata',
)
external common.Result _get_file_metadata(
  int gameCodeRaw,
  ffi.Pointer<ffi.Char> filelist_path,
);

common.Result get_file_metadata(
  GameCode gameCodeRaw,
  ffi.Pointer<ffi.Char> filelist_path,
) => _get_file_metadata(gameCodeRaw.value, filelist_path);

/// @brief Extracts all files found in the filelist.
@ffi.Native<
  common.Result Function(
    ffi.UnsignedInt,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
  )
>(symbol: 'unpack_all')
external common.Result _unpack_all(
  int gameCodeRaw,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> white_bin_path,
);

common.Result unpack_all(
  GameCode gameCodeRaw,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> white_bin_path,
) => _unpack_all(gameCodeRaw.value, filelist_path, white_bin_path);

/// @brief Extracts all files found in the filelist to specified outDir.
@ffi.Native<
  common.Result Function(
    ffi.UnsignedInt,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
  )
>(symbol: 'unpack_all_to_path')
external common.Result _unpack_all_to_path(
  int gameCodeRaw,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> white_bin_path,
  ffi.Pointer<ffi.Char> outDir,
);

common.Result unpack_all_to_path(
  GameCode gameCodeRaw,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> white_bin_path,
  ffi.Pointer<ffi.Char> outDir,
) => _unpack_all_to_path(
  gameCodeRaw.value,
  filelist_path,
  white_bin_path,
  outDir,
);

/// @brief Extracts a single file based on exact internal path matching.
@ffi.Native<
  common.Result Function(
    ffi.UnsignedInt,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
  )
>(symbol: 'unpack_single')
external common.Result _unpack_single(
  int gameCodeRaw,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> white_bin_path,
  ffi.Pointer<ffi.Char> target_path,
);

common.Result unpack_single(
  GameCode gameCodeRaw,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> white_bin_path,
  ffi.Pointer<ffi.Char> target_path,
) => _unpack_single(
  gameCodeRaw.value,
  filelist_path,
  white_bin_path,
  target_path,
);

/// @brief Extracts a single file based on exact internal path matching to specified outDir.
@ffi.Native<
  common.Result Function(
    ffi.UnsignedInt,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
  )
>(symbol: 'unpack_single_to_path')
external common.Result _unpack_single_to_path(
  int gameCodeRaw,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> white_bin_path,
  ffi.Pointer<ffi.Char> target_path,
  ffi.Pointer<ffi.Char> outDir,
);

common.Result unpack_single_to_path(
  GameCode gameCodeRaw,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> white_bin_path,
  ffi.Pointer<ffi.Char> target_path,
  ffi.Pointer<ffi.Char> outDir,
) => _unpack_single_to_path(
  gameCodeRaw.value,
  filelist_path,
  white_bin_path,
  target_path,
  outDir,
);

/// @brief Extracts multiple files matching a directory pattern.
@ffi.Native<
  common.Result Function(
    ffi.UnsignedInt,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
  )
>(symbol: 'unpack_multiple')
external common.Result _unpack_multiple(
  int gameCodeRaw,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> white_bin_path,
  ffi.Pointer<ffi.Char> directory_filter,
);

common.Result unpack_multiple(
  GameCode gameCodeRaw,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> white_bin_path,
  ffi.Pointer<ffi.Char> directory_filter,
) => _unpack_multiple(
  gameCodeRaw.value,
  filelist_path,
  white_bin_path,
  directory_filter,
);

/// @brief Extracts multiple files matching a directory pattern to specified outDir.
@ffi.Native<
  common.Result Function(
    ffi.UnsignedInt,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
  )
>(symbol: 'unpack_multiple_to_path')
external common.Result _unpack_multiple_to_path(
  int gameCodeRaw,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> white_bin_path,
  ffi.Pointer<ffi.Char> directory_filter,
  ffi.Pointer<ffi.Char> outDir,
);

common.Result unpack_multiple_to_path(
  GameCode gameCodeRaw,
  ffi.Pointer<ffi.Char> filelist_path,
  ffi.Pointer<ffi.Char> white_bin_path,
  ffi.Pointer<ffi.Char> directory_filter,
  ffi.Pointer<ffi.Char> outDir,
) => _unpack_multiple_to_path(
  gameCodeRaw.value,
  filelist_path,
  white_bin_path,
  directory_filter,
  outDir,
);

enum LogLevel {
  Finest(0),
  Fine(1),
  Info(2),
  Warn(3),
  Fatal(4);

  final int value;
  const LogLevel(this.value);

  static LogLevel fromValue(int value) => switch (value) {
    0 => Finest,
    1 => Fine,
    2 => Info,
    3 => Warn,
    4 => Fatal,
    _ => throw ArgumentError('Unknown value for LogLevel: $value'),
  };
}

enum GameCode {
  FF131(0),
  FF132(1);

  final int value;
  const GameCode(this.value);

  static GameCode fromValue(int value) => switch (value) {
    0 => FF131,
    1 => FF132,
    _ => throw ArgumentError('Unknown value for GameCode: $value'),
  };
}

final class FileEntry extends ffi.Struct {
  @ffi.Int()
  external int chunk_index;

  @ffi.UnsignedLong()
  external int file_code;

  @ffi.UnsignedInt()
  external int file_type_id;

  external ffi.Pointer<ffi.Char> file_path;
}

final class FileEntryList extends ffi.Struct {
  external ffi.Pointer<FileEntry> items;

  @ffi.Int()
  external int count;
}

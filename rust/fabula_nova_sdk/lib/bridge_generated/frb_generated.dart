// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'modules/crystalium/structs.dart';
import 'modules/event/structs.dart';
import 'modules/img/structs.dart';
import 'modules/scd/structs.dart';
import 'modules/vfx/structs.dart';
import 'modules/wct.dart';
import 'modules/wdb/enums.dart';
import 'modules/wdb/structs.dart';
import 'modules/wpd/structs.dart';
import 'modules/ztr/structs.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => -1916094208;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'fabula_nova_sdk',
    ioDirectory: 'target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<CgtFile> crateApiCgtFromJson({required String json});

  Future<CgtFile> crateApiCgtParse({required String inFile});

  Future<CgtFile> crateApiCgtParseFromMemory({required List<int> data});

  Future<String> crateApiCgtToJson({required CgtFile cgt});

  Future<List<String>> crateApiCgtValidate({required CgtFile cgt});

  Future<void> crateApiCgtWrite(
      {required CgtFile cgt, required String outFile});

  Future<Uint8List> crateApiCgtWriteToMemory({required CgtFile cgt});

  Future<void> crateApiClearLogCallback();

  Future<(int, int)> crateApiConvertDdsToPng(
      {required String ddsPath, required String pngPath});

  Future<((int, int), Uint8List)> crateApiConvertDdsToPngBytes(
      {required String ddsPath});

  Stream<String> crateApiCreateLogStream();

  Future<String> crateApiEventExportJson({required String inFile});

  Future<ExtractedEvent> crateApiEventExtract(
      {required String inFile, required String outDir});

  Future<EventSummary> crateApiEventGetSummary({required String inFile});

  Future<EventMetadata> crateApiEventParse({required String inFile});

  Future<EventMetadata> crateApiEventParseDirectory({required String dirPath});

  Future<EventMetadata> crateApiEventParseFromMemory(
      {required List<int> data, String? name});

  Future<List<String>> crateApiFetchLogs();

  Future<List<String>> crateApiGetAllBufferedLogs();

  Future<int> crateApiGetLogLevel();

  Future<void> crateApiImgRepackStrict(
      {required String headerFile,
      required String imgbFile,
      required String inDds});

  Future<ImgData> crateApiImgUnpack(
      {required String headerFile,
      required String imgbFile,
      required String outDds});

  Future<(ImgData, Uint8List)> crateApiImgUnpackToMemory(
      {required String headerFile, required String imgbFile});

  Future<void> crateApiInitApp();

  Future<McpFile> crateApiMcpFromJson({required String json});

  Future<McpFile> crateApiMcpParse({required String inFile});

  Future<McpFile> crateApiMcpParseFromMemory({required List<int> data});

  Future<String> crateApiMcpToJson({required McpFile mcp});

  Future<void> crateApiResetLogReadIndex();

  Future<Uint8List> crateApiScdBytesToWav(
      {required List<int> data, required String name});

  Future<ScdExtractResult> crateApiScdDecode({required String inFile});

  Future<ScdExtractResult> crateApiScdDecodeFromMemory(
      {required List<int> data, required String name});

  Future<DecodedAudio> crateApiScdDecodeStream(
      {required String inFile, required int streamIndex});

  Future<void> crateApiScdExtractToWav(
      {required String scdPath, required String wavPath});

  Future<ScdMetadata> crateApiScdParse({required String inFile});

  Future<ScdMetadata> crateApiScdParseFromMemory(
      {required List<int> data, required String name});

  Future<Uint8List> crateApiScdToWav({required String inFile});

  Future<void> crateApiSetLogLevel({required int level});

  Future<void> crateApiTestLog({required String message});

  Future<String> crateApiVfxExportJson({required String inFile});

  Future<((int, int), Uint8List)> crateApiVfxExtractTextureAsPng(
      {required String xfvPath, required String textureName});

  Future<List<String>> crateApiVfxExtractTextures(
      {required String xfvPath, required String outputDir});

  Future<VfxSummary> crateApiVfxGetSummary({required String inFile});

  Future<List<String>> crateApiVfxListEffects({required String inFile});

  Future<List<VfxTexture>> crateApiVfxListTextures({required String inFile});

  Future<VfxData> crateApiVfxParse({required String inFile});

  Future<void> crateApiWavToScd(
      {required String wavPath, required String scdPath});

  Future<void> crateApiWbtExtract(
      {required String filelistPath,
      required String containerPath,
      required String outDir,
      required int gameCode});

  Future<BigInt> crateApiWbtExtractDirectory(
      {required String filelistPath,
      required String containerPath,
      required String dirPrefix,
      required String outputDir,
      required int gameCode});

  Future<void> crateApiWbtExtractFileByIndex(
      {required String filelistPath,
      required String containerPath,
      required BigInt fileIndex,
      required String outputDir,
      required int gameCode});

  Future<BigInt> crateApiWbtExtractFilesByIndices(
      {required String filelistPath,
      required String containerPath,
      required Uint64List indices,
      required String outputDir,
      required int gameCode});

  Future<void> crateApiWbtExtractSingleFile(
      {required String filelistPath,
      required String containerPath,
      required String virtualPath,
      required String outputPath,
      required int gameCode});

  Future<List<WbtFileEntry>> crateApiWbtGetFileList(
      {required String filelistPath, required int gameCode});

  Future<void> crateApiWbtRepack(
      {required String filelistPath,
      required String containerPath,
      required String extractedDir,
      required int gameCode});

  Future<void> crateApiWbtRepackMultiple(
      {required String filelistPath,
      required String containerPath,
      required List<(String, String)> filesToPatch,
      required int gameCode});

  Future<void> crateApiWbtRepackSingle(
      {required String filelistPath,
      required String containerPath,
      required String targetPathInArchive,
      required String fileToInject,
      required int gameCode});

  Future<void> crateApiWctProcess(
      {required TargetType target,
      required Action action,
      required String inputFile});

  Future<WdbData> crateApiWdbFromJson({required String json});

  Future<WdbData> crateApiWdbParse(
      {required String inFile, required int gameCode});

  Future<void> crateApiWdbRepack(
      {required WdbData data, required String outFile});

  Future<String> crateApiWdbToJson({required WdbData data});

  Future<void> crateApiWpdRepack(
      {required String inDir, required String outFile});

  Future<WpdData> crateApiWpdUnpack(
      {required String inFile, required String outDir});

  Future<void> crateApiZtrExtractToText(
      {required String inFile, required String outFile, required int gameCode});

  Future<void> crateApiZtrPackFromData(
      {required List<(String, String)> entries,
      required String outFile,
      required int gameCode});

  Future<void> crateApiZtrPackFromStruct(
      {required ZtrData data, required String outFile, required int gameCode});

  Future<ZtrData> crateApiZtrParse(
      {required String inFile, required int gameCode});

  Stream<ZtrParseProgress> crateApiZtrParseDirectory(
      {required String dirPath, required int gameCode});

  Future<ZtrDirectoryResult> crateApiZtrParseDirectorySimple(
      {required String dirPath, required int gameCode});

  Future<ZtrData> crateApiZtrParseFromMemory(
      {required List<int> data, required int gameCode});

  Future<String> crateApiZtrToTextString({required ZtrData data});
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<CgtFile> crateApiCgtFromJson({required String json}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(json, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_cgt_file,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCgtFromJsonConstMeta,
      argValues: [json],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCgtFromJsonConstMeta => const TaskConstMeta(
        debugName: "cgt_from_json",
        argNames: ["json"],
      );

  @override
  Future<CgtFile> crateApiCgtParse({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_cgt_file,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCgtParseConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCgtParseConstMeta => const TaskConstMeta(
        debugName: "cgt_parse",
        argNames: ["inFile"],
      );

  @override
  Future<CgtFile> crateApiCgtParseFromMemory({required List<int> data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_cgt_file,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCgtParseFromMemoryConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCgtParseFromMemoryConstMeta => const TaskConstMeta(
        debugName: "cgt_parse_from_memory",
        argNames: ["data"],
      );

  @override
  Future<String> crateApiCgtToJson({required CgtFile cgt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_cgt_file(cgt, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCgtToJsonConstMeta,
      argValues: [cgt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCgtToJsonConstMeta => const TaskConstMeta(
        debugName: "cgt_to_json",
        argNames: ["cgt"],
      );

  @override
  Future<List<String>> crateApiCgtValidate({required CgtFile cgt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_cgt_file(cgt, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCgtValidateConstMeta,
      argValues: [cgt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCgtValidateConstMeta => const TaskConstMeta(
        debugName: "cgt_validate",
        argNames: ["cgt"],
      );

  @override
  Future<void> crateApiCgtWrite(
      {required CgtFile cgt, required String outFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_cgt_file(cgt, serializer);
        sse_encode_String(outFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCgtWriteConstMeta,
      argValues: [cgt, outFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCgtWriteConstMeta => const TaskConstMeta(
        debugName: "cgt_write",
        argNames: ["cgt", "outFile"],
      );

  @override
  Future<Uint8List> crateApiCgtWriteToMemory({required CgtFile cgt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_cgt_file(cgt, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCgtWriteToMemoryConstMeta,
      argValues: [cgt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCgtWriteToMemoryConstMeta => const TaskConstMeta(
        debugName: "cgt_write_to_memory",
        argNames: ["cgt"],
      );

  @override
  Future<void> crateApiClearLogCallback() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiClearLogCallbackConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiClearLogCallbackConstMeta => const TaskConstMeta(
        debugName: "clear_log_callback",
        argNames: [],
      );

  @override
  Future<(int, int)> crateApiConvertDdsToPng(
      {required String ddsPath, required String pngPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(ddsPath, serializer);
        sse_encode_String(pngPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_u_32_u_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiConvertDdsToPngConstMeta,
      argValues: [ddsPath, pngPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiConvertDdsToPngConstMeta => const TaskConstMeta(
        debugName: "convert_dds_to_png",
        argNames: ["ddsPath", "pngPath"],
      );

  @override
  Future<((int, int), Uint8List)> crateApiConvertDdsToPngBytes(
      {required String ddsPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(ddsPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_record_record_u_32_u_32_list_prim_u_8_strict,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiConvertDdsToPngBytesConstMeta,
      argValues: [ddsPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiConvertDdsToPngBytesConstMeta =>
      const TaskConstMeta(
        debugName: "convert_dds_to_png_bytes",
        argNames: ["ddsPath"],
      );

  @override
  Stream<String> crateApiCreateLogStream() {
    final sink = RustStreamSink<String>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_StreamSink_String_Sse(sink, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCreateLogStreamConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiCreateLogStreamConstMeta => const TaskConstMeta(
        debugName: "create_log_stream",
        argNames: ["sink"],
      );

  @override
  Future<String> crateApiEventExportJson({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEventExportJsonConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEventExportJsonConstMeta => const TaskConstMeta(
        debugName: "event_export_json",
        argNames: ["inFile"],
      );

  @override
  Future<ExtractedEvent> crateApiEventExtract(
      {required String inFile, required String outDir}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        sse_encode_String(outDir, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_extracted_event,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEventExtractConstMeta,
      argValues: [inFile, outDir],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEventExtractConstMeta => const TaskConstMeta(
        debugName: "event_extract",
        argNames: ["inFile", "outDir"],
      );

  @override
  Future<EventSummary> crateApiEventGetSummary({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_event_summary,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEventGetSummaryConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEventGetSummaryConstMeta => const TaskConstMeta(
        debugName: "event_get_summary",
        argNames: ["inFile"],
      );

  @override
  Future<EventMetadata> crateApiEventParse({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_event_metadata,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEventParseConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEventParseConstMeta => const TaskConstMeta(
        debugName: "event_parse",
        argNames: ["inFile"],
      );

  @override
  Future<EventMetadata> crateApiEventParseDirectory({required String dirPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dirPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_event_metadata,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEventParseDirectoryConstMeta,
      argValues: [dirPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEventParseDirectoryConstMeta =>
      const TaskConstMeta(
        debugName: "event_parse_directory",
        argNames: ["dirPath"],
      );

  @override
  Future<EventMetadata> crateApiEventParseFromMemory(
      {required List<int> data, String? name}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(data, serializer);
        sse_encode_opt_String(name, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_event_metadata,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEventParseFromMemoryConstMeta,
      argValues: [data, name],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEventParseFromMemoryConstMeta =>
      const TaskConstMeta(
        debugName: "event_parse_from_memory",
        argNames: ["data", "name"],
      );

  @override
  Future<List<String>> crateApiFetchLogs() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFetchLogsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFetchLogsConstMeta => const TaskConstMeta(
        debugName: "fetch_logs",
        argNames: [],
      );

  @override
  Future<List<String>> crateApiGetAllBufferedLogs() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetAllBufferedLogsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetAllBufferedLogsConstMeta => const TaskConstMeta(
        debugName: "get_all_buffered_logs",
        argNames: [],
      );

  @override
  Future<int> crateApiGetLogLevel() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetLogLevelConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetLogLevelConstMeta => const TaskConstMeta(
        debugName: "get_log_level",
        argNames: [],
      );

  @override
  Future<void> crateApiImgRepackStrict(
      {required String headerFile,
      required String imgbFile,
      required String inDds}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(headerFile, serializer);
        sse_encode_String(imgbFile, serializer);
        sse_encode_String(inDds, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiImgRepackStrictConstMeta,
      argValues: [headerFile, imgbFile, inDds],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiImgRepackStrictConstMeta => const TaskConstMeta(
        debugName: "img_repack_strict",
        argNames: ["headerFile", "imgbFile", "inDds"],
      );

  @override
  Future<ImgData> crateApiImgUnpack(
      {required String headerFile,
      required String imgbFile,
      required String outDds}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(headerFile, serializer);
        sse_encode_String(imgbFile, serializer);
        sse_encode_String(outDds, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_img_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiImgUnpackConstMeta,
      argValues: [headerFile, imgbFile, outDds],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiImgUnpackConstMeta => const TaskConstMeta(
        debugName: "img_unpack",
        argNames: ["headerFile", "imgbFile", "outDds"],
      );

  @override
  Future<(ImgData, Uint8List)> crateApiImgUnpackToMemory(
      {required String headerFile, required String imgbFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(headerFile, serializer);
        sse_encode_String(imgbFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_img_data_list_prim_u_8_strict,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiImgUnpackToMemoryConstMeta,
      argValues: [headerFile, imgbFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiImgUnpackToMemoryConstMeta => const TaskConstMeta(
        debugName: "img_unpack_to_memory",
        argNames: ["headerFile", "imgbFile"],
      );

  @override
  Future<void> crateApiInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Future<McpFile> crateApiMcpFromJson({required String json}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(json, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_mcp_file,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMcpFromJsonConstMeta,
      argValues: [json],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMcpFromJsonConstMeta => const TaskConstMeta(
        debugName: "mcp_from_json",
        argNames: ["json"],
      );

  @override
  Future<McpFile> crateApiMcpParse({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_mcp_file,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMcpParseConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMcpParseConstMeta => const TaskConstMeta(
        debugName: "mcp_parse",
        argNames: ["inFile"],
      );

  @override
  Future<McpFile> crateApiMcpParseFromMemory({required List<int> data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_mcp_file,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMcpParseFromMemoryConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMcpParseFromMemoryConstMeta => const TaskConstMeta(
        debugName: "mcp_parse_from_memory",
        argNames: ["data"],
      );

  @override
  Future<String> crateApiMcpToJson({required McpFile mcp}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_mcp_file(mcp, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMcpToJsonConstMeta,
      argValues: [mcp],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMcpToJsonConstMeta => const TaskConstMeta(
        debugName: "mcp_to_json",
        argNames: ["mcp"],
      );

  @override
  Future<void> crateApiResetLogReadIndex() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiResetLogReadIndexConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiResetLogReadIndexConstMeta => const TaskConstMeta(
        debugName: "reset_log_read_index",
        argNames: [],
      );

  @override
  Future<Uint8List> crateApiScdBytesToWav(
      {required List<int> data, required String name}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(data, serializer);
        sse_encode_String(name, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiScdBytesToWavConstMeta,
      argValues: [data, name],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiScdBytesToWavConstMeta => const TaskConstMeta(
        debugName: "scd_bytes_to_wav",
        argNames: ["data", "name"],
      );

  @override
  Future<ScdExtractResult> crateApiScdDecode({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_scd_extract_result,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiScdDecodeConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiScdDecodeConstMeta => const TaskConstMeta(
        debugName: "scd_decode",
        argNames: ["inFile"],
      );

  @override
  Future<ScdExtractResult> crateApiScdDecodeFromMemory(
      {required List<int> data, required String name}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(data, serializer);
        sse_encode_String(name, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_scd_extract_result,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiScdDecodeFromMemoryConstMeta,
      argValues: [data, name],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiScdDecodeFromMemoryConstMeta =>
      const TaskConstMeta(
        debugName: "scd_decode_from_memory",
        argNames: ["data", "name"],
      );

  @override
  Future<DecodedAudio> crateApiScdDecodeStream(
      {required String inFile, required int streamIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        sse_encode_u_32(streamIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_decoded_audio,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiScdDecodeStreamConstMeta,
      argValues: [inFile, streamIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiScdDecodeStreamConstMeta => const TaskConstMeta(
        debugName: "scd_decode_stream",
        argNames: ["inFile", "streamIndex"],
      );

  @override
  Future<void> crateApiScdExtractToWav(
      {required String scdPath, required String wavPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(scdPath, serializer);
        sse_encode_String(wavPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiScdExtractToWavConstMeta,
      argValues: [scdPath, wavPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiScdExtractToWavConstMeta => const TaskConstMeta(
        debugName: "scd_extract_to_wav",
        argNames: ["scdPath", "wavPath"],
      );

  @override
  Future<ScdMetadata> crateApiScdParse({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_scd_metadata,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiScdParseConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiScdParseConstMeta => const TaskConstMeta(
        debugName: "scd_parse",
        argNames: ["inFile"],
      );

  @override
  Future<ScdMetadata> crateApiScdParseFromMemory(
      {required List<int> data, required String name}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(data, serializer);
        sse_encode_String(name, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_scd_metadata,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiScdParseFromMemoryConstMeta,
      argValues: [data, name],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiScdParseFromMemoryConstMeta => const TaskConstMeta(
        debugName: "scd_parse_from_memory",
        argNames: ["data", "name"],
      );

  @override
  Future<Uint8List> crateApiScdToWav({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiScdToWavConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiScdToWavConstMeta => const TaskConstMeta(
        debugName: "scd_to_wav",
        argNames: ["inFile"],
      );

  @override
  Future<void> crateApiSetLogLevel({required int level}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(level, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 38, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSetLogLevelConstMeta,
      argValues: [level],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetLogLevelConstMeta => const TaskConstMeta(
        debugName: "set_log_level",
        argNames: ["level"],
      );

  @override
  Future<void> crateApiTestLog({required String message}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(message, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 39, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiTestLogConstMeta,
      argValues: [message],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTestLogConstMeta => const TaskConstMeta(
        debugName: "test_log",
        argNames: ["message"],
      );

  @override
  Future<String> crateApiVfxExportJson({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 40, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxExportJsonConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxExportJsonConstMeta => const TaskConstMeta(
        debugName: "vfx_export_json",
        argNames: ["inFile"],
      );

  @override
  Future<((int, int), Uint8List)> crateApiVfxExtractTextureAsPng(
      {required String xfvPath, required String textureName}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(xfvPath, serializer);
        sse_encode_String(textureName, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 41, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_record_record_u_32_u_32_list_prim_u_8_strict,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxExtractTextureAsPngConstMeta,
      argValues: [xfvPath, textureName],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxExtractTextureAsPngConstMeta =>
      const TaskConstMeta(
        debugName: "vfx_extract_texture_as_png",
        argNames: ["xfvPath", "textureName"],
      );

  @override
  Future<List<String>> crateApiVfxExtractTextures(
      {required String xfvPath, required String outputDir}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(xfvPath, serializer);
        sse_encode_String(outputDir, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 42, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxExtractTexturesConstMeta,
      argValues: [xfvPath, outputDir],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxExtractTexturesConstMeta => const TaskConstMeta(
        debugName: "vfx_extract_textures",
        argNames: ["xfvPath", "outputDir"],
      );

  @override
  Future<VfxSummary> crateApiVfxGetSummary({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 43, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_vfx_summary,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxGetSummaryConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxGetSummaryConstMeta => const TaskConstMeta(
        debugName: "vfx_get_summary",
        argNames: ["inFile"],
      );

  @override
  Future<List<String>> crateApiVfxListEffects({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 44, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxListEffectsConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxListEffectsConstMeta => const TaskConstMeta(
        debugName: "vfx_list_effects",
        argNames: ["inFile"],
      );

  @override
  Future<List<VfxTexture>> crateApiVfxListTextures({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 45, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_vfx_texture,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxListTexturesConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxListTexturesConstMeta => const TaskConstMeta(
        debugName: "vfx_list_textures",
        argNames: ["inFile"],
      );

  @override
  Future<VfxData> crateApiVfxParse({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 46, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_vfx_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxParseConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxParseConstMeta => const TaskConstMeta(
        debugName: "vfx_parse",
        argNames: ["inFile"],
      );

  @override
  Future<void> crateApiWavToScd(
      {required String wavPath, required String scdPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(wavPath, serializer);
        sse_encode_String(scdPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 47, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWavToScdConstMeta,
      argValues: [wavPath, scdPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWavToScdConstMeta => const TaskConstMeta(
        debugName: "wav_to_scd",
        argNames: ["wavPath", "scdPath"],
      );

  @override
  Future<void> crateApiWbtExtract(
      {required String filelistPath,
      required String containerPath,
      required String outDir,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_String(outDir, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 48, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtExtractConstMeta,
      argValues: [filelistPath, containerPath, outDir, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtExtractConstMeta => const TaskConstMeta(
        debugName: "wbt_extract",
        argNames: ["filelistPath", "containerPath", "outDir", "gameCode"],
      );

  @override
  Future<BigInt> crateApiWbtExtractDirectory(
      {required String filelistPath,
      required String containerPath,
      required String dirPrefix,
      required String outputDir,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_String(dirPrefix, serializer);
        sse_encode_String(outputDir, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 49, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtExtractDirectoryConstMeta,
      argValues: [filelistPath, containerPath, dirPrefix, outputDir, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtExtractDirectoryConstMeta =>
      const TaskConstMeta(
        debugName: "wbt_extract_directory",
        argNames: [
          "filelistPath",
          "containerPath",
          "dirPrefix",
          "outputDir",
          "gameCode"
        ],
      );

  @override
  Future<void> crateApiWbtExtractFileByIndex(
      {required String filelistPath,
      required String containerPath,
      required BigInt fileIndex,
      required String outputDir,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_usize(fileIndex, serializer);
        sse_encode_String(outputDir, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 50, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtExtractFileByIndexConstMeta,
      argValues: [filelistPath, containerPath, fileIndex, outputDir, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtExtractFileByIndexConstMeta =>
      const TaskConstMeta(
        debugName: "wbt_extract_file_by_index",
        argNames: [
          "filelistPath",
          "containerPath",
          "fileIndex",
          "outputDir",
          "gameCode"
        ],
      );

  @override
  Future<BigInt> crateApiWbtExtractFilesByIndices(
      {required String filelistPath,
      required String containerPath,
      required Uint64List indices,
      required String outputDir,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_list_prim_usize_strict(indices, serializer);
        sse_encode_String(outputDir, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 51, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtExtractFilesByIndicesConstMeta,
      argValues: [filelistPath, containerPath, indices, outputDir, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtExtractFilesByIndicesConstMeta =>
      const TaskConstMeta(
        debugName: "wbt_extract_files_by_indices",
        argNames: [
          "filelistPath",
          "containerPath",
          "indices",
          "outputDir",
          "gameCode"
        ],
      );

  @override
  Future<void> crateApiWbtExtractSingleFile(
      {required String filelistPath,
      required String containerPath,
      required String virtualPath,
      required String outputPath,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_String(virtualPath, serializer);
        sse_encode_String(outputPath, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 52, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtExtractSingleFileConstMeta,
      argValues: [
        filelistPath,
        containerPath,
        virtualPath,
        outputPath,
        gameCode
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtExtractSingleFileConstMeta =>
      const TaskConstMeta(
        debugName: "wbt_extract_single_file",
        argNames: [
          "filelistPath",
          "containerPath",
          "virtualPath",
          "outputPath",
          "gameCode"
        ],
      );

  @override
  Future<List<WbtFileEntry>> crateApiWbtGetFileList(
      {required String filelistPath, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 53, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_wbt_file_entry,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtGetFileListConstMeta,
      argValues: [filelistPath, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtGetFileListConstMeta => const TaskConstMeta(
        debugName: "wbt_get_file_list",
        argNames: ["filelistPath", "gameCode"],
      );

  @override
  Future<void> crateApiWbtRepack(
      {required String filelistPath,
      required String containerPath,
      required String extractedDir,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_String(extractedDir, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 54, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtRepackConstMeta,
      argValues: [filelistPath, containerPath, extractedDir, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtRepackConstMeta => const TaskConstMeta(
        debugName: "wbt_repack",
        argNames: ["filelistPath", "containerPath", "extractedDir", "gameCode"],
      );

  @override
  Future<void> crateApiWbtRepackMultiple(
      {required String filelistPath,
      required String containerPath,
      required List<(String, String)> filesToPatch,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_list_record_string_string(filesToPatch, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 55, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtRepackMultipleConstMeta,
      argValues: [filelistPath, containerPath, filesToPatch, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtRepackMultipleConstMeta => const TaskConstMeta(
        debugName: "wbt_repack_multiple",
        argNames: ["filelistPath", "containerPath", "filesToPatch", "gameCode"],
      );

  @override
  Future<void> crateApiWbtRepackSingle(
      {required String filelistPath,
      required String containerPath,
      required String targetPathInArchive,
      required String fileToInject,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_String(targetPathInArchive, serializer);
        sse_encode_String(fileToInject, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 56, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtRepackSingleConstMeta,
      argValues: [
        filelistPath,
        containerPath,
        targetPathInArchive,
        fileToInject,
        gameCode
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtRepackSingleConstMeta => const TaskConstMeta(
        debugName: "wbt_repack_single",
        argNames: [
          "filelistPath",
          "containerPath",
          "targetPathInArchive",
          "fileToInject",
          "gameCode"
        ],
      );

  @override
  Future<void> crateApiWctProcess(
      {required TargetType target,
      required Action action,
      required String inputFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_target_type(target, serializer);
        sse_encode_action(action, serializer);
        sse_encode_String(inputFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 57, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWctProcessConstMeta,
      argValues: [target, action, inputFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWctProcessConstMeta => const TaskConstMeta(
        debugName: "wct_process",
        argNames: ["target", "action", "inputFile"],
      );

  @override
  Future<WdbData> crateApiWdbFromJson({required String json}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(json, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 58, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wdb_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWdbFromJsonConstMeta,
      argValues: [json],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWdbFromJsonConstMeta => const TaskConstMeta(
        debugName: "wdb_from_json",
        argNames: ["json"],
      );

  @override
  Future<WdbData> crateApiWdbParse(
      {required String inFile, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 59, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wdb_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWdbParseConstMeta,
      argValues: [inFile, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWdbParseConstMeta => const TaskConstMeta(
        debugName: "wdb_parse",
        argNames: ["inFile", "gameCode"],
      );

  @override
  Future<void> crateApiWdbRepack(
      {required WdbData data, required String outFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_wdb_data(data, serializer);
        sse_encode_String(outFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 60, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWdbRepackConstMeta,
      argValues: [data, outFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWdbRepackConstMeta => const TaskConstMeta(
        debugName: "wdb_repack",
        argNames: ["data", "outFile"],
      );

  @override
  Future<String> crateApiWdbToJson({required WdbData data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_wdb_data(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 61, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWdbToJsonConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWdbToJsonConstMeta => const TaskConstMeta(
        debugName: "wdb_to_json",
        argNames: ["data"],
      );

  @override
  Future<void> crateApiWpdRepack(
      {required String inDir, required String outFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inDir, serializer);
        sse_encode_String(outFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 62, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWpdRepackConstMeta,
      argValues: [inDir, outFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWpdRepackConstMeta => const TaskConstMeta(
        debugName: "wpd_repack",
        argNames: ["inDir", "outFile"],
      );

  @override
  Future<WpdData> crateApiWpdUnpack(
      {required String inFile, required String outDir}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        sse_encode_String(outDir, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 63, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wpd_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWpdUnpackConstMeta,
      argValues: [inFile, outDir],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWpdUnpackConstMeta => const TaskConstMeta(
        debugName: "wpd_unpack",
        argNames: ["inFile", "outDir"],
      );

  @override
  Future<void> crateApiZtrExtractToText(
      {required String inFile,
      required String outFile,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        sse_encode_String(outFile, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 64, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiZtrExtractToTextConstMeta,
      argValues: [inFile, outFile, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrExtractToTextConstMeta => const TaskConstMeta(
        debugName: "ztr_extract_to_text",
        argNames: ["inFile", "outFile", "gameCode"],
      );

  @override
  Future<void> crateApiZtrPackFromData(
      {required List<(String, String)> entries,
      required String outFile,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_record_string_string(entries, serializer);
        sse_encode_String(outFile, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 65, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiZtrPackFromDataConstMeta,
      argValues: [entries, outFile, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrPackFromDataConstMeta => const TaskConstMeta(
        debugName: "ztr_pack_from_data",
        argNames: ["entries", "outFile", "gameCode"],
      );

  @override
  Future<void> crateApiZtrPackFromStruct(
      {required ZtrData data, required String outFile, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ztr_data(data, serializer);
        sse_encode_String(outFile, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 66, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiZtrPackFromStructConstMeta,
      argValues: [data, outFile, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrPackFromStructConstMeta => const TaskConstMeta(
        debugName: "ztr_pack_from_struct",
        argNames: ["data", "outFile", "gameCode"],
      );

  @override
  Future<ZtrData> crateApiZtrParse(
      {required String inFile, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 67, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ztr_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiZtrParseConstMeta,
      argValues: [inFile, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrParseConstMeta => const TaskConstMeta(
        debugName: "ztr_parse",
        argNames: ["inFile", "gameCode"],
      );

  @override
  Stream<ZtrParseProgress> crateApiZtrParseDirectory(
      {required String dirPath, required int gameCode}) {
    final progressSink = RustStreamSink<ZtrParseProgress>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dirPath, serializer);
        sse_encode_i_32(gameCode, serializer);
        sse_encode_StreamSink_ztr_parse_progress_Sse(progressSink, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 68, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ztr_directory_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiZtrParseDirectoryConstMeta,
      argValues: [dirPath, gameCode, progressSink],
      apiImpl: this,
    )));
    return progressSink.stream;
  }

  TaskConstMeta get kCrateApiZtrParseDirectoryConstMeta => const TaskConstMeta(
        debugName: "ztr_parse_directory",
        argNames: ["dirPath", "gameCode", "progressSink"],
      );

  @override
  Future<ZtrDirectoryResult> crateApiZtrParseDirectorySimple(
      {required String dirPath, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dirPath, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 69, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ztr_directory_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiZtrParseDirectorySimpleConstMeta,
      argValues: [dirPath, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrParseDirectorySimpleConstMeta =>
      const TaskConstMeta(
        debugName: "ztr_parse_directory_simple",
        argNames: ["dirPath", "gameCode"],
      );

  @override
  Future<ZtrData> crateApiZtrParseFromMemory(
      {required List<int> data, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(data, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 70, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ztr_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiZtrParseFromMemoryConstMeta,
      argValues: [data, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrParseFromMemoryConstMeta => const TaskConstMeta(
        debugName: "ztr_parse_from_memory",
        argNames: ["data", "gameCode"],
      );

  @override
  Future<String> crateApiZtrToTextString({required ZtrData data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ztr_data(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 71, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiZtrToTextStringConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrToTextStringConstMeta => const TaskConstMeta(
        debugName: "ztr_to_text_string",
        argNames: ["data"],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  Map<String, McpPattern> dco_decode_Map_String_mcp_pattern_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_mcp_pattern(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<String, WdbValue> dco_decode_Map_String_wdb_value_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_wdb_value(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  RustStreamSink<String> dco_decode_StreamSink_String_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<ZtrParseProgress> dco_decode_StreamSink_ztr_parse_progress_Sse(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  Action dco_decode_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Action.values[raw as int];
  }

  @protected
  ActorType dco_decode_actor_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ActorType_Camera();
      case 1:
        return ActorType_Sound();
      case 2:
        return ActorType_Effect();
      case 3:
        return ActorType_Bgm();
      case 4:
        return ActorType_Proxy();
      case 5:
        return ActorType_System();
      case 6:
        return ActorType_Character(
          dco_decode_String(raw[1]),
        );
      case 7:
        return ActorType_Unknown(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  BlockTrack dco_decode_block_track(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return BlockTrack(
      size: dco_decode_u_16(arr[0]),
      trackType: dco_decode_track_type(arr[1]),
      typeCode: dco_decode_u_16(arr[2]),
      flags: dco_decode_u_32(arr[3]),
      index: dco_decode_u_32(arr[4]),
      reference: dco_decode_opt_String(arr[5]),
      startFrame: dco_decode_opt_box_autoadd_u_32(arr[6]),
      durationFrames: dco_decode_opt_box_autoadd_u_32(arr[7]),
      floatValues: dco_decode_list_prim_f_32_strict(arr[8]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  CgtFile dco_decode_box_autoadd_cgt_file(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_cgt_file(raw);
  }

  @protected
  EventDataSet dco_decode_box_autoadd_event_data_set(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_event_data_set(raw);
  }

  @protected
  McpFile dco_decode_box_autoadd_mcp_file(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_mcp_file(raw);
  }

  @protected
  ScheduleHeader dco_decode_box_autoadd_schedule_header(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_schedule_header(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  VfxMesh dco_decode_box_autoadd_vfx_mesh(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_vfx_mesh(raw);
  }

  @protected
  WdbData dco_decode_box_autoadd_wdb_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_wdb_data(raw);
  }

  @protected
  ZtrData dco_decode_box_autoadd_ztr_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ztr_data(raw);
  }

  @protected
  CameraControlBlock dco_decode_camera_control_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return CameraControlBlock(
      name: dco_decode_String(arr[0]),
      sourceFile: dco_decode_String(arr[1]),
      headerSize: dco_decode_u_32(arr[2]),
      dataSize: dco_decode_u_32(arr[3]),
      flags: dco_decode_u_32(arr[4]),
    );
  }

  @protected
  CgtFile dco_decode_cgt_file(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return CgtFile(
      version: dco_decode_u_32(arr[0]),
      entryCount: dco_decode_u_32(arr[1]),
      totalNodes: dco_decode_u_32(arr[2]),
      reserved: dco_decode_u_32(arr[3]),
      entries: dco_decode_list_crystarium_entry(arr[4]),
      nodes: dco_decode_list_crystarium_node(arr[5]),
    );
  }

  @protected
  CrystalNodeType dco_decode_crystal_node_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CrystalNodeType.values[raw as int];
  }

  @protected
  CrystalRole dco_decode_crystal_role(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CrystalRole.values[raw as int];
  }

  @protected
  CrystariumEntry dco_decode_crystarium_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 14)
      throw Exception('unexpected arr length: expect 14 but see ${arr.length}');
    return CrystariumEntry(
      index: dco_decode_u_32(arr[0]),
      patternName: dco_decode_String(arr[1]),
      position: dco_decode_vec_3(arr[2]),
      scale: dco_decode_f_32(arr[3]),
      rotation: dco_decode_vec_3(arr[4]),
      rotationW: dco_decode_f_32(arr[5]),
      nodeScale: dco_decode_f_32(arr[6]),
      roleId: dco_decode_u_8(arr[7]),
      stage: dco_decode_u_8(arr[8]),
      entryType: dco_decode_u_8(arr[9]),
      reserved: dco_decode_u_8(arr[10]),
      nodeIds: dco_decode_list_prim_u_32_strict(arr[11]),
      linkPosition: dco_decode_vec_3(arr[12]),
      linkW: dco_decode_f_32(arr[13]),
    );
  }

  @protected
  CrystariumNode dco_decode_crystarium_node(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return CrystariumNode(
      index: dco_decode_u_32(arr[0]),
      name: dco_decode_String(arr[1]),
      parentIndex: dco_decode_i_32(arr[2]),
      unknown: dco_decode_u_32_array_4(arr[3]),
      scales: dco_decode_f_32_array_4(arr[4]),
    );
  }

  @protected
  DecodedAudio dco_decode_decoded_audio(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return DecodedAudio(
      sampleRate: dco_decode_u_32(arr[0]),
      channels: dco_decode_u_16(arr[1]),
      bitsPerSample: dco_decode_u_16(arr[2]),
      pcmData: dco_decode_list_prim_u_8_strict(arr[3]),
      durationSeconds: dco_decode_f_32(arr[4]),
      originalCodec: dco_decode_String(arr[5]),
    );
  }

  @protected
  DialogueEntry dco_decode_dialogue_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return DialogueEntry(
      recordName: dco_decode_String(arr[0]),
      rawContent: dco_decode_String(arr[1]),
      ztrKey: dco_decode_String(arr[2]),
    );
  }

  @protected
  EventActor dco_decode_event_actor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return EventActor(
      name: dco_decode_String(arr[0]),
      actorType: dco_decode_actor_type(arr[1]),
      index: dco_decode_u_16(arr[2]),
      flags: dco_decode_u_32(arr[3]),
    );
  }

  @protected
  EventBlock dco_decode_event_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return EventBlock(
      name: dco_decode_String(arr[0]),
      id: dco_decode_u_16(arr[1]),
      durationFrames: dco_decode_u_32(arr[2]),
      durationSeconds: dco_decode_f_32(arr[3]),
      trackCount: dco_decode_u_32(arr[4]),
      tracks: dco_decode_list_block_track(arr[5]),
    );
  }

  @protected
  EventDataSet dco_decode_event_data_set(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return EventDataSet(
      motionBlocks: dco_decode_list_motion_control_block(arr[0]),
      cameraBlocks: dco_decode_list_camera_control_block(arr[1]),
      sourceFiles: dco_decode_list_String(arr[2]),
    );
  }

  @protected
  EventMetadata dco_decode_event_metadata(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 15)
      throw Exception('unexpected arr length: expect 15 but see ${arr.length}');
    return EventMetadata(
      name: dco_decode_String(arr[0]),
      sourcePath: dco_decode_String(arr[1]),
      fileSize: dco_decode_u_64(arr[2]),
      recordCount: dco_decode_usize(arr[3]),
      wpdRecords: dco_decode_list_wpd_record_info(arr[4]),
      scheduleHeader: dco_decode_opt_box_autoadd_schedule_header(arr[5]),
      sectionCounts: dco_decode_section_counts(arr[6]),
      externalResources: dco_decode_list_external_resource(arr[7]),
      actors: dco_decode_list_event_actor(arr[8]),
      blocks: dco_decode_list_event_block(arr[9]),
      resources: dco_decode_list_event_resource(arr[10]),
      soundBlocks: dco_decode_list_sound_block(arr[11]),
      soundReferences: dco_decode_list_sound_reference(arr[12]),
      dialogueEntries: dco_decode_list_dialogue_entry(arr[13]),
      dataset: dco_decode_opt_box_autoadd_event_data_set(arr[14]),
    );
  }

  @protected
  EventResource dco_decode_event_resource(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return EventResource(
      name: dco_decode_String(arr[0]),
      resourceType: dco_decode_String(arr[1]),
      externalHash: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  EventSummary dco_decode_event_summary(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return EventSummary(
      name: dco_decode_String(arr[0]),
      actorCount: dco_decode_usize(arr[1]),
      blockCount: dco_decode_usize(arr[2]),
      resourceCount: dco_decode_usize(arr[3]),
      dialogueCount: dco_decode_usize(arr[4]),
      soundBlockCount: dco_decode_usize(arr[5]),
      totalDurationSeconds: dco_decode_f_32(arr[6]),
      hasDataset: dco_decode_bool(arr[7]),
      motionBlockCount: dco_decode_usize(arr[8]),
      cameraBlockCount: dco_decode_usize(arr[9]),
    );
  }

  @protected
  ExternalResource dco_decode_external_resource(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ExternalResource(
      name: dco_decode_String(arr[0]),
      hash: dco_decode_String(arr[1]),
      category: dco_decode_resource_category(arr[2]),
    );
  }

  @protected
  ExtractedEvent dco_decode_extracted_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ExtractedEvent(
      outputDir: dco_decode_String(arr[0]),
      metadata: dco_decode_event_metadata(arr[1]),
      extractedFiles: dco_decode_list_String(arr[2]),
    );
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  F32Array2 dco_decode_f_32_array_2(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return F32Array2(dco_decode_list_prim_f_32_strict(raw));
  }

  @protected
  F32Array3 dco_decode_f_32_array_3(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return F32Array3(dco_decode_list_prim_f_32_strict(raw));
  }

  @protected
  F32Array4 dco_decode_f_32_array_4(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return F32Array4(dco_decode_list_prim_f_32_strict(raw));
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  ImgData dco_decode_img_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ImgData(
      width: dco_decode_u_16(arr[0]),
      height: dco_decode_u_16(arr[1]),
      mipCount: dco_decode_u_8(arr[2]),
      format: dco_decode_String(arr[3]),
    );
  }

  @protected
  List<Map<String, WdbValue>> dco_decode_list_Map_String_wdb_value_None(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_Map_String_wdb_value_None)
        .toList();
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<BlockTrack> dco_decode_list_block_track(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_block_track).toList();
  }

  @protected
  List<CameraControlBlock> dco_decode_list_camera_control_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_camera_control_block).toList();
  }

  @protected
  List<CrystariumEntry> dco_decode_list_crystarium_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_crystarium_entry).toList();
  }

  @protected
  List<CrystariumNode> dco_decode_list_crystarium_node(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_crystarium_node).toList();
  }

  @protected
  List<DecodedAudio> dco_decode_list_decoded_audio(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_decoded_audio).toList();
  }

  @protected
  List<DialogueEntry> dco_decode_list_dialogue_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_dialogue_entry).toList();
  }

  @protected
  List<EventActor> dco_decode_list_event_actor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_event_actor).toList();
  }

  @protected
  List<EventBlock> dco_decode_list_event_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_event_block).toList();
  }

  @protected
  List<EventResource> dco_decode_list_event_resource(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_event_resource).toList();
  }

  @protected
  List<ExternalResource> dco_decode_list_external_resource(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_external_resource).toList();
  }

  @protected
  List<MotionControlBlock> dco_decode_list_motion_control_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_motion_control_block).toList();
  }

  @protected
  Float32List dco_decode_list_prim_f_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Float32List;
  }

  @protected
  Int32List dco_decode_list_prim_i_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Int32List;
  }

  @protected
  Uint16List dco_decode_list_prim_u_16_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint16List;
  }

  @protected
  Uint32List dco_decode_list_prim_u_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint32List;
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  Uint64List dco_decode_list_prim_usize_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint64List;
  }

  @protected
  List<(String, McpPattern)> dco_decode_list_record_string_mcp_pattern(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_string_mcp_pattern)
        .toList();
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  List<(String, WdbValue)> dco_decode_list_record_string_wdb_value(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_string_wdb_value)
        .toList();
  }

  @protected
  List<ScdStreamInfo> dco_decode_list_scd_stream_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_scd_stream_info).toList();
  }

  @protected
  List<SoundBlock> dco_decode_list_sound_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_sound_block).toList();
  }

  @protected
  List<SoundReference> dco_decode_list_sound_reference(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_sound_reference).toList();
  }

  @protected
  List<Vec3> dco_decode_list_vec_3(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_vec_3).toList();
  }

  @protected
  List<VfxAnimation> dco_decode_list_vfx_animation(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_vfx_animation).toList();
  }

  @protected
  List<VfxEffect> dco_decode_list_vfx_effect(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_vfx_effect).toList();
  }

  @protected
  List<VfxModel> dco_decode_list_vfx_model(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_vfx_model).toList();
  }

  @protected
  List<VfxTexture> dco_decode_list_vfx_texture(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_vfx_texture).toList();
  }

  @protected
  List<VfxVertex> dco_decode_list_vfx_vertex(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_vfx_vertex).toList();
  }

  @protected
  List<WbtFileEntry> dco_decode_list_wbt_file_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wbt_file_entry).toList();
  }

  @protected
  List<WpdRecord> dco_decode_list_wpd_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wpd_record).toList();
  }

  @protected
  List<WpdRecordInfo> dco_decode_list_wpd_record_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wpd_record_info).toList();
  }

  @protected
  List<ZtrEntry> dco_decode_list_ztr_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ztr_entry).toList();
  }

  @protected
  List<ZtrEntryWithSource> dco_decode_list_ztr_entry_with_source(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_ztr_entry_with_source)
        .toList();
  }

  @protected
  List<ZtrFileError> dco_decode_list_ztr_file_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ztr_file_error).toList();
  }

  @protected
  List<ZtrMapEntry> dco_decode_list_ztr_map_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ztr_map_entry).toList();
  }

  @protected
  McpFile dco_decode_mcp_file(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return McpFile(
      version: dco_decode_u_32(arr[0]),
      patternCount: dco_decode_u_32(arr[1]),
      reserved: dco_decode_u_32(arr[2]),
      patterns: dco_decode_Map_String_mcp_pattern_None(arr[3]),
    );
  }

  @protected
  McpPattern dco_decode_mcp_pattern(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return McpPattern(
      name: dco_decode_String(arr[0]),
      nodes: dco_decode_list_vec_3(arr[1]),
      count: dco_decode_usize(arr[2]),
    );
  }

  @protected
  MotionControlBlock dco_decode_motion_control_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return MotionControlBlock(
      name: dco_decode_String(arr[0]),
      sourceFile: dco_decode_String(arr[1]),
      headerSize: dco_decode_u_32(arr[2]),
      dataSize: dco_decode_u_32(arr[3]),
      version: dco_decode_u_16(arr[4]),
      flags: dco_decode_u_16(arr[5]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  EventDataSet? dco_decode_opt_box_autoadd_event_data_set(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_event_data_set(raw);
  }

  @protected
  ScheduleHeader? dco_decode_opt_box_autoadd_schedule_header(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_schedule_header(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  VfxMesh? dco_decode_opt_box_autoadd_vfx_mesh(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_vfx_mesh(raw);
  }

  @protected
  (ImgData, Uint8List) dco_decode_record_img_data_list_prim_u_8_strict(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_img_data(arr[0]),
      dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  ((int, int), Uint8List)
      dco_decode_record_record_u_32_u_32_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_record_u_32_u_32(arr[0]),
      dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  (String, McpPattern) dco_decode_record_string_mcp_pattern(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_mcp_pattern(arr[1]),
    );
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_String(arr[1]),
    );
  }

  @protected
  (String, WdbValue) dco_decode_record_string_wdb_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_wdb_value(arr[1]),
    );
  }

  @protected
  (int, int) dco_decode_record_u_32_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_u_32(arr[0]),
      dco_decode_u_32(arr[1]),
    );
  }

  @protected
  ResourceCategory dco_decode_resource_category(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ResourceCategory.values[raw as int];
  }

  @protected
  ScdCodec dco_decode_scd_codec(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ScdCodec.values[raw as int];
  }

  @protected
  ScdExtractResult dco_decode_scd_extract_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ScdExtractResult(
      metadata: dco_decode_scd_metadata(arr[0]),
      audioStreams: dco_decode_list_decoded_audio(arr[1]),
    );
  }

  @protected
  ScdHeader dco_decode_scd_header(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ScdHeader(
      version: dco_decode_u_32(arr[0]),
      bigEndian: dco_decode_bool(arr[1]),
      tablesOffset: dco_decode_u_16(arr[2]),
      fileSize: dco_decode_u_64(arr[3]),
    );
  }

  @protected
  ScdMetadata dco_decode_scd_metadata(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ScdMetadata(
      name: dco_decode_String(arr[0]),
      header: dco_decode_scd_header(arr[1]),
      streams: dco_decode_list_scd_stream_info(arr[2]),
      durationSeconds: dco_decode_f_32(arr[3]),
    );
  }

  @protected
  ScdStreamInfo dco_decode_scd_stream_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return ScdStreamInfo(
      index: dco_decode_u_32(arr[0]),
      dataSize: dco_decode_u_32(arr[1]),
      channels: dco_decode_u_32(arr[2]),
      sampleRate: dco_decode_u_32(arr[3]),
      codec: dco_decode_scd_codec(arr[4]),
      loopStart: dco_decode_u_32(arr[5]),
      loopEnd: dco_decode_u_32(arr[6]),
      extraDataSize: dco_decode_u_32(arr[7]),
      auxChunkCount: dco_decode_u_32(arr[8]),
      dataOffset: dco_decode_u_32(arr[9]),
    );
  }

  @protected
  ScheduleHeader dco_decode_schedule_header(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ScheduleHeader(
      magic: dco_decode_String(arr[0]),
      version: dco_decode_u_32(arr[1]),
      headerSize: dco_decode_u_32(arr[2]),
      dataSize: dco_decode_u_32(arr[3]),
    );
  }

  @protected
  SectionCounts dco_decode_section_counts(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return SectionCounts(
      crst: dco_decode_u_32(arr[0]),
      cres: dco_decode_u_32(arr[1]),
      catt: dco_decode_u_32(arr[2]),
      ccpt: dco_decode_u_32(arr[3]),
      cact: dco_decode_u_32(arr[4]),
      cdpt: dco_decode_u_32(arr[5]),
      ctrk: dco_decode_u_32(arr[6]),
      cbkt: dco_decode_u_32(arr[7]),
      cblk: dco_decode_u_32(arr[8]),
    );
  }

  @protected
  SoundBlock dco_decode_sound_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return SoundBlock(
      name: dco_decode_String(arr[0]),
      durationSamples: dco_decode_u_32(arr[1]),
      durationSeconds: dco_decode_f_32(arr[2]),
    );
  }

  @protected
  SoundReference dco_decode_sound_reference(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return SoundReference(
      blockName: dco_decode_String(arr[0]),
      soundId: dco_decode_String(arr[1]),
      soundType: dco_decode_sound_type(arr[2]),
    );
  }

  @protected
  SoundType dco_decode_sound_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SoundType.values[raw as int];
  }

  @protected
  TargetType dco_decode_target_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TargetType.values[raw as int];
  }

  @protected
  TrackType dco_decode_track_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return TrackType_MotionSet();
      case 1:
        return TrackType_CharacterSet();
      case 2:
        return TrackType_Camera();
      case 3:
        return TrackType_Sound();
      case 4:
        return TrackType_MusicBus();
      case 5:
        return TrackType_Dialogue();
      case 6:
        return TrackType_Effect();
      case 7:
        return TrackType_EventDef();
      case 8:
        return TrackType_ActorControl();
      case 9:
        return TrackType_Unknown(
          dco_decode_u_16(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  U32Array4 dco_decode_u_32_array_4(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U32Array4(dco_decode_list_prim_u_32_strict(raw));
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  Vec3 dco_decode_vec_3(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Vec3(
      x: dco_decode_f_32(arr[0]),
      y: dco_decode_f_32(arr[1]),
      z: dco_decode_f_32(arr[2]),
    );
  }

  @protected
  VfxAnimation dco_decode_vfx_animation(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return VfxAnimation(
      name: dco_decode_String(arr[0]),
      dataSize: dco_decode_u_32(arr[1]),
      durationFrames: dco_decode_opt_box_autoadd_u_32(arr[2]),
      keyframeCount: dco_decode_opt_box_autoadd_u_32(arr[3]),
    );
  }

  @protected
  VfxData dco_decode_vfx_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return VfxData(
      sourcePath: dco_decode_String(arr[0]),
      textures: dco_decode_list_vfx_texture(arr[1]),
      models: dco_decode_list_vfx_model(arr[2]),
      animations: dco_decode_list_vfx_animation(arr[3]),
      effects: dco_decode_list_vfx_effect(arr[4]),
    );
  }

  @protected
  VfxEffect dco_decode_vfx_effect(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return VfxEffect(
      name: dco_decode_String(arr[0]),
      dataSize: dco_decode_u_32(arr[1]),
      controllerPaths: dco_decode_list_String(arr[2]),
      modelRefs: dco_decode_list_String(arr[3]),
      textureRefs: dco_decode_list_String(arr[4]),
    );
  }

  @protected
  VfxMaterial dco_decode_vfx_material(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return VfxMaterial(
      ambientColor: dco_decode_f_32_array_4(arr[0]),
      diffuseColor: dco_decode_f_32_array_4(arr[1]),
      specularColor: dco_decode_f_32_array_4(arr[2]),
      shininess: dco_decode_f_32(arr[3]),
      fogParam: dco_decode_f_32_array_4(arr[4]),
      fogColor: dco_decode_f_32_array_4(arr[5]),
      alphaThreshold: dco_decode_f_32(arr[6]),
      blendEnabled: dco_decode_bool(arr[7]),
      alphaTestEnabled: dco_decode_bool(arr[8]),
      backFaceCulling: dco_decode_bool(arr[9]),
      depthMaskEnabled: dco_decode_bool(arr[10]),
      lightingEnabled: dco_decode_bool(arr[11]),
    );
  }

  @protected
  VfxMesh dco_decode_vfx_mesh(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return VfxMesh(
      vertices: dco_decode_list_vfx_vertex(arr[0]),
      indices: dco_decode_list_prim_u_16_strict(arr[1]),
      primitiveType: dco_decode_vfx_primitive_type(arr[2]),
    );
  }

  @protected
  VfxModel dco_decode_vfx_model(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return VfxModel(
      name: dco_decode_String(arr[0]),
      dataSize: dco_decode_u_32(arr[1]),
      vertexCount: dco_decode_opt_box_autoadd_u_32(arr[2]),
      indexCount: dco_decode_opt_box_autoadd_u_32(arr[3]),
      material: dco_decode_vfx_material(arr[4]),
      textureRefs: dco_decode_list_String(arr[5]),
      hasShader: dco_decode_bool(arr[6]),
      techniqueName: dco_decode_opt_String(arr[7]),
      mesh: dco_decode_opt_box_autoadd_vfx_mesh(arr[8]),
    );
  }

  @protected
  VfxPrimitiveType dco_decode_vfx_primitive_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VfxPrimitiveType.values[raw as int];
  }

  @protected
  VfxSummary dco_decode_vfx_summary(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return VfxSummary(
      sourcePath: dco_decode_String(arr[0]),
      textureCount: dco_decode_usize(arr[1]),
      modelCount: dco_decode_usize(arr[2]),
      animationCount: dco_decode_usize(arr[3]),
      effectCount: dco_decode_usize(arr[4]),
      totalSize: dco_decode_u_64(arr[5]),
      effectNames: dco_decode_list_String(arr[6]),
    );
  }

  @protected
  VfxTexture dco_decode_vfx_texture(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return VfxTexture(
      name: dco_decode_String(arr[0]),
      width: dco_decode_u_16(arr[1]),
      height: dco_decode_u_16(arr[2]),
      format: dco_decode_u_8(arr[3]),
      formatName: dco_decode_String(arr[4]),
      mipCount: dco_decode_u_8(arr[5]),
      imageType: dco_decode_u_8(arr[6]),
      depth: dco_decode_u_16(arr[7]),
      imgbOffset: dco_decode_u_32(arr[8]),
      imgbSize: dco_decode_u_32(arr[9]),
    );
  }

  @protected
  VfxVertex dco_decode_vfx_vertex(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return VfxVertex(
      position: dco_decode_f_32_array_3(arr[0]),
      uv: dco_decode_f_32_array_2(arr[1]),
    );
  }

  @protected
  WbtFileEntry dco_decode_wbt_file_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return WbtFileEntry(
      index: dco_decode_usize(arr[0]),
      offset: dco_decode_u_64(arr[1]),
      uncompressedSize: dco_decode_u_32(arr[2]),
      compressedSize: dco_decode_u_32(arr[3]),
      path: dco_decode_String(arr[4]),
    );
  }

  @protected
  WdbData dco_decode_wdb_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return WdbData(
      header: dco_decode_Map_String_wdb_value_None(arr[0]),
      records: dco_decode_list_Map_String_wdb_value_None(arr[1]),
    );
  }

  @protected
  WdbValue dco_decode_wdb_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return WdbValue_Int(
          dco_decode_i_32(raw[1]),
        );
      case 1:
        return WdbValue_UInt(
          dco_decode_u_32(raw[1]),
        );
      case 2:
        return WdbValue_Float(
          dco_decode_f_32(raw[1]),
        );
      case 3:
        return WdbValue_String(
          dco_decode_String(raw[1]),
        );
      case 4:
        return WdbValue_Bool(
          dco_decode_bool(raw[1]),
        );
      case 5:
        return WdbValue_IntArray(
          dco_decode_list_prim_i_32_strict(raw[1]),
        );
      case 6:
        return WdbValue_UIntArray(
          dco_decode_list_prim_u_32_strict(raw[1]),
        );
      case 7:
        return WdbValue_StringArray(
          dco_decode_list_String(raw[1]),
        );
      case 8:
        return WdbValue_CrystalRole(
          dco_decode_crystal_role(raw[1]),
        );
      case 9:
        return WdbValue_CrystalNodeType(
          dco_decode_crystal_node_type(raw[1]),
        );
      case 10:
        return WdbValue_Unknown();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  WpdData dco_decode_wpd_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return WpdData(
      records: dco_decode_list_wpd_record(arr[0]),
    );
  }

  @protected
  WpdRecord dco_decode_wpd_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return WpdRecord(
      name: dco_decode_String(arr[0]),
      extension_: dco_decode_String(arr[1]),
      data: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  WpdRecordInfo dco_decode_wpd_record_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return WpdRecordInfo(
      name: dco_decode_String(arr[0]),
      extension_: dco_decode_String(arr[1]),
      offset: dco_decode_u_32(arr[2]),
      size: dco_decode_u_32(arr[3]),
    );
  }

  @protected
  ZtrData dco_decode_ztr_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ZtrData(
      entries: dco_decode_list_ztr_entry(arr[0]),
      mappings: dco_decode_list_ztr_map_entry(arr[1]),
    );
  }

  @protected
  ZtrDirectoryResult dco_decode_ztr_directory_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ZtrDirectoryResult(
      entries: dco_decode_list_ztr_entry_with_source(arr[0]),
      parsedFiles: dco_decode_list_String(arr[1]),
      failedFiles: dco_decode_list_ztr_file_error(arr[2]),
      totalFiles: dco_decode_usize(arr[3]),
    );
  }

  @protected
  ZtrEntry dco_decode_ztr_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ZtrEntry(
      id: dco_decode_String(arr[0]),
      text: dco_decode_String(arr[1]),
    );
  }

  @protected
  ZtrEntryWithSource dco_decode_ztr_entry_with_source(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ZtrEntryWithSource(
      id: dco_decode_String(arr[0]),
      text: dco_decode_String(arr[1]),
      sourceFile: dco_decode_String(arr[2]),
    );
  }

  @protected
  ZtrFileError dco_decode_ztr_file_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ZtrFileError(
      filePath: dco_decode_String(arr[0]),
      error: dco_decode_String(arr[1]),
    );
  }

  @protected
  ZtrMapEntry dco_decode_ztr_map_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ZtrMapEntry(
      key: dco_decode_String(arr[0]),
      value: dco_decode_String(arr[1]),
    );
  }

  @protected
  ZtrParseProgress dco_decode_ztr_parse_progress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ZtrParseProgress(
      totalFiles: dco_decode_usize(arr[0]),
      processedFiles: dco_decode_usize(arr[1]),
      successCount: dco_decode_usize(arr[2]),
      errorCount: dco_decode_usize(arr[3]),
      currentFile: dco_decode_String(arr[4]),
      stage: dco_decode_String(arr[5]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  Map<String, McpPattern> sse_decode_Map_String_mcp_pattern_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_mcp_pattern(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<String, WdbValue> sse_decode_Map_String_wdb_value_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_wdb_value(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  RustStreamSink<String> sse_decode_StreamSink_String_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<ZtrParseProgress> sse_decode_StreamSink_ztr_parse_progress_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  Action sse_decode_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Action.values[inner];
  }

  @protected
  ActorType sse_decode_actor_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return ActorType_Camera();
      case 1:
        return ActorType_Sound();
      case 2:
        return ActorType_Effect();
      case 3:
        return ActorType_Bgm();
      case 4:
        return ActorType_Proxy();
      case 5:
        return ActorType_System();
      case 6:
        var var_field0 = sse_decode_String(deserializer);
        return ActorType_Character(var_field0);
      case 7:
        var var_field0 = sse_decode_String(deserializer);
        return ActorType_Unknown(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  BlockTrack sse_decode_block_track(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_size = sse_decode_u_16(deserializer);
    var var_trackType = sse_decode_track_type(deserializer);
    var var_typeCode = sse_decode_u_16(deserializer);
    var var_flags = sse_decode_u_32(deserializer);
    var var_index = sse_decode_u_32(deserializer);
    var var_reference = sse_decode_opt_String(deserializer);
    var var_startFrame = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_durationFrames = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_floatValues = sse_decode_list_prim_f_32_strict(deserializer);
    return BlockTrack(
        size: var_size,
        trackType: var_trackType,
        typeCode: var_typeCode,
        flags: var_flags,
        index: var_index,
        reference: var_reference,
        startFrame: var_startFrame,
        durationFrames: var_durationFrames,
        floatValues: var_floatValues);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  CgtFile sse_decode_box_autoadd_cgt_file(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_cgt_file(deserializer));
  }

  @protected
  EventDataSet sse_decode_box_autoadd_event_data_set(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_event_data_set(deserializer));
  }

  @protected
  McpFile sse_decode_box_autoadd_mcp_file(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_mcp_file(deserializer));
  }

  @protected
  ScheduleHeader sse_decode_box_autoadd_schedule_header(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_schedule_header(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  VfxMesh sse_decode_box_autoadd_vfx_mesh(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_vfx_mesh(deserializer));
  }

  @protected
  WdbData sse_decode_box_autoadd_wdb_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_wdb_data(deserializer));
  }

  @protected
  ZtrData sse_decode_box_autoadd_ztr_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ztr_data(deserializer));
  }

  @protected
  CameraControlBlock sse_decode_camera_control_block(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_sourceFile = sse_decode_String(deserializer);
    var var_headerSize = sse_decode_u_32(deserializer);
    var var_dataSize = sse_decode_u_32(deserializer);
    var var_flags = sse_decode_u_32(deserializer);
    return CameraControlBlock(
        name: var_name,
        sourceFile: var_sourceFile,
        headerSize: var_headerSize,
        dataSize: var_dataSize,
        flags: var_flags);
  }

  @protected
  CgtFile sse_decode_cgt_file(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_version = sse_decode_u_32(deserializer);
    var var_entryCount = sse_decode_u_32(deserializer);
    var var_totalNodes = sse_decode_u_32(deserializer);
    var var_reserved = sse_decode_u_32(deserializer);
    var var_entries = sse_decode_list_crystarium_entry(deserializer);
    var var_nodes = sse_decode_list_crystarium_node(deserializer);
    return CgtFile(
        version: var_version,
        entryCount: var_entryCount,
        totalNodes: var_totalNodes,
        reserved: var_reserved,
        entries: var_entries,
        nodes: var_nodes);
  }

  @protected
  CrystalNodeType sse_decode_crystal_node_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return CrystalNodeType.values[inner];
  }

  @protected
  CrystalRole sse_decode_crystal_role(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return CrystalRole.values[inner];
  }

  @protected
  CrystariumEntry sse_decode_crystarium_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_u_32(deserializer);
    var var_patternName = sse_decode_String(deserializer);
    var var_position = sse_decode_vec_3(deserializer);
    var var_scale = sse_decode_f_32(deserializer);
    var var_rotation = sse_decode_vec_3(deserializer);
    var var_rotationW = sse_decode_f_32(deserializer);
    var var_nodeScale = sse_decode_f_32(deserializer);
    var var_roleId = sse_decode_u_8(deserializer);
    var var_stage = sse_decode_u_8(deserializer);
    var var_entryType = sse_decode_u_8(deserializer);
    var var_reserved = sse_decode_u_8(deserializer);
    var var_nodeIds = sse_decode_list_prim_u_32_strict(deserializer);
    var var_linkPosition = sse_decode_vec_3(deserializer);
    var var_linkW = sse_decode_f_32(deserializer);
    return CrystariumEntry(
        index: var_index,
        patternName: var_patternName,
        position: var_position,
        scale: var_scale,
        rotation: var_rotation,
        rotationW: var_rotationW,
        nodeScale: var_nodeScale,
        roleId: var_roleId,
        stage: var_stage,
        entryType: var_entryType,
        reserved: var_reserved,
        nodeIds: var_nodeIds,
        linkPosition: var_linkPosition,
        linkW: var_linkW);
  }

  @protected
  CrystariumNode sse_decode_crystarium_node(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_u_32(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_parentIndex = sse_decode_i_32(deserializer);
    var var_unknown = sse_decode_u_32_array_4(deserializer);
    var var_scales = sse_decode_f_32_array_4(deserializer);
    return CrystariumNode(
        index: var_index,
        name: var_name,
        parentIndex: var_parentIndex,
        unknown: var_unknown,
        scales: var_scales);
  }

  @protected
  DecodedAudio sse_decode_decoded_audio(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sampleRate = sse_decode_u_32(deserializer);
    var var_channels = sse_decode_u_16(deserializer);
    var var_bitsPerSample = sse_decode_u_16(deserializer);
    var var_pcmData = sse_decode_list_prim_u_8_strict(deserializer);
    var var_durationSeconds = sse_decode_f_32(deserializer);
    var var_originalCodec = sse_decode_String(deserializer);
    return DecodedAudio(
        sampleRate: var_sampleRate,
        channels: var_channels,
        bitsPerSample: var_bitsPerSample,
        pcmData: var_pcmData,
        durationSeconds: var_durationSeconds,
        originalCodec: var_originalCodec);
  }

  @protected
  DialogueEntry sse_decode_dialogue_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_recordName = sse_decode_String(deserializer);
    var var_rawContent = sse_decode_String(deserializer);
    var var_ztrKey = sse_decode_String(deserializer);
    return DialogueEntry(
        recordName: var_recordName,
        rawContent: var_rawContent,
        ztrKey: var_ztrKey);
  }

  @protected
  EventActor sse_decode_event_actor(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_actorType = sse_decode_actor_type(deserializer);
    var var_index = sse_decode_u_16(deserializer);
    var var_flags = sse_decode_u_32(deserializer);
    return EventActor(
        name: var_name,
        actorType: var_actorType,
        index: var_index,
        flags: var_flags);
  }

  @protected
  EventBlock sse_decode_event_block(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_id = sse_decode_u_16(deserializer);
    var var_durationFrames = sse_decode_u_32(deserializer);
    var var_durationSeconds = sse_decode_f_32(deserializer);
    var var_trackCount = sse_decode_u_32(deserializer);
    var var_tracks = sse_decode_list_block_track(deserializer);
    return EventBlock(
        name: var_name,
        id: var_id,
        durationFrames: var_durationFrames,
        durationSeconds: var_durationSeconds,
        trackCount: var_trackCount,
        tracks: var_tracks);
  }

  @protected
  EventDataSet sse_decode_event_data_set(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_motionBlocks = sse_decode_list_motion_control_block(deserializer);
    var var_cameraBlocks = sse_decode_list_camera_control_block(deserializer);
    var var_sourceFiles = sse_decode_list_String(deserializer);
    return EventDataSet(
        motionBlocks: var_motionBlocks,
        cameraBlocks: var_cameraBlocks,
        sourceFiles: var_sourceFiles);
  }

  @protected
  EventMetadata sse_decode_event_metadata(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_sourcePath = sse_decode_String(deserializer);
    var var_fileSize = sse_decode_u_64(deserializer);
    var var_recordCount = sse_decode_usize(deserializer);
    var var_wpdRecords = sse_decode_list_wpd_record_info(deserializer);
    var var_scheduleHeader =
        sse_decode_opt_box_autoadd_schedule_header(deserializer);
    var var_sectionCounts = sse_decode_section_counts(deserializer);
    var var_externalResources = sse_decode_list_external_resource(deserializer);
    var var_actors = sse_decode_list_event_actor(deserializer);
    var var_blocks = sse_decode_list_event_block(deserializer);
    var var_resources = sse_decode_list_event_resource(deserializer);
    var var_soundBlocks = sse_decode_list_sound_block(deserializer);
    var var_soundReferences = sse_decode_list_sound_reference(deserializer);
    var var_dialogueEntries = sse_decode_list_dialogue_entry(deserializer);
    var var_dataset = sse_decode_opt_box_autoadd_event_data_set(deserializer);
    return EventMetadata(
        name: var_name,
        sourcePath: var_sourcePath,
        fileSize: var_fileSize,
        recordCount: var_recordCount,
        wpdRecords: var_wpdRecords,
        scheduleHeader: var_scheduleHeader,
        sectionCounts: var_sectionCounts,
        externalResources: var_externalResources,
        actors: var_actors,
        blocks: var_blocks,
        resources: var_resources,
        soundBlocks: var_soundBlocks,
        soundReferences: var_soundReferences,
        dialogueEntries: var_dialogueEntries,
        dataset: var_dataset);
  }

  @protected
  EventResource sse_decode_event_resource(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_resourceType = sse_decode_String(deserializer);
    var var_externalHash = sse_decode_opt_String(deserializer);
    return EventResource(
        name: var_name,
        resourceType: var_resourceType,
        externalHash: var_externalHash);
  }

  @protected
  EventSummary sse_decode_event_summary(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_actorCount = sse_decode_usize(deserializer);
    var var_blockCount = sse_decode_usize(deserializer);
    var var_resourceCount = sse_decode_usize(deserializer);
    var var_dialogueCount = sse_decode_usize(deserializer);
    var var_soundBlockCount = sse_decode_usize(deserializer);
    var var_totalDurationSeconds = sse_decode_f_32(deserializer);
    var var_hasDataset = sse_decode_bool(deserializer);
    var var_motionBlockCount = sse_decode_usize(deserializer);
    var var_cameraBlockCount = sse_decode_usize(deserializer);
    return EventSummary(
        name: var_name,
        actorCount: var_actorCount,
        blockCount: var_blockCount,
        resourceCount: var_resourceCount,
        dialogueCount: var_dialogueCount,
        soundBlockCount: var_soundBlockCount,
        totalDurationSeconds: var_totalDurationSeconds,
        hasDataset: var_hasDataset,
        motionBlockCount: var_motionBlockCount,
        cameraBlockCount: var_cameraBlockCount);
  }

  @protected
  ExternalResource sse_decode_external_resource(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_hash = sse_decode_String(deserializer);
    var var_category = sse_decode_resource_category(deserializer);
    return ExternalResource(
        name: var_name, hash: var_hash, category: var_category);
  }

  @protected
  ExtractedEvent sse_decode_extracted_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_outputDir = sse_decode_String(deserializer);
    var var_metadata = sse_decode_event_metadata(deserializer);
    var var_extractedFiles = sse_decode_list_String(deserializer);
    return ExtractedEvent(
        outputDir: var_outputDir,
        metadata: var_metadata,
        extractedFiles: var_extractedFiles);
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  F32Array2 sse_decode_f_32_array_2(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_f_32_strict(deserializer);
    return F32Array2(inner);
  }

  @protected
  F32Array3 sse_decode_f_32_array_3(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_f_32_strict(deserializer);
    return F32Array3(inner);
  }

  @protected
  F32Array4 sse_decode_f_32_array_4(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_f_32_strict(deserializer);
    return F32Array4(inner);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  ImgData sse_decode_img_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_width = sse_decode_u_16(deserializer);
    var var_height = sse_decode_u_16(deserializer);
    var var_mipCount = sse_decode_u_8(deserializer);
    var var_format = sse_decode_String(deserializer);
    return ImgData(
        width: var_width,
        height: var_height,
        mipCount: var_mipCount,
        format: var_format);
  }

  @protected
  List<Map<String, WdbValue>> sse_decode_list_Map_String_wdb_value_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Map<String, WdbValue>>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_Map_String_wdb_value_None(deserializer));
    }
    return ans_;
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<BlockTrack> sse_decode_list_block_track(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <BlockTrack>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_block_track(deserializer));
    }
    return ans_;
  }

  @protected
  List<CameraControlBlock> sse_decode_list_camera_control_block(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <CameraControlBlock>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_camera_control_block(deserializer));
    }
    return ans_;
  }

  @protected
  List<CrystariumEntry> sse_decode_list_crystarium_entry(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <CrystariumEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_crystarium_entry(deserializer));
    }
    return ans_;
  }

  @protected
  List<CrystariumNode> sse_decode_list_crystarium_node(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <CrystariumNode>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_crystarium_node(deserializer));
    }
    return ans_;
  }

  @protected
  List<DecodedAudio> sse_decode_list_decoded_audio(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DecodedAudio>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_decoded_audio(deserializer));
    }
    return ans_;
  }

  @protected
  List<DialogueEntry> sse_decode_list_dialogue_entry(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DialogueEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_dialogue_entry(deserializer));
    }
    return ans_;
  }

  @protected
  List<EventActor> sse_decode_list_event_actor(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <EventActor>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_event_actor(deserializer));
    }
    return ans_;
  }

  @protected
  List<EventBlock> sse_decode_list_event_block(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <EventBlock>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_event_block(deserializer));
    }
    return ans_;
  }

  @protected
  List<EventResource> sse_decode_list_event_resource(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <EventResource>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_event_resource(deserializer));
    }
    return ans_;
  }

  @protected
  List<ExternalResource> sse_decode_list_external_resource(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ExternalResource>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_external_resource(deserializer));
    }
    return ans_;
  }

  @protected
  List<MotionControlBlock> sse_decode_list_motion_control_block(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MotionControlBlock>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_motion_control_block(deserializer));
    }
    return ans_;
  }

  @protected
  Float32List sse_decode_list_prim_f_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat32List(len_);
  }

  @protected
  Int32List sse_decode_list_prim_i_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getInt32List(len_);
  }

  @protected
  Uint16List sse_decode_list_prim_u_16_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint16List(len_);
  }

  @protected
  Uint32List sse_decode_list_prim_u_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint32List(len_);
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint64List sse_decode_list_prim_usize_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint64List(len_);
  }

  @protected
  List<(String, McpPattern)> sse_decode_list_record_string_mcp_pattern(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, McpPattern)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_mcp_pattern(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, WdbValue)> sse_decode_list_record_string_wdb_value(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, WdbValue)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_wdb_value(deserializer));
    }
    return ans_;
  }

  @protected
  List<ScdStreamInfo> sse_decode_list_scd_stream_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ScdStreamInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_scd_stream_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<SoundBlock> sse_decode_list_sound_block(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SoundBlock>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_sound_block(deserializer));
    }
    return ans_;
  }

  @protected
  List<SoundReference> sse_decode_list_sound_reference(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SoundReference>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_sound_reference(deserializer));
    }
    return ans_;
  }

  @protected
  List<Vec3> sse_decode_list_vec_3(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Vec3>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_vec_3(deserializer));
    }
    return ans_;
  }

  @protected
  List<VfxAnimation> sse_decode_list_vfx_animation(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <VfxAnimation>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_vfx_animation(deserializer));
    }
    return ans_;
  }

  @protected
  List<VfxEffect> sse_decode_list_vfx_effect(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <VfxEffect>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_vfx_effect(deserializer));
    }
    return ans_;
  }

  @protected
  List<VfxModel> sse_decode_list_vfx_model(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <VfxModel>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_vfx_model(deserializer));
    }
    return ans_;
  }

  @protected
  List<VfxTexture> sse_decode_list_vfx_texture(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <VfxTexture>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_vfx_texture(deserializer));
    }
    return ans_;
  }

  @protected
  List<VfxVertex> sse_decode_list_vfx_vertex(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <VfxVertex>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_vfx_vertex(deserializer));
    }
    return ans_;
  }

  @protected
  List<WbtFileEntry> sse_decode_list_wbt_file_entry(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WbtFileEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wbt_file_entry(deserializer));
    }
    return ans_;
  }

  @protected
  List<WpdRecord> sse_decode_list_wpd_record(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WpdRecord>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wpd_record(deserializer));
    }
    return ans_;
  }

  @protected
  List<WpdRecordInfo> sse_decode_list_wpd_record_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WpdRecordInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wpd_record_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<ZtrEntry> sse_decode_list_ztr_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ZtrEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ztr_entry(deserializer));
    }
    return ans_;
  }

  @protected
  List<ZtrEntryWithSource> sse_decode_list_ztr_entry_with_source(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ZtrEntryWithSource>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ztr_entry_with_source(deserializer));
    }
    return ans_;
  }

  @protected
  List<ZtrFileError> sse_decode_list_ztr_file_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ZtrFileError>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ztr_file_error(deserializer));
    }
    return ans_;
  }

  @protected
  List<ZtrMapEntry> sse_decode_list_ztr_map_entry(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ZtrMapEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ztr_map_entry(deserializer));
    }
    return ans_;
  }

  @protected
  McpFile sse_decode_mcp_file(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_version = sse_decode_u_32(deserializer);
    var var_patternCount = sse_decode_u_32(deserializer);
    var var_reserved = sse_decode_u_32(deserializer);
    var var_patterns = sse_decode_Map_String_mcp_pattern_None(deserializer);
    return McpFile(
        version: var_version,
        patternCount: var_patternCount,
        reserved: var_reserved,
        patterns: var_patterns);
  }

  @protected
  McpPattern sse_decode_mcp_pattern(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_nodes = sse_decode_list_vec_3(deserializer);
    var var_count = sse_decode_usize(deserializer);
    return McpPattern(name: var_name, nodes: var_nodes, count: var_count);
  }

  @protected
  MotionControlBlock sse_decode_motion_control_block(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_sourceFile = sse_decode_String(deserializer);
    var var_headerSize = sse_decode_u_32(deserializer);
    var var_dataSize = sse_decode_u_32(deserializer);
    var var_version = sse_decode_u_16(deserializer);
    var var_flags = sse_decode_u_16(deserializer);
    return MotionControlBlock(
        name: var_name,
        sourceFile: var_sourceFile,
        headerSize: var_headerSize,
        dataSize: var_dataSize,
        version: var_version,
        flags: var_flags);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  EventDataSet? sse_decode_opt_box_autoadd_event_data_set(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_event_data_set(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ScheduleHeader? sse_decode_opt_box_autoadd_schedule_header(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_schedule_header(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  VfxMesh? sse_decode_opt_box_autoadd_vfx_mesh(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_vfx_mesh(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (ImgData, Uint8List) sse_decode_record_img_data_list_prim_u_8_strict(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_img_data(deserializer);
    var var_field1 = sse_decode_list_prim_u_8_strict(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  ((int, int), Uint8List)
      sse_decode_record_record_u_32_u_32_list_prim_u_8_strict(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_record_u_32_u_32(deserializer);
    var var_field1 = sse_decode_list_prim_u_8_strict(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, McpPattern) sse_decode_record_string_mcp_pattern(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_mcp_pattern(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, String) sse_decode_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, WdbValue) sse_decode_record_string_wdb_value(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_wdb_value(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (int, int) sse_decode_record_u_32_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_32(deserializer);
    var var_field1 = sse_decode_u_32(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  ResourceCategory sse_decode_resource_category(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ResourceCategory.values[inner];
  }

  @protected
  ScdCodec sse_decode_scd_codec(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ScdCodec.values[inner];
  }

  @protected
  ScdExtractResult sse_decode_scd_extract_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_metadata = sse_decode_scd_metadata(deserializer);
    var var_audioStreams = sse_decode_list_decoded_audio(deserializer);
    return ScdExtractResult(
        metadata: var_metadata, audioStreams: var_audioStreams);
  }

  @protected
  ScdHeader sse_decode_scd_header(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_version = sse_decode_u_32(deserializer);
    var var_bigEndian = sse_decode_bool(deserializer);
    var var_tablesOffset = sse_decode_u_16(deserializer);
    var var_fileSize = sse_decode_u_64(deserializer);
    return ScdHeader(
        version: var_version,
        bigEndian: var_bigEndian,
        tablesOffset: var_tablesOffset,
        fileSize: var_fileSize);
  }

  @protected
  ScdMetadata sse_decode_scd_metadata(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_header = sse_decode_scd_header(deserializer);
    var var_streams = sse_decode_list_scd_stream_info(deserializer);
    var var_durationSeconds = sse_decode_f_32(deserializer);
    return ScdMetadata(
        name: var_name,
        header: var_header,
        streams: var_streams,
        durationSeconds: var_durationSeconds);
  }

  @protected
  ScdStreamInfo sse_decode_scd_stream_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_u_32(deserializer);
    var var_dataSize = sse_decode_u_32(deserializer);
    var var_channels = sse_decode_u_32(deserializer);
    var var_sampleRate = sse_decode_u_32(deserializer);
    var var_codec = sse_decode_scd_codec(deserializer);
    var var_loopStart = sse_decode_u_32(deserializer);
    var var_loopEnd = sse_decode_u_32(deserializer);
    var var_extraDataSize = sse_decode_u_32(deserializer);
    var var_auxChunkCount = sse_decode_u_32(deserializer);
    var var_dataOffset = sse_decode_u_32(deserializer);
    return ScdStreamInfo(
        index: var_index,
        dataSize: var_dataSize,
        channels: var_channels,
        sampleRate: var_sampleRate,
        codec: var_codec,
        loopStart: var_loopStart,
        loopEnd: var_loopEnd,
        extraDataSize: var_extraDataSize,
        auxChunkCount: var_auxChunkCount,
        dataOffset: var_dataOffset);
  }

  @protected
  ScheduleHeader sse_decode_schedule_header(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_magic = sse_decode_String(deserializer);
    var var_version = sse_decode_u_32(deserializer);
    var var_headerSize = sse_decode_u_32(deserializer);
    var var_dataSize = sse_decode_u_32(deserializer);
    return ScheduleHeader(
        magic: var_magic,
        version: var_version,
        headerSize: var_headerSize,
        dataSize: var_dataSize);
  }

  @protected
  SectionCounts sse_decode_section_counts(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_crst = sse_decode_u_32(deserializer);
    var var_cres = sse_decode_u_32(deserializer);
    var var_catt = sse_decode_u_32(deserializer);
    var var_ccpt = sse_decode_u_32(deserializer);
    var var_cact = sse_decode_u_32(deserializer);
    var var_cdpt = sse_decode_u_32(deserializer);
    var var_ctrk = sse_decode_u_32(deserializer);
    var var_cbkt = sse_decode_u_32(deserializer);
    var var_cblk = sse_decode_u_32(deserializer);
    return SectionCounts(
        crst: var_crst,
        cres: var_cres,
        catt: var_catt,
        ccpt: var_ccpt,
        cact: var_cact,
        cdpt: var_cdpt,
        ctrk: var_ctrk,
        cbkt: var_cbkt,
        cblk: var_cblk);
  }

  @protected
  SoundBlock sse_decode_sound_block(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_durationSamples = sse_decode_u_32(deserializer);
    var var_durationSeconds = sse_decode_f_32(deserializer);
    return SoundBlock(
        name: var_name,
        durationSamples: var_durationSamples,
        durationSeconds: var_durationSeconds);
  }

  @protected
  SoundReference sse_decode_sound_reference(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_blockName = sse_decode_String(deserializer);
    var var_soundId = sse_decode_String(deserializer);
    var var_soundType = sse_decode_sound_type(deserializer);
    return SoundReference(
        blockName: var_blockName,
        soundId: var_soundId,
        soundType: var_soundType);
  }

  @protected
  SoundType sse_decode_sound_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SoundType.values[inner];
  }

  @protected
  TargetType sse_decode_target_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return TargetType.values[inner];
  }

  @protected
  TrackType sse_decode_track_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return TrackType_MotionSet();
      case 1:
        return TrackType_CharacterSet();
      case 2:
        return TrackType_Camera();
      case 3:
        return TrackType_Sound();
      case 4:
        return TrackType_MusicBus();
      case 5:
        return TrackType_Dialogue();
      case 6:
        return TrackType_Effect();
      case 7:
        return TrackType_EventDef();
      case 8:
        return TrackType_ActorControl();
      case 9:
        var var_field0 = sse_decode_u_16(deserializer);
        return TrackType_Unknown(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  U32Array4 sse_decode_u_32_array_4(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_32_strict(deserializer);
    return U32Array4(inner);
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  Vec3 sse_decode_vec_3(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_x = sse_decode_f_32(deserializer);
    var var_y = sse_decode_f_32(deserializer);
    var var_z = sse_decode_f_32(deserializer);
    return Vec3(x: var_x, y: var_y, z: var_z);
  }

  @protected
  VfxAnimation sse_decode_vfx_animation(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_dataSize = sse_decode_u_32(deserializer);
    var var_durationFrames = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_keyframeCount = sse_decode_opt_box_autoadd_u_32(deserializer);
    return VfxAnimation(
        name: var_name,
        dataSize: var_dataSize,
        durationFrames: var_durationFrames,
        keyframeCount: var_keyframeCount);
  }

  @protected
  VfxData sse_decode_vfx_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sourcePath = sse_decode_String(deserializer);
    var var_textures = sse_decode_list_vfx_texture(deserializer);
    var var_models = sse_decode_list_vfx_model(deserializer);
    var var_animations = sse_decode_list_vfx_animation(deserializer);
    var var_effects = sse_decode_list_vfx_effect(deserializer);
    return VfxData(
        sourcePath: var_sourcePath,
        textures: var_textures,
        models: var_models,
        animations: var_animations,
        effects: var_effects);
  }

  @protected
  VfxEffect sse_decode_vfx_effect(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_dataSize = sse_decode_u_32(deserializer);
    var var_controllerPaths = sse_decode_list_String(deserializer);
    var var_modelRefs = sse_decode_list_String(deserializer);
    var var_textureRefs = sse_decode_list_String(deserializer);
    return VfxEffect(
        name: var_name,
        dataSize: var_dataSize,
        controllerPaths: var_controllerPaths,
        modelRefs: var_modelRefs,
        textureRefs: var_textureRefs);
  }

  @protected
  VfxMaterial sse_decode_vfx_material(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ambientColor = sse_decode_f_32_array_4(deserializer);
    var var_diffuseColor = sse_decode_f_32_array_4(deserializer);
    var var_specularColor = sse_decode_f_32_array_4(deserializer);
    var var_shininess = sse_decode_f_32(deserializer);
    var var_fogParam = sse_decode_f_32_array_4(deserializer);
    var var_fogColor = sse_decode_f_32_array_4(deserializer);
    var var_alphaThreshold = sse_decode_f_32(deserializer);
    var var_blendEnabled = sse_decode_bool(deserializer);
    var var_alphaTestEnabled = sse_decode_bool(deserializer);
    var var_backFaceCulling = sse_decode_bool(deserializer);
    var var_depthMaskEnabled = sse_decode_bool(deserializer);
    var var_lightingEnabled = sse_decode_bool(deserializer);
    return VfxMaterial(
        ambientColor: var_ambientColor,
        diffuseColor: var_diffuseColor,
        specularColor: var_specularColor,
        shininess: var_shininess,
        fogParam: var_fogParam,
        fogColor: var_fogColor,
        alphaThreshold: var_alphaThreshold,
        blendEnabled: var_blendEnabled,
        alphaTestEnabled: var_alphaTestEnabled,
        backFaceCulling: var_backFaceCulling,
        depthMaskEnabled: var_depthMaskEnabled,
        lightingEnabled: var_lightingEnabled);
  }

  @protected
  VfxMesh sse_decode_vfx_mesh(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_vertices = sse_decode_list_vfx_vertex(deserializer);
    var var_indices = sse_decode_list_prim_u_16_strict(deserializer);
    var var_primitiveType = sse_decode_vfx_primitive_type(deserializer);
    return VfxMesh(
        vertices: var_vertices,
        indices: var_indices,
        primitiveType: var_primitiveType);
  }

  @protected
  VfxModel sse_decode_vfx_model(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_dataSize = sse_decode_u_32(deserializer);
    var var_vertexCount = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_indexCount = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_material = sse_decode_vfx_material(deserializer);
    var var_textureRefs = sse_decode_list_String(deserializer);
    var var_hasShader = sse_decode_bool(deserializer);
    var var_techniqueName = sse_decode_opt_String(deserializer);
    var var_mesh = sse_decode_opt_box_autoadd_vfx_mesh(deserializer);
    return VfxModel(
        name: var_name,
        dataSize: var_dataSize,
        vertexCount: var_vertexCount,
        indexCount: var_indexCount,
        material: var_material,
        textureRefs: var_textureRefs,
        hasShader: var_hasShader,
        techniqueName: var_techniqueName,
        mesh: var_mesh);
  }

  @protected
  VfxPrimitiveType sse_decode_vfx_primitive_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return VfxPrimitiveType.values[inner];
  }

  @protected
  VfxSummary sse_decode_vfx_summary(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sourcePath = sse_decode_String(deserializer);
    var var_textureCount = sse_decode_usize(deserializer);
    var var_modelCount = sse_decode_usize(deserializer);
    var var_animationCount = sse_decode_usize(deserializer);
    var var_effectCount = sse_decode_usize(deserializer);
    var var_totalSize = sse_decode_u_64(deserializer);
    var var_effectNames = sse_decode_list_String(deserializer);
    return VfxSummary(
        sourcePath: var_sourcePath,
        textureCount: var_textureCount,
        modelCount: var_modelCount,
        animationCount: var_animationCount,
        effectCount: var_effectCount,
        totalSize: var_totalSize,
        effectNames: var_effectNames);
  }

  @protected
  VfxTexture sse_decode_vfx_texture(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_width = sse_decode_u_16(deserializer);
    var var_height = sse_decode_u_16(deserializer);
    var var_format = sse_decode_u_8(deserializer);
    var var_formatName = sse_decode_String(deserializer);
    var var_mipCount = sse_decode_u_8(deserializer);
    var var_imageType = sse_decode_u_8(deserializer);
    var var_depth = sse_decode_u_16(deserializer);
    var var_imgbOffset = sse_decode_u_32(deserializer);
    var var_imgbSize = sse_decode_u_32(deserializer);
    return VfxTexture(
        name: var_name,
        width: var_width,
        height: var_height,
        format: var_format,
        formatName: var_formatName,
        mipCount: var_mipCount,
        imageType: var_imageType,
        depth: var_depth,
        imgbOffset: var_imgbOffset,
        imgbSize: var_imgbSize);
  }

  @protected
  VfxVertex sse_decode_vfx_vertex(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_position = sse_decode_f_32_array_3(deserializer);
    var var_uv = sse_decode_f_32_array_2(deserializer);
    return VfxVertex(position: var_position, uv: var_uv);
  }

  @protected
  WbtFileEntry sse_decode_wbt_file_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_usize(deserializer);
    var var_offset = sse_decode_u_64(deserializer);
    var var_uncompressedSize = sse_decode_u_32(deserializer);
    var var_compressedSize = sse_decode_u_32(deserializer);
    var var_path = sse_decode_String(deserializer);
    return WbtFileEntry(
        index: var_index,
        offset: var_offset,
        uncompressedSize: var_uncompressedSize,
        compressedSize: var_compressedSize,
        path: var_path);
  }

  @protected
  WdbData sse_decode_wdb_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_header = sse_decode_Map_String_wdb_value_None(deserializer);
    var var_records = sse_decode_list_Map_String_wdb_value_None(deserializer);
    return WdbData(header: var_header, records: var_records);
  }

  @protected
  WdbValue sse_decode_wdb_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_i_32(deserializer);
        return WdbValue_Int(var_field0);
      case 1:
        var var_field0 = sse_decode_u_32(deserializer);
        return WdbValue_UInt(var_field0);
      case 2:
        var var_field0 = sse_decode_f_32(deserializer);
        return WdbValue_Float(var_field0);
      case 3:
        var var_field0 = sse_decode_String(deserializer);
        return WdbValue_String(var_field0);
      case 4:
        var var_field0 = sse_decode_bool(deserializer);
        return WdbValue_Bool(var_field0);
      case 5:
        var var_field0 = sse_decode_list_prim_i_32_strict(deserializer);
        return WdbValue_IntArray(var_field0);
      case 6:
        var var_field0 = sse_decode_list_prim_u_32_strict(deserializer);
        return WdbValue_UIntArray(var_field0);
      case 7:
        var var_field0 = sse_decode_list_String(deserializer);
        return WdbValue_StringArray(var_field0);
      case 8:
        var var_field0 = sse_decode_crystal_role(deserializer);
        return WdbValue_CrystalRole(var_field0);
      case 9:
        var var_field0 = sse_decode_crystal_node_type(deserializer);
        return WdbValue_CrystalNodeType(var_field0);
      case 10:
        return WdbValue_Unknown();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  WpdData sse_decode_wpd_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_records = sse_decode_list_wpd_record(deserializer);
    return WpdData(records: var_records);
  }

  @protected
  WpdRecord sse_decode_wpd_record(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_extension_ = sse_decode_String(deserializer);
    var var_data = sse_decode_list_prim_u_8_strict(deserializer);
    return WpdRecord(
        name: var_name, extension_: var_extension_, data: var_data);
  }

  @protected
  WpdRecordInfo sse_decode_wpd_record_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_extension_ = sse_decode_String(deserializer);
    var var_offset = sse_decode_u_32(deserializer);
    var var_size = sse_decode_u_32(deserializer);
    return WpdRecordInfo(
        name: var_name,
        extension_: var_extension_,
        offset: var_offset,
        size: var_size);
  }

  @protected
  ZtrData sse_decode_ztr_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_entries = sse_decode_list_ztr_entry(deserializer);
    var var_mappings = sse_decode_list_ztr_map_entry(deserializer);
    return ZtrData(entries: var_entries, mappings: var_mappings);
  }

  @protected
  ZtrDirectoryResult sse_decode_ztr_directory_result(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_entries = sse_decode_list_ztr_entry_with_source(deserializer);
    var var_parsedFiles = sse_decode_list_String(deserializer);
    var var_failedFiles = sse_decode_list_ztr_file_error(deserializer);
    var var_totalFiles = sse_decode_usize(deserializer);
    return ZtrDirectoryResult(
        entries: var_entries,
        parsedFiles: var_parsedFiles,
        failedFiles: var_failedFiles,
        totalFiles: var_totalFiles);
  }

  @protected
  ZtrEntry sse_decode_ztr_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_text = sse_decode_String(deserializer);
    return ZtrEntry(id: var_id, text: var_text);
  }

  @protected
  ZtrEntryWithSource sse_decode_ztr_entry_with_source(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_text = sse_decode_String(deserializer);
    var var_sourceFile = sse_decode_String(deserializer);
    return ZtrEntryWithSource(
        id: var_id, text: var_text, sourceFile: var_sourceFile);
  }

  @protected
  ZtrFileError sse_decode_ztr_file_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_filePath = sse_decode_String(deserializer);
    var var_error = sse_decode_String(deserializer);
    return ZtrFileError(filePath: var_filePath, error: var_error);
  }

  @protected
  ZtrMapEntry sse_decode_ztr_map_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_key = sse_decode_String(deserializer);
    var var_value = sse_decode_String(deserializer);
    return ZtrMapEntry(key: var_key, value: var_value);
  }

  @protected
  ZtrParseProgress sse_decode_ztr_parse_progress(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_totalFiles = sse_decode_usize(deserializer);
    var var_processedFiles = sse_decode_usize(deserializer);
    var var_successCount = sse_decode_usize(deserializer);
    var var_errorCount = sse_decode_usize(deserializer);
    var var_currentFile = sse_decode_String(deserializer);
    var var_stage = sse_decode_String(deserializer);
    return ZtrParseProgress(
        totalFiles: var_totalFiles,
        processedFiles: var_processedFiles,
        successCount: var_successCount,
        errorCount: var_errorCount,
        currentFile: var_currentFile,
        stage: var_stage);
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_Map_String_mcp_pattern_None(
      Map<String, McpPattern> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_mcp_pattern(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_Map_String_wdb_value_None(
      Map<String, WdbValue> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_wdb_value(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_StreamSink_String_Sse(
      RustStreamSink<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_ztr_parse_progress_Sse(
      RustStreamSink<ZtrParseProgress> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_ztr_parse_progress,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_action(Action self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_actor_type(ActorType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ActorType_Camera():
        sse_encode_i_32(0, serializer);
      case ActorType_Sound():
        sse_encode_i_32(1, serializer);
      case ActorType_Effect():
        sse_encode_i_32(2, serializer);
      case ActorType_Bgm():
        sse_encode_i_32(3, serializer);
      case ActorType_Proxy():
        sse_encode_i_32(4, serializer);
      case ActorType_System():
        sse_encode_i_32(5, serializer);
      case ActorType_Character(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_String(field0, serializer);
      case ActorType_Unknown(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_block_track(BlockTrack self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self.size, serializer);
    sse_encode_track_type(self.trackType, serializer);
    sse_encode_u_16(self.typeCode, serializer);
    sse_encode_u_32(self.flags, serializer);
    sse_encode_u_32(self.index, serializer);
    sse_encode_opt_String(self.reference, serializer);
    sse_encode_opt_box_autoadd_u_32(self.startFrame, serializer);
    sse_encode_opt_box_autoadd_u_32(self.durationFrames, serializer);
    sse_encode_list_prim_f_32_strict(self.floatValues, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_cgt_file(CgtFile self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_cgt_file(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_event_data_set(
      EventDataSet self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_event_data_set(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_mcp_file(McpFile self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_mcp_file(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_schedule_header(
      ScheduleHeader self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_schedule_header(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_vfx_mesh(VfxMesh self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_vfx_mesh(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_wdb_data(WdbData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_wdb_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ztr_data(ZtrData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ztr_data(self, serializer);
  }

  @protected
  void sse_encode_camera_control_block(
      CameraControlBlock self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.sourceFile, serializer);
    sse_encode_u_32(self.headerSize, serializer);
    sse_encode_u_32(self.dataSize, serializer);
    sse_encode_u_32(self.flags, serializer);
  }

  @protected
  void sse_encode_cgt_file(CgtFile self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.version, serializer);
    sse_encode_u_32(self.entryCount, serializer);
    sse_encode_u_32(self.totalNodes, serializer);
    sse_encode_u_32(self.reserved, serializer);
    sse_encode_list_crystarium_entry(self.entries, serializer);
    sse_encode_list_crystarium_node(self.nodes, serializer);
  }

  @protected
  void sse_encode_crystal_node_type(
      CrystalNodeType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_crystal_role(CrystalRole self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_crystarium_entry(
      CrystariumEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.index, serializer);
    sse_encode_String(self.patternName, serializer);
    sse_encode_vec_3(self.position, serializer);
    sse_encode_f_32(self.scale, serializer);
    sse_encode_vec_3(self.rotation, serializer);
    sse_encode_f_32(self.rotationW, serializer);
    sse_encode_f_32(self.nodeScale, serializer);
    sse_encode_u_8(self.roleId, serializer);
    sse_encode_u_8(self.stage, serializer);
    sse_encode_u_8(self.entryType, serializer);
    sse_encode_u_8(self.reserved, serializer);
    sse_encode_list_prim_u_32_strict(self.nodeIds, serializer);
    sse_encode_vec_3(self.linkPosition, serializer);
    sse_encode_f_32(self.linkW, serializer);
  }

  @protected
  void sse_encode_crystarium_node(
      CrystariumNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.index, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_i_32(self.parentIndex, serializer);
    sse_encode_u_32_array_4(self.unknown, serializer);
    sse_encode_f_32_array_4(self.scales, serializer);
  }

  @protected
  void sse_encode_decoded_audio(DecodedAudio self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.sampleRate, serializer);
    sse_encode_u_16(self.channels, serializer);
    sse_encode_u_16(self.bitsPerSample, serializer);
    sse_encode_list_prim_u_8_strict(self.pcmData, serializer);
    sse_encode_f_32(self.durationSeconds, serializer);
    sse_encode_String(self.originalCodec, serializer);
  }

  @protected
  void sse_encode_dialogue_entry(DialogueEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.recordName, serializer);
    sse_encode_String(self.rawContent, serializer);
    sse_encode_String(self.ztrKey, serializer);
  }

  @protected
  void sse_encode_event_actor(EventActor self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_actor_type(self.actorType, serializer);
    sse_encode_u_16(self.index, serializer);
    sse_encode_u_32(self.flags, serializer);
  }

  @protected
  void sse_encode_event_block(EventBlock self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_u_16(self.id, serializer);
    sse_encode_u_32(self.durationFrames, serializer);
    sse_encode_f_32(self.durationSeconds, serializer);
    sse_encode_u_32(self.trackCount, serializer);
    sse_encode_list_block_track(self.tracks, serializer);
  }

  @protected
  void sse_encode_event_data_set(EventDataSet self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_motion_control_block(self.motionBlocks, serializer);
    sse_encode_list_camera_control_block(self.cameraBlocks, serializer);
    sse_encode_list_String(self.sourceFiles, serializer);
  }

  @protected
  void sse_encode_event_metadata(EventMetadata self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.sourcePath, serializer);
    sse_encode_u_64(self.fileSize, serializer);
    sse_encode_usize(self.recordCount, serializer);
    sse_encode_list_wpd_record_info(self.wpdRecords, serializer);
    sse_encode_opt_box_autoadd_schedule_header(self.scheduleHeader, serializer);
    sse_encode_section_counts(self.sectionCounts, serializer);
    sse_encode_list_external_resource(self.externalResources, serializer);
    sse_encode_list_event_actor(self.actors, serializer);
    sse_encode_list_event_block(self.blocks, serializer);
    sse_encode_list_event_resource(self.resources, serializer);
    sse_encode_list_sound_block(self.soundBlocks, serializer);
    sse_encode_list_sound_reference(self.soundReferences, serializer);
    sse_encode_list_dialogue_entry(self.dialogueEntries, serializer);
    sse_encode_opt_box_autoadd_event_data_set(self.dataset, serializer);
  }

  @protected
  void sse_encode_event_resource(EventResource self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.resourceType, serializer);
    sse_encode_opt_String(self.externalHash, serializer);
  }

  @protected
  void sse_encode_event_summary(EventSummary self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_usize(self.actorCount, serializer);
    sse_encode_usize(self.blockCount, serializer);
    sse_encode_usize(self.resourceCount, serializer);
    sse_encode_usize(self.dialogueCount, serializer);
    sse_encode_usize(self.soundBlockCount, serializer);
    sse_encode_f_32(self.totalDurationSeconds, serializer);
    sse_encode_bool(self.hasDataset, serializer);
    sse_encode_usize(self.motionBlockCount, serializer);
    sse_encode_usize(self.cameraBlockCount, serializer);
  }

  @protected
  void sse_encode_external_resource(
      ExternalResource self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.hash, serializer);
    sse_encode_resource_category(self.category, serializer);
  }

  @protected
  void sse_encode_extracted_event(
      ExtractedEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.outputDir, serializer);
    sse_encode_event_metadata(self.metadata, serializer);
    sse_encode_list_String(self.extractedFiles, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_f_32_array_2(F32Array2 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_f_32_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_f_32_array_3(F32Array3 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_f_32_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_f_32_array_4(F32Array4 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_f_32_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_img_data(ImgData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self.width, serializer);
    sse_encode_u_16(self.height, serializer);
    sse_encode_u_8(self.mipCount, serializer);
    sse_encode_String(self.format, serializer);
  }

  @protected
  void sse_encode_list_Map_String_wdb_value_None(
      List<Map<String, WdbValue>> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Map_String_wdb_value_None(item, serializer);
    }
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_block_track(
      List<BlockTrack> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_block_track(item, serializer);
    }
  }

  @protected
  void sse_encode_list_camera_control_block(
      List<CameraControlBlock> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_camera_control_block(item, serializer);
    }
  }

  @protected
  void sse_encode_list_crystarium_entry(
      List<CrystariumEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_crystarium_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_list_crystarium_node(
      List<CrystariumNode> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_crystarium_node(item, serializer);
    }
  }

  @protected
  void sse_encode_list_decoded_audio(
      List<DecodedAudio> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_decoded_audio(item, serializer);
    }
  }

  @protected
  void sse_encode_list_dialogue_entry(
      List<DialogueEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_dialogue_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_list_event_actor(
      List<EventActor> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_event_actor(item, serializer);
    }
  }

  @protected
  void sse_encode_list_event_block(
      List<EventBlock> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_event_block(item, serializer);
    }
  }

  @protected
  void sse_encode_list_event_resource(
      List<EventResource> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_event_resource(item, serializer);
    }
  }

  @protected
  void sse_encode_list_external_resource(
      List<ExternalResource> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_external_resource(item, serializer);
    }
  }

  @protected
  void sse_encode_list_motion_control_block(
      List<MotionControlBlock> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_motion_control_block(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_f_32_strict(
      Float32List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat32List(self);
  }

  @protected
  void sse_encode_list_prim_i_32_strict(
      Int32List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putInt32List(self);
  }

  @protected
  void sse_encode_list_prim_u_16_strict(
      Uint16List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint16List(self);
  }

  @protected
  void sse_encode_list_prim_u_32_strict(
      Uint32List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint32List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_prim_usize_strict(
      Uint64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint64List(self);
  }

  @protected
  void sse_encode_list_record_string_mcp_pattern(
      List<(String, McpPattern)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_mcp_pattern(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_string(
      List<(String, String)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_wdb_value(
      List<(String, WdbValue)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_wdb_value(item, serializer);
    }
  }

  @protected
  void sse_encode_list_scd_stream_info(
      List<ScdStreamInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_scd_stream_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_sound_block(
      List<SoundBlock> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_sound_block(item, serializer);
    }
  }

  @protected
  void sse_encode_list_sound_reference(
      List<SoundReference> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_sound_reference(item, serializer);
    }
  }

  @protected
  void sse_encode_list_vec_3(List<Vec3> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_vec_3(item, serializer);
    }
  }

  @protected
  void sse_encode_list_vfx_animation(
      List<VfxAnimation> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_vfx_animation(item, serializer);
    }
  }

  @protected
  void sse_encode_list_vfx_effect(
      List<VfxEffect> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_vfx_effect(item, serializer);
    }
  }

  @protected
  void sse_encode_list_vfx_model(
      List<VfxModel> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_vfx_model(item, serializer);
    }
  }

  @protected
  void sse_encode_list_vfx_texture(
      List<VfxTexture> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_vfx_texture(item, serializer);
    }
  }

  @protected
  void sse_encode_list_vfx_vertex(
      List<VfxVertex> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_vfx_vertex(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wbt_file_entry(
      List<WbtFileEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wbt_file_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wpd_record(
      List<WpdRecord> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wpd_record(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wpd_record_info(
      List<WpdRecordInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wpd_record_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ztr_entry(
      List<ZtrEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ztr_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ztr_entry_with_source(
      List<ZtrEntryWithSource> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ztr_entry_with_source(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ztr_file_error(
      List<ZtrFileError> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ztr_file_error(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ztr_map_entry(
      List<ZtrMapEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ztr_map_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_mcp_file(McpFile self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.version, serializer);
    sse_encode_u_32(self.patternCount, serializer);
    sse_encode_u_32(self.reserved, serializer);
    sse_encode_Map_String_mcp_pattern_None(self.patterns, serializer);
  }

  @protected
  void sse_encode_mcp_pattern(McpPattern self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_list_vec_3(self.nodes, serializer);
    sse_encode_usize(self.count, serializer);
  }

  @protected
  void sse_encode_motion_control_block(
      MotionControlBlock self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.sourceFile, serializer);
    sse_encode_u_32(self.headerSize, serializer);
    sse_encode_u_32(self.dataSize, serializer);
    sse_encode_u_16(self.version, serializer);
    sse_encode_u_16(self.flags, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_event_data_set(
      EventDataSet? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_event_data_set(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_schedule_header(
      ScheduleHeader? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_schedule_header(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_vfx_mesh(
      VfxMesh? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_vfx_mesh(self, serializer);
    }
  }

  @protected
  void sse_encode_record_img_data_list_prim_u_8_strict(
      (ImgData, Uint8List) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_img_data(self.$1, serializer);
    sse_encode_list_prim_u_8_strict(self.$2, serializer);
  }

  @protected
  void sse_encode_record_record_u_32_u_32_list_prim_u_8_strict(
      ((int, int), Uint8List) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_record_u_32_u_32(self.$1, serializer);
    sse_encode_list_prim_u_8_strict(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_mcp_pattern(
      (String, McpPattern) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_mcp_pattern(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_string(
      (String, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_wdb_value(
      (String, WdbValue) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_wdb_value(self.$2, serializer);
  }

  @protected
  void sse_encode_record_u_32_u_32((int, int) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.$1, serializer);
    sse_encode_u_32(self.$2, serializer);
  }

  @protected
  void sse_encode_resource_category(
      ResourceCategory self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_scd_codec(ScdCodec self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_scd_extract_result(
      ScdExtractResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_scd_metadata(self.metadata, serializer);
    sse_encode_list_decoded_audio(self.audioStreams, serializer);
  }

  @protected
  void sse_encode_scd_header(ScdHeader self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.version, serializer);
    sse_encode_bool(self.bigEndian, serializer);
    sse_encode_u_16(self.tablesOffset, serializer);
    sse_encode_u_64(self.fileSize, serializer);
  }

  @protected
  void sse_encode_scd_metadata(ScdMetadata self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_scd_header(self.header, serializer);
    sse_encode_list_scd_stream_info(self.streams, serializer);
    sse_encode_f_32(self.durationSeconds, serializer);
  }

  @protected
  void sse_encode_scd_stream_info(
      ScdStreamInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.index, serializer);
    sse_encode_u_32(self.dataSize, serializer);
    sse_encode_u_32(self.channels, serializer);
    sse_encode_u_32(self.sampleRate, serializer);
    sse_encode_scd_codec(self.codec, serializer);
    sse_encode_u_32(self.loopStart, serializer);
    sse_encode_u_32(self.loopEnd, serializer);
    sse_encode_u_32(self.extraDataSize, serializer);
    sse_encode_u_32(self.auxChunkCount, serializer);
    sse_encode_u_32(self.dataOffset, serializer);
  }

  @protected
  void sse_encode_schedule_header(
      ScheduleHeader self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.magic, serializer);
    sse_encode_u_32(self.version, serializer);
    sse_encode_u_32(self.headerSize, serializer);
    sse_encode_u_32(self.dataSize, serializer);
  }

  @protected
  void sse_encode_section_counts(SectionCounts self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.crst, serializer);
    sse_encode_u_32(self.cres, serializer);
    sse_encode_u_32(self.catt, serializer);
    sse_encode_u_32(self.ccpt, serializer);
    sse_encode_u_32(self.cact, serializer);
    sse_encode_u_32(self.cdpt, serializer);
    sse_encode_u_32(self.ctrk, serializer);
    sse_encode_u_32(self.cbkt, serializer);
    sse_encode_u_32(self.cblk, serializer);
  }

  @protected
  void sse_encode_sound_block(SoundBlock self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_u_32(self.durationSamples, serializer);
    sse_encode_f_32(self.durationSeconds, serializer);
  }

  @protected
  void sse_encode_sound_reference(
      SoundReference self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.blockName, serializer);
    sse_encode_String(self.soundId, serializer);
    sse_encode_sound_type(self.soundType, serializer);
  }

  @protected
  void sse_encode_sound_type(SoundType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_target_type(TargetType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_track_type(TrackType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case TrackType_MotionSet():
        sse_encode_i_32(0, serializer);
      case TrackType_CharacterSet():
        sse_encode_i_32(1, serializer);
      case TrackType_Camera():
        sse_encode_i_32(2, serializer);
      case TrackType_Sound():
        sse_encode_i_32(3, serializer);
      case TrackType_MusicBus():
        sse_encode_i_32(4, serializer);
      case TrackType_Dialogue():
        sse_encode_i_32(5, serializer);
      case TrackType_Effect():
        sse_encode_i_32(6, serializer);
      case TrackType_EventDef():
        sse_encode_i_32(7, serializer);
      case TrackType_ActorControl():
        sse_encode_i_32(8, serializer);
      case TrackType_Unknown(field0: final field0):
        sse_encode_i_32(9, serializer);
        sse_encode_u_16(field0, serializer);
    }
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_32_array_4(U32Array4 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_32_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_vec_3(Vec3 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self.x, serializer);
    sse_encode_f_32(self.y, serializer);
    sse_encode_f_32(self.z, serializer);
  }

  @protected
  void sse_encode_vfx_animation(VfxAnimation self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_u_32(self.dataSize, serializer);
    sse_encode_opt_box_autoadd_u_32(self.durationFrames, serializer);
    sse_encode_opt_box_autoadd_u_32(self.keyframeCount, serializer);
  }

  @protected
  void sse_encode_vfx_data(VfxData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.sourcePath, serializer);
    sse_encode_list_vfx_texture(self.textures, serializer);
    sse_encode_list_vfx_model(self.models, serializer);
    sse_encode_list_vfx_animation(self.animations, serializer);
    sse_encode_list_vfx_effect(self.effects, serializer);
  }

  @protected
  void sse_encode_vfx_effect(VfxEffect self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_u_32(self.dataSize, serializer);
    sse_encode_list_String(self.controllerPaths, serializer);
    sse_encode_list_String(self.modelRefs, serializer);
    sse_encode_list_String(self.textureRefs, serializer);
  }

  @protected
  void sse_encode_vfx_material(VfxMaterial self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32_array_4(self.ambientColor, serializer);
    sse_encode_f_32_array_4(self.diffuseColor, serializer);
    sse_encode_f_32_array_4(self.specularColor, serializer);
    sse_encode_f_32(self.shininess, serializer);
    sse_encode_f_32_array_4(self.fogParam, serializer);
    sse_encode_f_32_array_4(self.fogColor, serializer);
    sse_encode_f_32(self.alphaThreshold, serializer);
    sse_encode_bool(self.blendEnabled, serializer);
    sse_encode_bool(self.alphaTestEnabled, serializer);
    sse_encode_bool(self.backFaceCulling, serializer);
    sse_encode_bool(self.depthMaskEnabled, serializer);
    sse_encode_bool(self.lightingEnabled, serializer);
  }

  @protected
  void sse_encode_vfx_mesh(VfxMesh self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_vfx_vertex(self.vertices, serializer);
    sse_encode_list_prim_u_16_strict(self.indices, serializer);
    sse_encode_vfx_primitive_type(self.primitiveType, serializer);
  }

  @protected
  void sse_encode_vfx_model(VfxModel self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_u_32(self.dataSize, serializer);
    sse_encode_opt_box_autoadd_u_32(self.vertexCount, serializer);
    sse_encode_opt_box_autoadd_u_32(self.indexCount, serializer);
    sse_encode_vfx_material(self.material, serializer);
    sse_encode_list_String(self.textureRefs, serializer);
    sse_encode_bool(self.hasShader, serializer);
    sse_encode_opt_String(self.techniqueName, serializer);
    sse_encode_opt_box_autoadd_vfx_mesh(self.mesh, serializer);
  }

  @protected
  void sse_encode_vfx_primitive_type(
      VfxPrimitiveType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_vfx_summary(VfxSummary self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.sourcePath, serializer);
    sse_encode_usize(self.textureCount, serializer);
    sse_encode_usize(self.modelCount, serializer);
    sse_encode_usize(self.animationCount, serializer);
    sse_encode_usize(self.effectCount, serializer);
    sse_encode_u_64(self.totalSize, serializer);
    sse_encode_list_String(self.effectNames, serializer);
  }

  @protected
  void sse_encode_vfx_texture(VfxTexture self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_u_16(self.width, serializer);
    sse_encode_u_16(self.height, serializer);
    sse_encode_u_8(self.format, serializer);
    sse_encode_String(self.formatName, serializer);
    sse_encode_u_8(self.mipCount, serializer);
    sse_encode_u_8(self.imageType, serializer);
    sse_encode_u_16(self.depth, serializer);
    sse_encode_u_32(self.imgbOffset, serializer);
    sse_encode_u_32(self.imgbSize, serializer);
  }

  @protected
  void sse_encode_vfx_vertex(VfxVertex self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32_array_3(self.position, serializer);
    sse_encode_f_32_array_2(self.uv, serializer);
  }

  @protected
  void sse_encode_wbt_file_entry(WbtFileEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.index, serializer);
    sse_encode_u_64(self.offset, serializer);
    sse_encode_u_32(self.uncompressedSize, serializer);
    sse_encode_u_32(self.compressedSize, serializer);
    sse_encode_String(self.path, serializer);
  }

  @protected
  void sse_encode_wdb_data(WdbData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Map_String_wdb_value_None(self.header, serializer);
    sse_encode_list_Map_String_wdb_value_None(self.records, serializer);
  }

  @protected
  void sse_encode_wdb_value(WdbValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case WdbValue_Int(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_i_32(field0, serializer);
      case WdbValue_UInt(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_32(field0, serializer);
      case WdbValue_Float(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_f_32(field0, serializer);
      case WdbValue_String(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_String(field0, serializer);
      case WdbValue_Bool(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_bool(field0, serializer);
      case WdbValue_IntArray(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_list_prim_i_32_strict(field0, serializer);
      case WdbValue_UIntArray(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_list_prim_u_32_strict(field0, serializer);
      case WdbValue_StringArray(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_list_String(field0, serializer);
      case WdbValue_CrystalRole(field0: final field0):
        sse_encode_i_32(8, serializer);
        sse_encode_crystal_role(field0, serializer);
      case WdbValue_CrystalNodeType(field0: final field0):
        sse_encode_i_32(9, serializer);
        sse_encode_crystal_node_type(field0, serializer);
      case WdbValue_Unknown():
        sse_encode_i_32(10, serializer);
    }
  }

  @protected
  void sse_encode_wpd_data(WpdData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_wpd_record(self.records, serializer);
  }

  @protected
  void sse_encode_wpd_record(WpdRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.extension_, serializer);
    sse_encode_list_prim_u_8_strict(self.data, serializer);
  }

  @protected
  void sse_encode_wpd_record_info(
      WpdRecordInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.extension_, serializer);
    sse_encode_u_32(self.offset, serializer);
    sse_encode_u_32(self.size, serializer);
  }

  @protected
  void sse_encode_ztr_data(ZtrData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_ztr_entry(self.entries, serializer);
    sse_encode_list_ztr_map_entry(self.mappings, serializer);
  }

  @protected
  void sse_encode_ztr_directory_result(
      ZtrDirectoryResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_ztr_entry_with_source(self.entries, serializer);
    sse_encode_list_String(self.parsedFiles, serializer);
    sse_encode_list_ztr_file_error(self.failedFiles, serializer);
    sse_encode_usize(self.totalFiles, serializer);
  }

  @protected
  void sse_encode_ztr_entry(ZtrEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.text, serializer);
  }

  @protected
  void sse_encode_ztr_entry_with_source(
      ZtrEntryWithSource self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.text, serializer);
    sse_encode_String(self.sourceFile, serializer);
  }

  @protected
  void sse_encode_ztr_file_error(ZtrFileError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.filePath, serializer);
    sse_encode_String(self.error, serializer);
  }

  @protected
  void sse_encode_ztr_map_entry(ZtrMapEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.key, serializer);
    sse_encode_String(self.value, serializer);
  }

  @protected
  void sse_encode_ztr_parse_progress(
      ZtrParseProgress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.totalFiles, serializer);
    sse_encode_usize(self.processedFiles, serializer);
    sse_encode_usize(self.successCount, serializer);
    sse_encode_usize(self.errorCount, serializer);
    sse_encode_String(self.currentFile, serializer);
    sse_encode_String(self.stage, serializer);
  }
}

// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'modules/img/structs.dart';
import 'modules/wct.dart';
import 'modules/wdb/enums.dart';
import 'modules/wdb/structs.dart';
import 'modules/wpd/structs.dart';
import 'modules/ztr/structs.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => -888955645;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'fabula_nova_sdk',
    ioDirectory: 'target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<void> crateApiClearLogCallback();

  Stream<String> crateApiCreateLogStream();

  Future<List<String>> crateApiFetchLogs();

  Future<List<String>> crateApiGetAllBufferedLogs();

  Future<int> crateApiGetLogLevel();

  Future<void> crateApiImgRepackStrict(
      {required String headerFile,
      required String imgbFile,
      required String inDds});

  Future<ImgData> crateApiImgUnpack(
      {required String headerFile,
      required String imgbFile,
      required String outDds});

  Future<(ImgData, Uint8List)> crateApiImgUnpackToMemory(
      {required String headerFile, required String imgbFile});

  Future<void> crateApiInitApp();

  Future<void> crateApiResetLogReadIndex();

  Future<void> crateApiSetLogLevel({required int level});

  Future<void> crateApiTestLog({required String message});

  Future<void> crateApiWbtExtract(
      {required String filelistPath,
      required String containerPath,
      required String outDir,
      required int gameCode});

  Future<BigInt> crateApiWbtExtractDirectory(
      {required String filelistPath,
      required String containerPath,
      required String dirPrefix,
      required String outputDir,
      required int gameCode});

  Future<void> crateApiWbtExtractFileByIndex(
      {required String filelistPath,
      required String containerPath,
      required BigInt fileIndex,
      required String outputDir,
      required int gameCode});

  Future<BigInt> crateApiWbtExtractFilesByIndices(
      {required String filelistPath,
      required String containerPath,
      required Uint64List indices,
      required String outputDir,
      required int gameCode});

  Future<void> crateApiWbtExtractSingleFile(
      {required String filelistPath,
      required String containerPath,
      required String virtualPath,
      required String outputPath,
      required int gameCode});

  Future<List<WbtFileEntry>> crateApiWbtGetFileList(
      {required String filelistPath, required int gameCode});

  Future<void> crateApiWbtRepack(
      {required String filelistPath,
      required String containerPath,
      required String extractedDir,
      required int gameCode});

  Future<void> crateApiWbtRepackMultiple(
      {required String filelistPath,
      required String containerPath,
      required List<(String, String)> filesToPatch,
      required int gameCode});

  Future<void> crateApiWbtRepackSingle(
      {required String filelistPath,
      required String containerPath,
      required String targetPathInArchive,
      required String fileToInject,
      required int gameCode});

  Future<void> crateApiWctProcess(
      {required TargetType target,
      required Action action,
      required String inputFile});

  Future<WdbData> crateApiWdbFromJson({required String json});

  Future<WdbData> crateApiWdbParse(
      {required String inFile, required int gameCode});

  Future<void> crateApiWdbRepack(
      {required WdbData data, required String outFile});

  Future<String> crateApiWdbToJson({required WdbData data});

  Future<void> crateApiWpdRepack(
      {required String inDir, required String outFile});

  Future<WpdData> crateApiWpdUnpack(
      {required String inFile, required String outDir});

  Future<void> crateApiZtrExtractToText(
      {required String inFile, required String outFile, required int gameCode});

  Future<void> crateApiZtrPackFromData(
      {required List<(String, String)> entries,
      required String outFile,
      required int gameCode});

  Future<void> crateApiZtrPackFromStruct(
      {required ZtrData data, required String outFile, required int gameCode});

  Future<ZtrData> crateApiZtrParse(
      {required String inFile, required int gameCode});

  Stream<ZtrParseProgress> crateApiZtrParseDirectory(
      {required String dirPath, required int gameCode});

  Future<ZtrDirectoryResult> crateApiZtrParseDirectorySimple(
      {required String dirPath, required int gameCode});

  Future<ZtrData> crateApiZtrParseFromMemory(
      {required List<int> data, required int gameCode});

  Future<String> crateApiZtrToTextString({required ZtrData data});
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiClearLogCallback() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiClearLogCallbackConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiClearLogCallbackConstMeta => const TaskConstMeta(
        debugName: "clear_log_callback",
        argNames: [],
      );

  @override
  Stream<String> crateApiCreateLogStream() {
    final sink = RustStreamSink<String>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_StreamSink_String_Sse(sink, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCreateLogStreamConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiCreateLogStreamConstMeta => const TaskConstMeta(
        debugName: "create_log_stream",
        argNames: ["sink"],
      );

  @override
  Future<List<String>> crateApiFetchLogs() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFetchLogsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFetchLogsConstMeta => const TaskConstMeta(
        debugName: "fetch_logs",
        argNames: [],
      );

  @override
  Future<List<String>> crateApiGetAllBufferedLogs() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetAllBufferedLogsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetAllBufferedLogsConstMeta => const TaskConstMeta(
        debugName: "get_all_buffered_logs",
        argNames: [],
      );

  @override
  Future<int> crateApiGetLogLevel() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetLogLevelConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetLogLevelConstMeta => const TaskConstMeta(
        debugName: "get_log_level",
        argNames: [],
      );

  @override
  Future<void> crateApiImgRepackStrict(
      {required String headerFile,
      required String imgbFile,
      required String inDds}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(headerFile, serializer);
        sse_encode_String(imgbFile, serializer);
        sse_encode_String(inDds, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiImgRepackStrictConstMeta,
      argValues: [headerFile, imgbFile, inDds],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiImgRepackStrictConstMeta => const TaskConstMeta(
        debugName: "img_repack_strict",
        argNames: ["headerFile", "imgbFile", "inDds"],
      );

  @override
  Future<ImgData> crateApiImgUnpack(
      {required String headerFile,
      required String imgbFile,
      required String outDds}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(headerFile, serializer);
        sse_encode_String(imgbFile, serializer);
        sse_encode_String(outDds, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_img_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiImgUnpackConstMeta,
      argValues: [headerFile, imgbFile, outDds],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiImgUnpackConstMeta => const TaskConstMeta(
        debugName: "img_unpack",
        argNames: ["headerFile", "imgbFile", "outDds"],
      );

  @override
  Future<(ImgData, Uint8List)> crateApiImgUnpackToMemory(
      {required String headerFile, required String imgbFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(headerFile, serializer);
        sse_encode_String(imgbFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_img_data_list_prim_u_8_strict,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiImgUnpackToMemoryConstMeta,
      argValues: [headerFile, imgbFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiImgUnpackToMemoryConstMeta => const TaskConstMeta(
        debugName: "img_unpack_to_memory",
        argNames: ["headerFile", "imgbFile"],
      );

  @override
  Future<void> crateApiInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Future<void> crateApiResetLogReadIndex() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiResetLogReadIndexConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiResetLogReadIndexConstMeta => const TaskConstMeta(
        debugName: "reset_log_read_index",
        argNames: [],
      );

  @override
  Future<void> crateApiSetLogLevel({required int level}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(level, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSetLogLevelConstMeta,
      argValues: [level],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetLogLevelConstMeta => const TaskConstMeta(
        debugName: "set_log_level",
        argNames: ["level"],
      );

  @override
  Future<void> crateApiTestLog({required String message}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(message, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiTestLogConstMeta,
      argValues: [message],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTestLogConstMeta => const TaskConstMeta(
        debugName: "test_log",
        argNames: ["message"],
      );

  @override
  Future<void> crateApiWbtExtract(
      {required String filelistPath,
      required String containerPath,
      required String outDir,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_String(outDir, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtExtractConstMeta,
      argValues: [filelistPath, containerPath, outDir, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtExtractConstMeta => const TaskConstMeta(
        debugName: "wbt_extract",
        argNames: ["filelistPath", "containerPath", "outDir", "gameCode"],
      );

  @override
  Future<BigInt> crateApiWbtExtractDirectory(
      {required String filelistPath,
      required String containerPath,
      required String dirPrefix,
      required String outputDir,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_String(dirPrefix, serializer);
        sse_encode_String(outputDir, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtExtractDirectoryConstMeta,
      argValues: [filelistPath, containerPath, dirPrefix, outputDir, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtExtractDirectoryConstMeta =>
      const TaskConstMeta(
        debugName: "wbt_extract_directory",
        argNames: [
          "filelistPath",
          "containerPath",
          "dirPrefix",
          "outputDir",
          "gameCode"
        ],
      );

  @override
  Future<void> crateApiWbtExtractFileByIndex(
      {required String filelistPath,
      required String containerPath,
      required BigInt fileIndex,
      required String outputDir,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_usize(fileIndex, serializer);
        sse_encode_String(outputDir, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtExtractFileByIndexConstMeta,
      argValues: [filelistPath, containerPath, fileIndex, outputDir, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtExtractFileByIndexConstMeta =>
      const TaskConstMeta(
        debugName: "wbt_extract_file_by_index",
        argNames: [
          "filelistPath",
          "containerPath",
          "fileIndex",
          "outputDir",
          "gameCode"
        ],
      );

  @override
  Future<BigInt> crateApiWbtExtractFilesByIndices(
      {required String filelistPath,
      required String containerPath,
      required Uint64List indices,
      required String outputDir,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_list_prim_usize_strict(indices, serializer);
        sse_encode_String(outputDir, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtExtractFilesByIndicesConstMeta,
      argValues: [filelistPath, containerPath, indices, outputDir, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtExtractFilesByIndicesConstMeta =>
      const TaskConstMeta(
        debugName: "wbt_extract_files_by_indices",
        argNames: [
          "filelistPath",
          "containerPath",
          "indices",
          "outputDir",
          "gameCode"
        ],
      );

  @override
  Future<void> crateApiWbtExtractSingleFile(
      {required String filelistPath,
      required String containerPath,
      required String virtualPath,
      required String outputPath,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_String(virtualPath, serializer);
        sse_encode_String(outputPath, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtExtractSingleFileConstMeta,
      argValues: [
        filelistPath,
        containerPath,
        virtualPath,
        outputPath,
        gameCode
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtExtractSingleFileConstMeta =>
      const TaskConstMeta(
        debugName: "wbt_extract_single_file",
        argNames: [
          "filelistPath",
          "containerPath",
          "virtualPath",
          "outputPath",
          "gameCode"
        ],
      );

  @override
  Future<List<WbtFileEntry>> crateApiWbtGetFileList(
      {required String filelistPath, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_wbt_file_entry,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtGetFileListConstMeta,
      argValues: [filelistPath, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtGetFileListConstMeta => const TaskConstMeta(
        debugName: "wbt_get_file_list",
        argNames: ["filelistPath", "gameCode"],
      );

  @override
  Future<void> crateApiWbtRepack(
      {required String filelistPath,
      required String containerPath,
      required String extractedDir,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_String(extractedDir, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtRepackConstMeta,
      argValues: [filelistPath, containerPath, extractedDir, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtRepackConstMeta => const TaskConstMeta(
        debugName: "wbt_repack",
        argNames: ["filelistPath", "containerPath", "extractedDir", "gameCode"],
      );

  @override
  Future<void> crateApiWbtRepackMultiple(
      {required String filelistPath,
      required String containerPath,
      required List<(String, String)> filesToPatch,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_list_record_string_string(filesToPatch, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtRepackMultipleConstMeta,
      argValues: [filelistPath, containerPath, filesToPatch, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtRepackMultipleConstMeta => const TaskConstMeta(
        debugName: "wbt_repack_multiple",
        argNames: ["filelistPath", "containerPath", "filesToPatch", "gameCode"],
      );

  @override
  Future<void> crateApiWbtRepackSingle(
      {required String filelistPath,
      required String containerPath,
      required String targetPathInArchive,
      required String fileToInject,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_String(targetPathInArchive, serializer);
        sse_encode_String(fileToInject, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtRepackSingleConstMeta,
      argValues: [
        filelistPath,
        containerPath,
        targetPathInArchive,
        fileToInject,
        gameCode
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtRepackSingleConstMeta => const TaskConstMeta(
        debugName: "wbt_repack_single",
        argNames: [
          "filelistPath",
          "containerPath",
          "targetPathInArchive",
          "fileToInject",
          "gameCode"
        ],
      );

  @override
  Future<void> crateApiWctProcess(
      {required TargetType target,
      required Action action,
      required String inputFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_target_type(target, serializer);
        sse_encode_action(action, serializer);
        sse_encode_String(inputFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWctProcessConstMeta,
      argValues: [target, action, inputFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWctProcessConstMeta => const TaskConstMeta(
        debugName: "wct_process",
        argNames: ["target", "action", "inputFile"],
      );

  @override
  Future<WdbData> crateApiWdbFromJson({required String json}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(json, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wdb_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWdbFromJsonConstMeta,
      argValues: [json],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWdbFromJsonConstMeta => const TaskConstMeta(
        debugName: "wdb_from_json",
        argNames: ["json"],
      );

  @override
  Future<WdbData> crateApiWdbParse(
      {required String inFile, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wdb_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWdbParseConstMeta,
      argValues: [inFile, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWdbParseConstMeta => const TaskConstMeta(
        debugName: "wdb_parse",
        argNames: ["inFile", "gameCode"],
      );

  @override
  Future<void> crateApiWdbRepack(
      {required WdbData data, required String outFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_wdb_data(data, serializer);
        sse_encode_String(outFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWdbRepackConstMeta,
      argValues: [data, outFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWdbRepackConstMeta => const TaskConstMeta(
        debugName: "wdb_repack",
        argNames: ["data", "outFile"],
      );

  @override
  Future<String> crateApiWdbToJson({required WdbData data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_wdb_data(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWdbToJsonConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWdbToJsonConstMeta => const TaskConstMeta(
        debugName: "wdb_to_json",
        argNames: ["data"],
      );

  @override
  Future<void> crateApiWpdRepack(
      {required String inDir, required String outFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inDir, serializer);
        sse_encode_String(outFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWpdRepackConstMeta,
      argValues: [inDir, outFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWpdRepackConstMeta => const TaskConstMeta(
        debugName: "wpd_repack",
        argNames: ["inDir", "outFile"],
      );

  @override
  Future<WpdData> crateApiWpdUnpack(
      {required String inFile, required String outDir}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        sse_encode_String(outDir, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wpd_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWpdUnpackConstMeta,
      argValues: [inFile, outDir],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWpdUnpackConstMeta => const TaskConstMeta(
        debugName: "wpd_unpack",
        argNames: ["inFile", "outDir"],
      );

  @override
  Future<void> crateApiZtrExtractToText(
      {required String inFile,
      required String outFile,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        sse_encode_String(outFile, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiZtrExtractToTextConstMeta,
      argValues: [inFile, outFile, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrExtractToTextConstMeta => const TaskConstMeta(
        debugName: "ztr_extract_to_text",
        argNames: ["inFile", "outFile", "gameCode"],
      );

  @override
  Future<void> crateApiZtrPackFromData(
      {required List<(String, String)> entries,
      required String outFile,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_record_string_string(entries, serializer);
        sse_encode_String(outFile, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiZtrPackFromDataConstMeta,
      argValues: [entries, outFile, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrPackFromDataConstMeta => const TaskConstMeta(
        debugName: "ztr_pack_from_data",
        argNames: ["entries", "outFile", "gameCode"],
      );

  @override
  Future<void> crateApiZtrPackFromStruct(
      {required ZtrData data, required String outFile, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ztr_data(data, serializer);
        sse_encode_String(outFile, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiZtrPackFromStructConstMeta,
      argValues: [data, outFile, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrPackFromStructConstMeta => const TaskConstMeta(
        debugName: "ztr_pack_from_struct",
        argNames: ["data", "outFile", "gameCode"],
      );

  @override
  Future<ZtrData> crateApiZtrParse(
      {required String inFile, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ztr_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiZtrParseConstMeta,
      argValues: [inFile, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrParseConstMeta => const TaskConstMeta(
        debugName: "ztr_parse",
        argNames: ["inFile", "gameCode"],
      );

  @override
  Stream<ZtrParseProgress> crateApiZtrParseDirectory(
      {required String dirPath, required int gameCode}) {
    final progressSink = RustStreamSink<ZtrParseProgress>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dirPath, serializer);
        sse_encode_i_32(gameCode, serializer);
        sse_encode_StreamSink_ztr_parse_progress_Sse(progressSink, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ztr_directory_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiZtrParseDirectoryConstMeta,
      argValues: [dirPath, gameCode, progressSink],
      apiImpl: this,
    )));
    return progressSink.stream;
  }

  TaskConstMeta get kCrateApiZtrParseDirectoryConstMeta => const TaskConstMeta(
        debugName: "ztr_parse_directory",
        argNames: ["dirPath", "gameCode", "progressSink"],
      );

  @override
  Future<ZtrDirectoryResult> crateApiZtrParseDirectorySimple(
      {required String dirPath, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dirPath, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ztr_directory_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiZtrParseDirectorySimpleConstMeta,
      argValues: [dirPath, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrParseDirectorySimpleConstMeta =>
      const TaskConstMeta(
        debugName: "ztr_parse_directory_simple",
        argNames: ["dirPath", "gameCode"],
      );

  @override
  Future<ZtrData> crateApiZtrParseFromMemory(
      {required List<int> data, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(data, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ztr_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiZtrParseFromMemoryConstMeta,
      argValues: [data, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrParseFromMemoryConstMeta => const TaskConstMeta(
        debugName: "ztr_parse_from_memory",
        argNames: ["data", "gameCode"],
      );

  @override
  Future<String> crateApiZtrToTextString({required ZtrData data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ztr_data(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiZtrToTextStringConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrToTextStringConstMeta => const TaskConstMeta(
        debugName: "ztr_to_text_string",
        argNames: ["data"],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  Map<String, WdbValue> dco_decode_Map_String_wdb_value_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_wdb_value(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  RustStreamSink<String> dco_decode_StreamSink_String_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<ZtrParseProgress> dco_decode_StreamSink_ztr_parse_progress_Sse(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  Action dco_decode_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Action.values[raw as int];
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  WdbData dco_decode_box_autoadd_wdb_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_wdb_data(raw);
  }

  @protected
  ZtrData dco_decode_box_autoadd_ztr_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ztr_data(raw);
  }

  @protected
  CrystalNodeType dco_decode_crystal_node_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CrystalNodeType.values[raw as int];
  }

  @protected
  CrystalRole dco_decode_crystal_role(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CrystalRole.values[raw as int];
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  ImgData dco_decode_img_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ImgData(
      width: dco_decode_u_16(arr[0]),
      height: dco_decode_u_16(arr[1]),
      mipCount: dco_decode_u_8(arr[2]),
      format: dco_decode_String(arr[3]),
    );
  }

  @protected
  List<Map<String, WdbValue>> dco_decode_list_Map_String_wdb_value_None(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_Map_String_wdb_value_None)
        .toList();
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  Int32List dco_decode_list_prim_i_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Int32List;
  }

  @protected
  Uint32List dco_decode_list_prim_u_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint32List;
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  Uint64List dco_decode_list_prim_usize_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint64List;
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  List<(String, WdbValue)> dco_decode_list_record_string_wdb_value(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_string_wdb_value)
        .toList();
  }

  @protected
  List<WbtFileEntry> dco_decode_list_wbt_file_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wbt_file_entry).toList();
  }

  @protected
  List<WpdRecord> dco_decode_list_wpd_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wpd_record).toList();
  }

  @protected
  List<ZtrEntry> dco_decode_list_ztr_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ztr_entry).toList();
  }

  @protected
  List<ZtrEntryWithSource> dco_decode_list_ztr_entry_with_source(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_ztr_entry_with_source)
        .toList();
  }

  @protected
  List<ZtrFileError> dco_decode_list_ztr_file_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ztr_file_error).toList();
  }

  @protected
  List<ZtrMapEntry> dco_decode_list_ztr_map_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ztr_map_entry).toList();
  }

  @protected
  (ImgData, Uint8List) dco_decode_record_img_data_list_prim_u_8_strict(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_img_data(arr[0]),
      dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_String(arr[1]),
    );
  }

  @protected
  (String, WdbValue) dco_decode_record_string_wdb_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_wdb_value(arr[1]),
    );
  }

  @protected
  TargetType dco_decode_target_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TargetType.values[raw as int];
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  WbtFileEntry dco_decode_wbt_file_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return WbtFileEntry(
      index: dco_decode_usize(arr[0]),
      offset: dco_decode_u_64(arr[1]),
      uncompressedSize: dco_decode_u_32(arr[2]),
      compressedSize: dco_decode_u_32(arr[3]),
      path: dco_decode_String(arr[4]),
    );
  }

  @protected
  WdbData dco_decode_wdb_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return WdbData(
      header: dco_decode_Map_String_wdb_value_None(arr[0]),
      records: dco_decode_list_Map_String_wdb_value_None(arr[1]),
    );
  }

  @protected
  WdbValue dco_decode_wdb_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return WdbValue_Int(
          dco_decode_i_32(raw[1]),
        );
      case 1:
        return WdbValue_UInt(
          dco_decode_u_32(raw[1]),
        );
      case 2:
        return WdbValue_Float(
          dco_decode_f_32(raw[1]),
        );
      case 3:
        return WdbValue_String(
          dco_decode_String(raw[1]),
        );
      case 4:
        return WdbValue_Bool(
          dco_decode_bool(raw[1]),
        );
      case 5:
        return WdbValue_IntArray(
          dco_decode_list_prim_i_32_strict(raw[1]),
        );
      case 6:
        return WdbValue_UIntArray(
          dco_decode_list_prim_u_32_strict(raw[1]),
        );
      case 7:
        return WdbValue_StringArray(
          dco_decode_list_String(raw[1]),
        );
      case 8:
        return WdbValue_UInt64(
          dco_decode_u_64(raw[1]),
        );
      case 9:
        return WdbValue_CrystalRole(
          dco_decode_crystal_role(raw[1]),
        );
      case 10:
        return WdbValue_CrystalNodeType(
          dco_decode_crystal_node_type(raw[1]),
        );
      case 11:
        return WdbValue_Unknown();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  WpdData dco_decode_wpd_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return WpdData(
      records: dco_decode_list_wpd_record(arr[0]),
    );
  }

  @protected
  WpdRecord dco_decode_wpd_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return WpdRecord(
      name: dco_decode_String(arr[0]),
      extension_: dco_decode_String(arr[1]),
      data: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  ZtrData dco_decode_ztr_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ZtrData(
      entries: dco_decode_list_ztr_entry(arr[0]),
      mappings: dco_decode_list_ztr_map_entry(arr[1]),
    );
  }

  @protected
  ZtrDirectoryResult dco_decode_ztr_directory_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ZtrDirectoryResult(
      entries: dco_decode_list_ztr_entry_with_source(arr[0]),
      parsedFiles: dco_decode_list_String(arr[1]),
      failedFiles: dco_decode_list_ztr_file_error(arr[2]),
      totalFiles: dco_decode_usize(arr[3]),
    );
  }

  @protected
  ZtrEntry dco_decode_ztr_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ZtrEntry(
      id: dco_decode_String(arr[0]),
      text: dco_decode_String(arr[1]),
    );
  }

  @protected
  ZtrEntryWithSource dco_decode_ztr_entry_with_source(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ZtrEntryWithSource(
      id: dco_decode_String(arr[0]),
      text: dco_decode_String(arr[1]),
      sourceFile: dco_decode_String(arr[2]),
    );
  }

  @protected
  ZtrFileError dco_decode_ztr_file_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ZtrFileError(
      filePath: dco_decode_String(arr[0]),
      error: dco_decode_String(arr[1]),
    );
  }

  @protected
  ZtrMapEntry dco_decode_ztr_map_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ZtrMapEntry(
      key: dco_decode_String(arr[0]),
      value: dco_decode_String(arr[1]),
    );
  }

  @protected
  ZtrParseProgress dco_decode_ztr_parse_progress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ZtrParseProgress(
      totalFiles: dco_decode_usize(arr[0]),
      processedFiles: dco_decode_usize(arr[1]),
      successCount: dco_decode_usize(arr[2]),
      errorCount: dco_decode_usize(arr[3]),
      currentFile: dco_decode_String(arr[4]),
      stage: dco_decode_String(arr[5]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  Map<String, WdbValue> sse_decode_Map_String_wdb_value_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_wdb_value(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  RustStreamSink<String> sse_decode_StreamSink_String_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<ZtrParseProgress> sse_decode_StreamSink_ztr_parse_progress_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  Action sse_decode_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Action.values[inner];
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  WdbData sse_decode_box_autoadd_wdb_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_wdb_data(deserializer));
  }

  @protected
  ZtrData sse_decode_box_autoadd_ztr_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ztr_data(deserializer));
  }

  @protected
  CrystalNodeType sse_decode_crystal_node_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return CrystalNodeType.values[inner];
  }

  @protected
  CrystalRole sse_decode_crystal_role(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return CrystalRole.values[inner];
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  ImgData sse_decode_img_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_width = sse_decode_u_16(deserializer);
    var var_height = sse_decode_u_16(deserializer);
    var var_mipCount = sse_decode_u_8(deserializer);
    var var_format = sse_decode_String(deserializer);
    return ImgData(
        width: var_width,
        height: var_height,
        mipCount: var_mipCount,
        format: var_format);
  }

  @protected
  List<Map<String, WdbValue>> sse_decode_list_Map_String_wdb_value_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Map<String, WdbValue>>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_Map_String_wdb_value_None(deserializer));
    }
    return ans_;
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  Int32List sse_decode_list_prim_i_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getInt32List(len_);
  }

  @protected
  Uint32List sse_decode_list_prim_u_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint32List(len_);
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint64List sse_decode_list_prim_usize_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint64List(len_);
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, WdbValue)> sse_decode_list_record_string_wdb_value(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, WdbValue)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_wdb_value(deserializer));
    }
    return ans_;
  }

  @protected
  List<WbtFileEntry> sse_decode_list_wbt_file_entry(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WbtFileEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wbt_file_entry(deserializer));
    }
    return ans_;
  }

  @protected
  List<WpdRecord> sse_decode_list_wpd_record(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WpdRecord>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wpd_record(deserializer));
    }
    return ans_;
  }

  @protected
  List<ZtrEntry> sse_decode_list_ztr_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ZtrEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ztr_entry(deserializer));
    }
    return ans_;
  }

  @protected
  List<ZtrEntryWithSource> sse_decode_list_ztr_entry_with_source(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ZtrEntryWithSource>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ztr_entry_with_source(deserializer));
    }
    return ans_;
  }

  @protected
  List<ZtrFileError> sse_decode_list_ztr_file_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ZtrFileError>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ztr_file_error(deserializer));
    }
    return ans_;
  }

  @protected
  List<ZtrMapEntry> sse_decode_list_ztr_map_entry(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ZtrMapEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ztr_map_entry(deserializer));
    }
    return ans_;
  }

  @protected
  (ImgData, Uint8List) sse_decode_record_img_data_list_prim_u_8_strict(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_img_data(deserializer);
    var var_field1 = sse_decode_list_prim_u_8_strict(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, String) sse_decode_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, WdbValue) sse_decode_record_string_wdb_value(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_wdb_value(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  TargetType sse_decode_target_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return TargetType.values[inner];
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  WbtFileEntry sse_decode_wbt_file_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_usize(deserializer);
    var var_offset = sse_decode_u_64(deserializer);
    var var_uncompressedSize = sse_decode_u_32(deserializer);
    var var_compressedSize = sse_decode_u_32(deserializer);
    var var_path = sse_decode_String(deserializer);
    return WbtFileEntry(
        index: var_index,
        offset: var_offset,
        uncompressedSize: var_uncompressedSize,
        compressedSize: var_compressedSize,
        path: var_path);
  }

  @protected
  WdbData sse_decode_wdb_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_header = sse_decode_Map_String_wdb_value_None(deserializer);
    var var_records = sse_decode_list_Map_String_wdb_value_None(deserializer);
    return WdbData(header: var_header, records: var_records);
  }

  @protected
  WdbValue sse_decode_wdb_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_i_32(deserializer);
        return WdbValue_Int(var_field0);
      case 1:
        var var_field0 = sse_decode_u_32(deserializer);
        return WdbValue_UInt(var_field0);
      case 2:
        var var_field0 = sse_decode_f_32(deserializer);
        return WdbValue_Float(var_field0);
      case 3:
        var var_field0 = sse_decode_String(deserializer);
        return WdbValue_String(var_field0);
      case 4:
        var var_field0 = sse_decode_bool(deserializer);
        return WdbValue_Bool(var_field0);
      case 5:
        var var_field0 = sse_decode_list_prim_i_32_strict(deserializer);
        return WdbValue_IntArray(var_field0);
      case 6:
        var var_field0 = sse_decode_list_prim_u_32_strict(deserializer);
        return WdbValue_UIntArray(var_field0);
      case 7:
        var var_field0 = sse_decode_list_String(deserializer);
        return WdbValue_StringArray(var_field0);
      case 8:
        var var_field0 = sse_decode_u_64(deserializer);
        return WdbValue_UInt64(var_field0);
      case 9:
        var var_field0 = sse_decode_crystal_role(deserializer);
        return WdbValue_CrystalRole(var_field0);
      case 10:
        var var_field0 = sse_decode_crystal_node_type(deserializer);
        return WdbValue_CrystalNodeType(var_field0);
      case 11:
        return WdbValue_Unknown();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  WpdData sse_decode_wpd_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_records = sse_decode_list_wpd_record(deserializer);
    return WpdData(records: var_records);
  }

  @protected
  WpdRecord sse_decode_wpd_record(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_extension_ = sse_decode_String(deserializer);
    var var_data = sse_decode_list_prim_u_8_strict(deserializer);
    return WpdRecord(
        name: var_name, extension_: var_extension_, data: var_data);
  }

  @protected
  ZtrData sse_decode_ztr_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_entries = sse_decode_list_ztr_entry(deserializer);
    var var_mappings = sse_decode_list_ztr_map_entry(deserializer);
    return ZtrData(entries: var_entries, mappings: var_mappings);
  }

  @protected
  ZtrDirectoryResult sse_decode_ztr_directory_result(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_entries = sse_decode_list_ztr_entry_with_source(deserializer);
    var var_parsedFiles = sse_decode_list_String(deserializer);
    var var_failedFiles = sse_decode_list_ztr_file_error(deserializer);
    var var_totalFiles = sse_decode_usize(deserializer);
    return ZtrDirectoryResult(
        entries: var_entries,
        parsedFiles: var_parsedFiles,
        failedFiles: var_failedFiles,
        totalFiles: var_totalFiles);
  }

  @protected
  ZtrEntry sse_decode_ztr_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_text = sse_decode_String(deserializer);
    return ZtrEntry(id: var_id, text: var_text);
  }

  @protected
  ZtrEntryWithSource sse_decode_ztr_entry_with_source(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_text = sse_decode_String(deserializer);
    var var_sourceFile = sse_decode_String(deserializer);
    return ZtrEntryWithSource(
        id: var_id, text: var_text, sourceFile: var_sourceFile);
  }

  @protected
  ZtrFileError sse_decode_ztr_file_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_filePath = sse_decode_String(deserializer);
    var var_error = sse_decode_String(deserializer);
    return ZtrFileError(filePath: var_filePath, error: var_error);
  }

  @protected
  ZtrMapEntry sse_decode_ztr_map_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_key = sse_decode_String(deserializer);
    var var_value = sse_decode_String(deserializer);
    return ZtrMapEntry(key: var_key, value: var_value);
  }

  @protected
  ZtrParseProgress sse_decode_ztr_parse_progress(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_totalFiles = sse_decode_usize(deserializer);
    var var_processedFiles = sse_decode_usize(deserializer);
    var var_successCount = sse_decode_usize(deserializer);
    var var_errorCount = sse_decode_usize(deserializer);
    var var_currentFile = sse_decode_String(deserializer);
    var var_stage = sse_decode_String(deserializer);
    return ZtrParseProgress(
        totalFiles: var_totalFiles,
        processedFiles: var_processedFiles,
        successCount: var_successCount,
        errorCount: var_errorCount,
        currentFile: var_currentFile,
        stage: var_stage);
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_Map_String_wdb_value_None(
      Map<String, WdbValue> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_wdb_value(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_StreamSink_String_Sse(
      RustStreamSink<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_ztr_parse_progress_Sse(
      RustStreamSink<ZtrParseProgress> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_ztr_parse_progress,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_action(Action self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_wdb_data(WdbData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_wdb_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ztr_data(ZtrData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ztr_data(self, serializer);
  }

  @protected
  void sse_encode_crystal_node_type(
      CrystalNodeType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_crystal_role(CrystalRole self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_img_data(ImgData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self.width, serializer);
    sse_encode_u_16(self.height, serializer);
    sse_encode_u_8(self.mipCount, serializer);
    sse_encode_String(self.format, serializer);
  }

  @protected
  void sse_encode_list_Map_String_wdb_value_None(
      List<Map<String, WdbValue>> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Map_String_wdb_value_None(item, serializer);
    }
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_i_32_strict(
      Int32List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putInt32List(self);
  }

  @protected
  void sse_encode_list_prim_u_32_strict(
      Uint32List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint32List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_prim_usize_strict(
      Uint64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint64List(self);
  }

  @protected
  void sse_encode_list_record_string_string(
      List<(String, String)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_wdb_value(
      List<(String, WdbValue)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_wdb_value(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wbt_file_entry(
      List<WbtFileEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wbt_file_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wpd_record(
      List<WpdRecord> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wpd_record(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ztr_entry(
      List<ZtrEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ztr_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ztr_entry_with_source(
      List<ZtrEntryWithSource> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ztr_entry_with_source(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ztr_file_error(
      List<ZtrFileError> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ztr_file_error(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ztr_map_entry(
      List<ZtrMapEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ztr_map_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_record_img_data_list_prim_u_8_strict(
      (ImgData, Uint8List) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_img_data(self.$1, serializer);
    sse_encode_list_prim_u_8_strict(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_string(
      (String, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_wdb_value(
      (String, WdbValue) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_wdb_value(self.$2, serializer);
  }

  @protected
  void sse_encode_target_type(TargetType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_wbt_file_entry(WbtFileEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.index, serializer);
    sse_encode_u_64(self.offset, serializer);
    sse_encode_u_32(self.uncompressedSize, serializer);
    sse_encode_u_32(self.compressedSize, serializer);
    sse_encode_String(self.path, serializer);
  }

  @protected
  void sse_encode_wdb_data(WdbData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Map_String_wdb_value_None(self.header, serializer);
    sse_encode_list_Map_String_wdb_value_None(self.records, serializer);
  }

  @protected
  void sse_encode_wdb_value(WdbValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case WdbValue_Int(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_i_32(field0, serializer);
      case WdbValue_UInt(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_32(field0, serializer);
      case WdbValue_Float(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_f_32(field0, serializer);
      case WdbValue_String(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_String(field0, serializer);
      case WdbValue_Bool(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_bool(field0, serializer);
      case WdbValue_IntArray(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_list_prim_i_32_strict(field0, serializer);
      case WdbValue_UIntArray(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_list_prim_u_32_strict(field0, serializer);
      case WdbValue_StringArray(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_list_String(field0, serializer);
      case WdbValue_UInt64(field0: final field0):
        sse_encode_i_32(8, serializer);
        sse_encode_u_64(field0, serializer);
      case WdbValue_CrystalRole(field0: final field0):
        sse_encode_i_32(9, serializer);
        sse_encode_crystal_role(field0, serializer);
      case WdbValue_CrystalNodeType(field0: final field0):
        sse_encode_i_32(10, serializer);
        sse_encode_crystal_node_type(field0, serializer);
      case WdbValue_Unknown():
        sse_encode_i_32(11, serializer);
    }
  }

  @protected
  void sse_encode_wpd_data(WpdData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_wpd_record(self.records, serializer);
  }

  @protected
  void sse_encode_wpd_record(WpdRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.extension_, serializer);
    sse_encode_list_prim_u_8_strict(self.data, serializer);
  }

  @protected
  void sse_encode_ztr_data(ZtrData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_ztr_entry(self.entries, serializer);
    sse_encode_list_ztr_map_entry(self.mappings, serializer);
  }

  @protected
  void sse_encode_ztr_directory_result(
      ZtrDirectoryResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_ztr_entry_with_source(self.entries, serializer);
    sse_encode_list_String(self.parsedFiles, serializer);
    sse_encode_list_ztr_file_error(self.failedFiles, serializer);
    sse_encode_usize(self.totalFiles, serializer);
  }

  @protected
  void sse_encode_ztr_entry(ZtrEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.text, serializer);
  }

  @protected
  void sse_encode_ztr_entry_with_source(
      ZtrEntryWithSource self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.text, serializer);
    sse_encode_String(self.sourceFile, serializer);
  }

  @protected
  void sse_encode_ztr_file_error(ZtrFileError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.filePath, serializer);
    sse_encode_String(self.error, serializer);
  }

  @protected
  void sse_encode_ztr_map_entry(ZtrMapEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.key, serializer);
    sse_encode_String(self.value, serializer);
  }

  @protected
  void sse_encode_ztr_parse_progress(
      ZtrParseProgress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.totalFiles, serializer);
    sse_encode_usize(self.processedFiles, serializer);
    sse_encode_usize(self.successCount, serializer);
    sse_encode_usize(self.errorCount, serializer);
    sse_encode_String(self.currentFile, serializer);
    sse_encode_String(self.stage, serializer);
  }
}

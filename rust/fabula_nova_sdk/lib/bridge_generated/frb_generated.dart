// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'modules/crystalium/structs.dart';
import 'modules/img/structs.dart';
import 'modules/vfx/structs.dart';
import 'modules/wct.dart';
import 'modules/wdb/enums.dart';
import 'modules/wdb/structs.dart';
import 'modules/wpd/structs.dart';
import 'modules/ztr/structs.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => 1786907440;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'fabula_nova_sdk',
    ioDirectory: 'target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<CgtFile> crateApiCgtFromJson({required String json});

  Future<CgtFile> crateApiCgtParse({required String inFile});

  Future<CgtFile> crateApiCgtParseFromMemory({required List<int> data});

  Future<String> crateApiCgtToJson({required CgtFile cgt});

  Future<List<String>> crateApiCgtValidate({required CgtFile cgt});

  Future<void> crateApiCgtWrite(
      {required CgtFile cgt, required String outFile});

  Future<Uint8List> crateApiCgtWriteToMemory({required CgtFile cgt});

  Future<void> crateApiClearLogCallback();

  Future<(int, int)> crateApiConvertDdsToPng(
      {required String ddsPath, required String pngPath});

  Future<((int, int), Uint8List)> crateApiConvertDdsToPngBytes(
      {required String ddsPath});

  Stream<String> crateApiCreateLogStream();

  Future<List<String>> crateApiFetchLogs();

  Future<List<String>> crateApiGetAllBufferedLogs();

  Future<int> crateApiGetLogLevel();

  Future<void> crateApiImgRepackStrict(
      {required String headerFile,
      required String imgbFile,
      required String inDds});

  Future<ImgData> crateApiImgUnpack(
      {required String headerFile,
      required String imgbFile,
      required String outDds});

  Future<(ImgData, Uint8List)> crateApiImgUnpackToMemory(
      {required String headerFile, required String imgbFile});

  Future<void> crateApiInitApp();

  Future<McpFile> crateApiMcpFromJson({required String json});

  Future<McpFile> crateApiMcpParse({required String inFile});

  Future<McpFile> crateApiMcpParseFromMemory({required List<int> data});

  Future<String> crateApiMcpToJson({required McpFile mcp});

  Future<void> crateApiResetLogReadIndex();

  Future<void> crateApiSetLogLevel({required int level});

  Future<void> crateApiTestLog({required String message});

  Future<String> crateApiVfxExportJson({required String inFile});

  Future<((int, int), Uint8List)> crateApiVfxExtractTextureAsPng(
      {required String xfvPath, required String textureName});

  Future<List<String>> crateApiVfxExtractTextures(
      {required String xfvPath, required String outputDir});

  Future<VfxSummary> crateApiVfxGetSummary({required String inFile});

  Future<List<String>> crateApiVfxListEffects({required String inFile});

  Future<List<VfxTexture>> crateApiVfxListTextures({required String inFile});

  Future<VfxData> crateApiVfxParse({required String inFile});

  Future<void> crateApiVfxPlayerDispose();

  Future<(int, int)> crateApiVfxPlayerGetDimensions();

  Future<double> crateApiVfxPlayerGetTime();

  Future<void> crateApiVfxPlayerInit({required int width, required int height});

  Future<bool> crateApiVfxPlayerIsInitialized();

  Future<void> crateApiVfxPlayerLoadModel(
      {required String xfvPath,
      required String modelName,
      required String textureName});

  Future<void> crateApiVfxPlayerLoadTest(
      {required double r,
      required double g,
      required double b,
      required double a});

  Future<Uint8List> crateApiVfxPlayerRenderFrame({required double deltaTime});

  Future<void> crateApiVfxPlayerReset();

  Future<void> crateApiWbtExtract(
      {required String filelistPath,
      required String containerPath,
      required String outDir,
      required int gameCode});

  Future<BigInt> crateApiWbtExtractDirectory(
      {required String filelistPath,
      required String containerPath,
      required String dirPrefix,
      required String outputDir,
      required int gameCode});

  Future<void> crateApiWbtExtractFileByIndex(
      {required String filelistPath,
      required String containerPath,
      required BigInt fileIndex,
      required String outputDir,
      required int gameCode});

  Future<BigInt> crateApiWbtExtractFilesByIndices(
      {required String filelistPath,
      required String containerPath,
      required Uint64List indices,
      required String outputDir,
      required int gameCode});

  Future<void> crateApiWbtExtractSingleFile(
      {required String filelistPath,
      required String containerPath,
      required String virtualPath,
      required String outputPath,
      required int gameCode});

  Future<List<WbtFileEntry>> crateApiWbtGetFileList(
      {required String filelistPath, required int gameCode});

  Future<void> crateApiWbtRepack(
      {required String filelistPath,
      required String containerPath,
      required String extractedDir,
      required int gameCode});

  Future<void> crateApiWbtRepackMultiple(
      {required String filelistPath,
      required String containerPath,
      required List<(String, String)> filesToPatch,
      required int gameCode});

  Future<void> crateApiWbtRepackSingle(
      {required String filelistPath,
      required String containerPath,
      required String targetPathInArchive,
      required String fileToInject,
      required int gameCode});

  Future<void> crateApiWctProcess(
      {required TargetType target,
      required Action action,
      required String inputFile});

  Future<WdbData> crateApiWdbFromJson({required String json});

  Future<WdbData> crateApiWdbParse(
      {required String inFile, required int gameCode});

  Future<void> crateApiWdbRepack(
      {required WdbData data, required String outFile});

  Future<String> crateApiWdbToJson({required WdbData data});

  Future<void> crateApiWpdRepack(
      {required String inDir, required String outFile});

  Future<WpdData> crateApiWpdUnpack(
      {required String inFile, required String outDir});

  Future<void> crateApiZtrExtractToText(
      {required String inFile, required String outFile, required int gameCode});

  Future<void> crateApiZtrPackFromData(
      {required List<(String, String)> entries,
      required String outFile,
      required int gameCode});

  Future<void> crateApiZtrPackFromStruct(
      {required ZtrData data, required String outFile, required int gameCode});

  Future<ZtrData> crateApiZtrParse(
      {required String inFile, required int gameCode});

  Stream<ZtrParseProgress> crateApiZtrParseDirectory(
      {required String dirPath, required int gameCode});

  Future<ZtrDirectoryResult> crateApiZtrParseDirectorySimple(
      {required String dirPath, required int gameCode});

  Future<ZtrData> crateApiZtrParseFromMemory(
      {required List<int> data, required int gameCode});

  Future<String> crateApiZtrToTextString({required ZtrData data});
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<CgtFile> crateApiCgtFromJson({required String json}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(json, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_cgt_file,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCgtFromJsonConstMeta,
      argValues: [json],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCgtFromJsonConstMeta => const TaskConstMeta(
        debugName: "cgt_from_json",
        argNames: ["json"],
      );

  @override
  Future<CgtFile> crateApiCgtParse({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_cgt_file,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCgtParseConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCgtParseConstMeta => const TaskConstMeta(
        debugName: "cgt_parse",
        argNames: ["inFile"],
      );

  @override
  Future<CgtFile> crateApiCgtParseFromMemory({required List<int> data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_cgt_file,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCgtParseFromMemoryConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCgtParseFromMemoryConstMeta => const TaskConstMeta(
        debugName: "cgt_parse_from_memory",
        argNames: ["data"],
      );

  @override
  Future<String> crateApiCgtToJson({required CgtFile cgt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_cgt_file(cgt, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCgtToJsonConstMeta,
      argValues: [cgt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCgtToJsonConstMeta => const TaskConstMeta(
        debugName: "cgt_to_json",
        argNames: ["cgt"],
      );

  @override
  Future<List<String>> crateApiCgtValidate({required CgtFile cgt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_cgt_file(cgt, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCgtValidateConstMeta,
      argValues: [cgt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCgtValidateConstMeta => const TaskConstMeta(
        debugName: "cgt_validate",
        argNames: ["cgt"],
      );

  @override
  Future<void> crateApiCgtWrite(
      {required CgtFile cgt, required String outFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_cgt_file(cgt, serializer);
        sse_encode_String(outFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCgtWriteConstMeta,
      argValues: [cgt, outFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCgtWriteConstMeta => const TaskConstMeta(
        debugName: "cgt_write",
        argNames: ["cgt", "outFile"],
      );

  @override
  Future<Uint8List> crateApiCgtWriteToMemory({required CgtFile cgt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_cgt_file(cgt, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCgtWriteToMemoryConstMeta,
      argValues: [cgt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCgtWriteToMemoryConstMeta => const TaskConstMeta(
        debugName: "cgt_write_to_memory",
        argNames: ["cgt"],
      );

  @override
  Future<void> crateApiClearLogCallback() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiClearLogCallbackConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiClearLogCallbackConstMeta => const TaskConstMeta(
        debugName: "clear_log_callback",
        argNames: [],
      );

  @override
  Future<(int, int)> crateApiConvertDdsToPng(
      {required String ddsPath, required String pngPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(ddsPath, serializer);
        sse_encode_String(pngPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_u_32_u_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiConvertDdsToPngConstMeta,
      argValues: [ddsPath, pngPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiConvertDdsToPngConstMeta => const TaskConstMeta(
        debugName: "convert_dds_to_png",
        argNames: ["ddsPath", "pngPath"],
      );

  @override
  Future<((int, int), Uint8List)> crateApiConvertDdsToPngBytes(
      {required String ddsPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(ddsPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_record_record_u_32_u_32_list_prim_u_8_strict,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiConvertDdsToPngBytesConstMeta,
      argValues: [ddsPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiConvertDdsToPngBytesConstMeta =>
      const TaskConstMeta(
        debugName: "convert_dds_to_png_bytes",
        argNames: ["ddsPath"],
      );

  @override
  Stream<String> crateApiCreateLogStream() {
    final sink = RustStreamSink<String>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_StreamSink_String_Sse(sink, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCreateLogStreamConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiCreateLogStreamConstMeta => const TaskConstMeta(
        debugName: "create_log_stream",
        argNames: ["sink"],
      );

  @override
  Future<List<String>> crateApiFetchLogs() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFetchLogsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFetchLogsConstMeta => const TaskConstMeta(
        debugName: "fetch_logs",
        argNames: [],
      );

  @override
  Future<List<String>> crateApiGetAllBufferedLogs() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetAllBufferedLogsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetAllBufferedLogsConstMeta => const TaskConstMeta(
        debugName: "get_all_buffered_logs",
        argNames: [],
      );

  @override
  Future<int> crateApiGetLogLevel() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetLogLevelConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetLogLevelConstMeta => const TaskConstMeta(
        debugName: "get_log_level",
        argNames: [],
      );

  @override
  Future<void> crateApiImgRepackStrict(
      {required String headerFile,
      required String imgbFile,
      required String inDds}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(headerFile, serializer);
        sse_encode_String(imgbFile, serializer);
        sse_encode_String(inDds, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiImgRepackStrictConstMeta,
      argValues: [headerFile, imgbFile, inDds],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiImgRepackStrictConstMeta => const TaskConstMeta(
        debugName: "img_repack_strict",
        argNames: ["headerFile", "imgbFile", "inDds"],
      );

  @override
  Future<ImgData> crateApiImgUnpack(
      {required String headerFile,
      required String imgbFile,
      required String outDds}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(headerFile, serializer);
        sse_encode_String(imgbFile, serializer);
        sse_encode_String(outDds, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_img_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiImgUnpackConstMeta,
      argValues: [headerFile, imgbFile, outDds],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiImgUnpackConstMeta => const TaskConstMeta(
        debugName: "img_unpack",
        argNames: ["headerFile", "imgbFile", "outDds"],
      );

  @override
  Future<(ImgData, Uint8List)> crateApiImgUnpackToMemory(
      {required String headerFile, required String imgbFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(headerFile, serializer);
        sse_encode_String(imgbFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_img_data_list_prim_u_8_strict,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiImgUnpackToMemoryConstMeta,
      argValues: [headerFile, imgbFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiImgUnpackToMemoryConstMeta => const TaskConstMeta(
        debugName: "img_unpack_to_memory",
        argNames: ["headerFile", "imgbFile"],
      );

  @override
  Future<void> crateApiInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Future<McpFile> crateApiMcpFromJson({required String json}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(json, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_mcp_file,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMcpFromJsonConstMeta,
      argValues: [json],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMcpFromJsonConstMeta => const TaskConstMeta(
        debugName: "mcp_from_json",
        argNames: ["json"],
      );

  @override
  Future<McpFile> crateApiMcpParse({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_mcp_file,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMcpParseConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMcpParseConstMeta => const TaskConstMeta(
        debugName: "mcp_parse",
        argNames: ["inFile"],
      );

  @override
  Future<McpFile> crateApiMcpParseFromMemory({required List<int> data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_mcp_file,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMcpParseFromMemoryConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMcpParseFromMemoryConstMeta => const TaskConstMeta(
        debugName: "mcp_parse_from_memory",
        argNames: ["data"],
      );

  @override
  Future<String> crateApiMcpToJson({required McpFile mcp}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_mcp_file(mcp, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMcpToJsonConstMeta,
      argValues: [mcp],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMcpToJsonConstMeta => const TaskConstMeta(
        debugName: "mcp_to_json",
        argNames: ["mcp"],
      );

  @override
  Future<void> crateApiResetLogReadIndex() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiResetLogReadIndexConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiResetLogReadIndexConstMeta => const TaskConstMeta(
        debugName: "reset_log_read_index",
        argNames: [],
      );

  @override
  Future<void> crateApiSetLogLevel({required int level}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(level, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSetLogLevelConstMeta,
      argValues: [level],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetLogLevelConstMeta => const TaskConstMeta(
        debugName: "set_log_level",
        argNames: ["level"],
      );

  @override
  Future<void> crateApiTestLog({required String message}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(message, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiTestLogConstMeta,
      argValues: [message],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTestLogConstMeta => const TaskConstMeta(
        debugName: "test_log",
        argNames: ["message"],
      );

  @override
  Future<String> crateApiVfxExportJson({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxExportJsonConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxExportJsonConstMeta => const TaskConstMeta(
        debugName: "vfx_export_json",
        argNames: ["inFile"],
      );

  @override
  Future<((int, int), Uint8List)> crateApiVfxExtractTextureAsPng(
      {required String xfvPath, required String textureName}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(xfvPath, serializer);
        sse_encode_String(textureName, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_record_record_u_32_u_32_list_prim_u_8_strict,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxExtractTextureAsPngConstMeta,
      argValues: [xfvPath, textureName],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxExtractTextureAsPngConstMeta =>
      const TaskConstMeta(
        debugName: "vfx_extract_texture_as_png",
        argNames: ["xfvPath", "textureName"],
      );

  @override
  Future<List<String>> crateApiVfxExtractTextures(
      {required String xfvPath, required String outputDir}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(xfvPath, serializer);
        sse_encode_String(outputDir, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxExtractTexturesConstMeta,
      argValues: [xfvPath, outputDir],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxExtractTexturesConstMeta => const TaskConstMeta(
        debugName: "vfx_extract_textures",
        argNames: ["xfvPath", "outputDir"],
      );

  @override
  Future<VfxSummary> crateApiVfxGetSummary({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_vfx_summary,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxGetSummaryConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxGetSummaryConstMeta => const TaskConstMeta(
        debugName: "vfx_get_summary",
        argNames: ["inFile"],
      );

  @override
  Future<List<String>> crateApiVfxListEffects({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxListEffectsConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxListEffectsConstMeta => const TaskConstMeta(
        debugName: "vfx_list_effects",
        argNames: ["inFile"],
      );

  @override
  Future<List<VfxTexture>> crateApiVfxListTextures({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_vfx_texture,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxListTexturesConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxListTexturesConstMeta => const TaskConstMeta(
        debugName: "vfx_list_textures",
        argNames: ["inFile"],
      );

  @override
  Future<VfxData> crateApiVfxParse({required String inFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_vfx_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxParseConstMeta,
      argValues: [inFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxParseConstMeta => const TaskConstMeta(
        debugName: "vfx_parse",
        argNames: ["inFile"],
      );

  @override
  Future<void> crateApiVfxPlayerDispose() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVfxPlayerDisposeConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxPlayerDisposeConstMeta => const TaskConstMeta(
        debugName: "vfx_player_dispose",
        argNames: [],
      );

  @override
  Future<(int, int)> crateApiVfxPlayerGetDimensions() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_u_32_u_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxPlayerGetDimensionsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxPlayerGetDimensionsConstMeta =>
      const TaskConstMeta(
        debugName: "vfx_player_get_dimensions",
        argNames: [],
      );

  @override
  Future<double> crateApiVfxPlayerGetTime() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxPlayerGetTimeConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxPlayerGetTimeConstMeta => const TaskConstMeta(
        debugName: "vfx_player_get_time",
        argNames: [],
      );

  @override
  Future<void> crateApiVfxPlayerInit(
      {required int width, required int height}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(width, serializer);
        sse_encode_u_32(height, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxPlayerInitConstMeta,
      argValues: [width, height],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxPlayerInitConstMeta => const TaskConstMeta(
        debugName: "vfx_player_init",
        argNames: ["width", "height"],
      );

  @override
  Future<bool> crateApiVfxPlayerIsInitialized() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVfxPlayerIsInitializedConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxPlayerIsInitializedConstMeta =>
      const TaskConstMeta(
        debugName: "vfx_player_is_initialized",
        argNames: [],
      );

  @override
  Future<void> crateApiVfxPlayerLoadModel(
      {required String xfvPath,
      required String modelName,
      required String textureName}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(xfvPath, serializer);
        sse_encode_String(modelName, serializer);
        sse_encode_String(textureName, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 38, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxPlayerLoadModelConstMeta,
      argValues: [xfvPath, modelName, textureName],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxPlayerLoadModelConstMeta => const TaskConstMeta(
        debugName: "vfx_player_load_model",
        argNames: ["xfvPath", "modelName", "textureName"],
      );

  @override
  Future<void> crateApiVfxPlayerLoadTest(
      {required double r,
      required double g,
      required double b,
      required double a}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_f_32(r, serializer);
        sse_encode_f_32(g, serializer);
        sse_encode_f_32(b, serializer);
        sse_encode_f_32(a, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 39, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxPlayerLoadTestConstMeta,
      argValues: [r, g, b, a],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxPlayerLoadTestConstMeta => const TaskConstMeta(
        debugName: "vfx_player_load_test",
        argNames: ["r", "g", "b", "a"],
      );

  @override
  Future<Uint8List> crateApiVfxPlayerRenderFrame({required double deltaTime}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_f_32(deltaTime, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 40, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxPlayerRenderFrameConstMeta,
      argValues: [deltaTime],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxPlayerRenderFrameConstMeta =>
      const TaskConstMeta(
        debugName: "vfx_player_render_frame",
        argNames: ["deltaTime"],
      );

  @override
  Future<void> crateApiVfxPlayerReset() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 41, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVfxPlayerResetConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVfxPlayerResetConstMeta => const TaskConstMeta(
        debugName: "vfx_player_reset",
        argNames: [],
      );

  @override
  Future<void> crateApiWbtExtract(
      {required String filelistPath,
      required String containerPath,
      required String outDir,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_String(outDir, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 42, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtExtractConstMeta,
      argValues: [filelistPath, containerPath, outDir, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtExtractConstMeta => const TaskConstMeta(
        debugName: "wbt_extract",
        argNames: ["filelistPath", "containerPath", "outDir", "gameCode"],
      );

  @override
  Future<BigInt> crateApiWbtExtractDirectory(
      {required String filelistPath,
      required String containerPath,
      required String dirPrefix,
      required String outputDir,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_String(dirPrefix, serializer);
        sse_encode_String(outputDir, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 43, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtExtractDirectoryConstMeta,
      argValues: [filelistPath, containerPath, dirPrefix, outputDir, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtExtractDirectoryConstMeta =>
      const TaskConstMeta(
        debugName: "wbt_extract_directory",
        argNames: [
          "filelistPath",
          "containerPath",
          "dirPrefix",
          "outputDir",
          "gameCode"
        ],
      );

  @override
  Future<void> crateApiWbtExtractFileByIndex(
      {required String filelistPath,
      required String containerPath,
      required BigInt fileIndex,
      required String outputDir,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_usize(fileIndex, serializer);
        sse_encode_String(outputDir, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 44, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtExtractFileByIndexConstMeta,
      argValues: [filelistPath, containerPath, fileIndex, outputDir, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtExtractFileByIndexConstMeta =>
      const TaskConstMeta(
        debugName: "wbt_extract_file_by_index",
        argNames: [
          "filelistPath",
          "containerPath",
          "fileIndex",
          "outputDir",
          "gameCode"
        ],
      );

  @override
  Future<BigInt> crateApiWbtExtractFilesByIndices(
      {required String filelistPath,
      required String containerPath,
      required Uint64List indices,
      required String outputDir,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_list_prim_usize_strict(indices, serializer);
        sse_encode_String(outputDir, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 45, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtExtractFilesByIndicesConstMeta,
      argValues: [filelistPath, containerPath, indices, outputDir, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtExtractFilesByIndicesConstMeta =>
      const TaskConstMeta(
        debugName: "wbt_extract_files_by_indices",
        argNames: [
          "filelistPath",
          "containerPath",
          "indices",
          "outputDir",
          "gameCode"
        ],
      );

  @override
  Future<void> crateApiWbtExtractSingleFile(
      {required String filelistPath,
      required String containerPath,
      required String virtualPath,
      required String outputPath,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_String(virtualPath, serializer);
        sse_encode_String(outputPath, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 46, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtExtractSingleFileConstMeta,
      argValues: [
        filelistPath,
        containerPath,
        virtualPath,
        outputPath,
        gameCode
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtExtractSingleFileConstMeta =>
      const TaskConstMeta(
        debugName: "wbt_extract_single_file",
        argNames: [
          "filelistPath",
          "containerPath",
          "virtualPath",
          "outputPath",
          "gameCode"
        ],
      );

  @override
  Future<List<WbtFileEntry>> crateApiWbtGetFileList(
      {required String filelistPath, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 47, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_wbt_file_entry,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtGetFileListConstMeta,
      argValues: [filelistPath, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtGetFileListConstMeta => const TaskConstMeta(
        debugName: "wbt_get_file_list",
        argNames: ["filelistPath", "gameCode"],
      );

  @override
  Future<void> crateApiWbtRepack(
      {required String filelistPath,
      required String containerPath,
      required String extractedDir,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_String(extractedDir, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 48, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtRepackConstMeta,
      argValues: [filelistPath, containerPath, extractedDir, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtRepackConstMeta => const TaskConstMeta(
        debugName: "wbt_repack",
        argNames: ["filelistPath", "containerPath", "extractedDir", "gameCode"],
      );

  @override
  Future<void> crateApiWbtRepackMultiple(
      {required String filelistPath,
      required String containerPath,
      required List<(String, String)> filesToPatch,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_list_record_string_string(filesToPatch, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 49, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtRepackMultipleConstMeta,
      argValues: [filelistPath, containerPath, filesToPatch, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtRepackMultipleConstMeta => const TaskConstMeta(
        debugName: "wbt_repack_multiple",
        argNames: ["filelistPath", "containerPath", "filesToPatch", "gameCode"],
      );

  @override
  Future<void> crateApiWbtRepackSingle(
      {required String filelistPath,
      required String containerPath,
      required String targetPathInArchive,
      required String fileToInject,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filelistPath, serializer);
        sse_encode_String(containerPath, serializer);
        sse_encode_String(targetPathInArchive, serializer);
        sse_encode_String(fileToInject, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 50, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWbtRepackSingleConstMeta,
      argValues: [
        filelistPath,
        containerPath,
        targetPathInArchive,
        fileToInject,
        gameCode
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWbtRepackSingleConstMeta => const TaskConstMeta(
        debugName: "wbt_repack_single",
        argNames: [
          "filelistPath",
          "containerPath",
          "targetPathInArchive",
          "fileToInject",
          "gameCode"
        ],
      );

  @override
  Future<void> crateApiWctProcess(
      {required TargetType target,
      required Action action,
      required String inputFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_target_type(target, serializer);
        sse_encode_action(action, serializer);
        sse_encode_String(inputFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 51, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWctProcessConstMeta,
      argValues: [target, action, inputFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWctProcessConstMeta => const TaskConstMeta(
        debugName: "wct_process",
        argNames: ["target", "action", "inputFile"],
      );

  @override
  Future<WdbData> crateApiWdbFromJson({required String json}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(json, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 52, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wdb_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWdbFromJsonConstMeta,
      argValues: [json],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWdbFromJsonConstMeta => const TaskConstMeta(
        debugName: "wdb_from_json",
        argNames: ["json"],
      );

  @override
  Future<WdbData> crateApiWdbParse(
      {required String inFile, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 53, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wdb_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWdbParseConstMeta,
      argValues: [inFile, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWdbParseConstMeta => const TaskConstMeta(
        debugName: "wdb_parse",
        argNames: ["inFile", "gameCode"],
      );

  @override
  Future<void> crateApiWdbRepack(
      {required WdbData data, required String outFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_wdb_data(data, serializer);
        sse_encode_String(outFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 54, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWdbRepackConstMeta,
      argValues: [data, outFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWdbRepackConstMeta => const TaskConstMeta(
        debugName: "wdb_repack",
        argNames: ["data", "outFile"],
      );

  @override
  Future<String> crateApiWdbToJson({required WdbData data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_wdb_data(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 55, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWdbToJsonConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWdbToJsonConstMeta => const TaskConstMeta(
        debugName: "wdb_to_json",
        argNames: ["data"],
      );

  @override
  Future<void> crateApiWpdRepack(
      {required String inDir, required String outFile}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inDir, serializer);
        sse_encode_String(outFile, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 56, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWpdRepackConstMeta,
      argValues: [inDir, outFile],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWpdRepackConstMeta => const TaskConstMeta(
        debugName: "wpd_repack",
        argNames: ["inDir", "outFile"],
      );

  @override
  Future<WpdData> crateApiWpdUnpack(
      {required String inFile, required String outDir}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        sse_encode_String(outDir, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 57, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wpd_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWpdUnpackConstMeta,
      argValues: [inFile, outDir],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWpdUnpackConstMeta => const TaskConstMeta(
        debugName: "wpd_unpack",
        argNames: ["inFile", "outDir"],
      );

  @override
  Future<void> crateApiZtrExtractToText(
      {required String inFile,
      required String outFile,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        sse_encode_String(outFile, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 58, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiZtrExtractToTextConstMeta,
      argValues: [inFile, outFile, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrExtractToTextConstMeta => const TaskConstMeta(
        debugName: "ztr_extract_to_text",
        argNames: ["inFile", "outFile", "gameCode"],
      );

  @override
  Future<void> crateApiZtrPackFromData(
      {required List<(String, String)> entries,
      required String outFile,
      required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_record_string_string(entries, serializer);
        sse_encode_String(outFile, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 59, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiZtrPackFromDataConstMeta,
      argValues: [entries, outFile, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrPackFromDataConstMeta => const TaskConstMeta(
        debugName: "ztr_pack_from_data",
        argNames: ["entries", "outFile", "gameCode"],
      );

  @override
  Future<void> crateApiZtrPackFromStruct(
      {required ZtrData data, required String outFile, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ztr_data(data, serializer);
        sse_encode_String(outFile, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 60, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiZtrPackFromStructConstMeta,
      argValues: [data, outFile, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrPackFromStructConstMeta => const TaskConstMeta(
        debugName: "ztr_pack_from_struct",
        argNames: ["data", "outFile", "gameCode"],
      );

  @override
  Future<ZtrData> crateApiZtrParse(
      {required String inFile, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(inFile, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 61, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ztr_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiZtrParseConstMeta,
      argValues: [inFile, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrParseConstMeta => const TaskConstMeta(
        debugName: "ztr_parse",
        argNames: ["inFile", "gameCode"],
      );

  @override
  Stream<ZtrParseProgress> crateApiZtrParseDirectory(
      {required String dirPath, required int gameCode}) {
    final progressSink = RustStreamSink<ZtrParseProgress>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dirPath, serializer);
        sse_encode_i_32(gameCode, serializer);
        sse_encode_StreamSink_ztr_parse_progress_Sse(progressSink, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 62, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ztr_directory_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiZtrParseDirectoryConstMeta,
      argValues: [dirPath, gameCode, progressSink],
      apiImpl: this,
    )));
    return progressSink.stream;
  }

  TaskConstMeta get kCrateApiZtrParseDirectoryConstMeta => const TaskConstMeta(
        debugName: "ztr_parse_directory",
        argNames: ["dirPath", "gameCode", "progressSink"],
      );

  @override
  Future<ZtrDirectoryResult> crateApiZtrParseDirectorySimple(
      {required String dirPath, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dirPath, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 63, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ztr_directory_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiZtrParseDirectorySimpleConstMeta,
      argValues: [dirPath, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrParseDirectorySimpleConstMeta =>
      const TaskConstMeta(
        debugName: "ztr_parse_directory_simple",
        argNames: ["dirPath", "gameCode"],
      );

  @override
  Future<ZtrData> crateApiZtrParseFromMemory(
      {required List<int> data, required int gameCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(data, serializer);
        sse_encode_i_32(gameCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 64, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ztr_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiZtrParseFromMemoryConstMeta,
      argValues: [data, gameCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrParseFromMemoryConstMeta => const TaskConstMeta(
        debugName: "ztr_parse_from_memory",
        argNames: ["data", "gameCode"],
      );

  @override
  Future<String> crateApiZtrToTextString({required ZtrData data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ztr_data(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 65, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiZtrToTextStringConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZtrToTextStringConstMeta => const TaskConstMeta(
        debugName: "ztr_to_text_string",
        argNames: ["data"],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  Map<String, McpPattern> dco_decode_Map_String_mcp_pattern_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_mcp_pattern(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<String, WdbValue> dco_decode_Map_String_wdb_value_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_wdb_value(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  RustStreamSink<String> dco_decode_StreamSink_String_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<ZtrParseProgress> dco_decode_StreamSink_ztr_parse_progress_Sse(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  Action dco_decode_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Action.values[raw as int];
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  CgtFile dco_decode_box_autoadd_cgt_file(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_cgt_file(raw);
  }

  @protected
  McpFile dco_decode_box_autoadd_mcp_file(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_mcp_file(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  VfxMesh dco_decode_box_autoadd_vfx_mesh(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_vfx_mesh(raw);
  }

  @protected
  WdbData dco_decode_box_autoadd_wdb_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_wdb_data(raw);
  }

  @protected
  ZtrData dco_decode_box_autoadd_ztr_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ztr_data(raw);
  }

  @protected
  CgtFile dco_decode_cgt_file(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return CgtFile(
      version: dco_decode_u_32(arr[0]),
      entryCount: dco_decode_u_32(arr[1]),
      totalNodes: dco_decode_u_32(arr[2]),
      reserved: dco_decode_u_32(arr[3]),
      entries: dco_decode_list_crystarium_entry(arr[4]),
      nodes: dco_decode_list_crystarium_node(arr[5]),
    );
  }

  @protected
  CrystalNodeType dco_decode_crystal_node_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CrystalNodeType.values[raw as int];
  }

  @protected
  CrystalRole dco_decode_crystal_role(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CrystalRole.values[raw as int];
  }

  @protected
  CrystariumEntry dco_decode_crystarium_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 14)
      throw Exception('unexpected arr length: expect 14 but see ${arr.length}');
    return CrystariumEntry(
      index: dco_decode_u_32(arr[0]),
      patternName: dco_decode_String(arr[1]),
      position: dco_decode_vec_3(arr[2]),
      scale: dco_decode_f_32(arr[3]),
      rotation: dco_decode_vec_3(arr[4]),
      rotationW: dco_decode_f_32(arr[5]),
      nodeScale: dco_decode_f_32(arr[6]),
      roleId: dco_decode_u_8(arr[7]),
      stage: dco_decode_u_8(arr[8]),
      entryType: dco_decode_u_8(arr[9]),
      reserved: dco_decode_u_8(arr[10]),
      nodeIds: dco_decode_list_prim_u_32_strict(arr[11]),
      linkPosition: dco_decode_vec_3(arr[12]),
      linkW: dco_decode_f_32(arr[13]),
    );
  }

  @protected
  CrystariumNode dco_decode_crystarium_node(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return CrystariumNode(
      index: dco_decode_u_32(arr[0]),
      name: dco_decode_String(arr[1]),
      parentIndex: dco_decode_i_32(arr[2]),
      unknown: dco_decode_u_32_array_4(arr[3]),
      scales: dco_decode_f_32_array_4(arr[4]),
    );
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  F32Array2 dco_decode_f_32_array_2(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return F32Array2(dco_decode_list_prim_f_32_strict(raw));
  }

  @protected
  F32Array3 dco_decode_f_32_array_3(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return F32Array3(dco_decode_list_prim_f_32_strict(raw));
  }

  @protected
  F32Array4 dco_decode_f_32_array_4(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return F32Array4(dco_decode_list_prim_f_32_strict(raw));
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  ImgData dco_decode_img_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ImgData(
      width: dco_decode_u_16(arr[0]),
      height: dco_decode_u_16(arr[1]),
      mipCount: dco_decode_u_8(arr[2]),
      format: dco_decode_String(arr[3]),
    );
  }

  @protected
  List<Map<String, WdbValue>> dco_decode_list_Map_String_wdb_value_None(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_Map_String_wdb_value_None)
        .toList();
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<CrystariumEntry> dco_decode_list_crystarium_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_crystarium_entry).toList();
  }

  @protected
  List<CrystariumNode> dco_decode_list_crystarium_node(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_crystarium_node).toList();
  }

  @protected
  Float32List dco_decode_list_prim_f_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Float32List;
  }

  @protected
  Int32List dco_decode_list_prim_i_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Int32List;
  }

  @protected
  Uint16List dco_decode_list_prim_u_16_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint16List;
  }

  @protected
  Uint32List dco_decode_list_prim_u_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint32List;
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  Uint64List dco_decode_list_prim_usize_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint64List;
  }

  @protected
  List<(String, McpPattern)> dco_decode_list_record_string_mcp_pattern(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_string_mcp_pattern)
        .toList();
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  List<(String, WdbValue)> dco_decode_list_record_string_wdb_value(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_string_wdb_value)
        .toList();
  }

  @protected
  List<Vec3> dco_decode_list_vec_3(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_vec_3).toList();
  }

  @protected
  List<VfxAnimation> dco_decode_list_vfx_animation(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_vfx_animation).toList();
  }

  @protected
  List<VfxEffect> dco_decode_list_vfx_effect(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_vfx_effect).toList();
  }

  @protected
  List<VfxModel> dco_decode_list_vfx_model(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_vfx_model).toList();
  }

  @protected
  List<VfxTexture> dco_decode_list_vfx_texture(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_vfx_texture).toList();
  }

  @protected
  List<VfxVertex> dco_decode_list_vfx_vertex(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_vfx_vertex).toList();
  }

  @protected
  List<WbtFileEntry> dco_decode_list_wbt_file_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wbt_file_entry).toList();
  }

  @protected
  List<WpdRecord> dco_decode_list_wpd_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wpd_record).toList();
  }

  @protected
  List<ZtrEntry> dco_decode_list_ztr_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ztr_entry).toList();
  }

  @protected
  List<ZtrEntryWithSource> dco_decode_list_ztr_entry_with_source(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_ztr_entry_with_source)
        .toList();
  }

  @protected
  List<ZtrFileError> dco_decode_list_ztr_file_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ztr_file_error).toList();
  }

  @protected
  List<ZtrMapEntry> dco_decode_list_ztr_map_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ztr_map_entry).toList();
  }

  @protected
  McpFile dco_decode_mcp_file(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return McpFile(
      version: dco_decode_u_32(arr[0]),
      patternCount: dco_decode_u_32(arr[1]),
      reserved: dco_decode_u_32(arr[2]),
      patterns: dco_decode_Map_String_mcp_pattern_None(arr[3]),
    );
  }

  @protected
  McpPattern dco_decode_mcp_pattern(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return McpPattern(
      name: dco_decode_String(arr[0]),
      nodes: dco_decode_list_vec_3(arr[1]),
      count: dco_decode_usize(arr[2]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  VfxMesh? dco_decode_opt_box_autoadd_vfx_mesh(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_vfx_mesh(raw);
  }

  @protected
  (ImgData, Uint8List) dco_decode_record_img_data_list_prim_u_8_strict(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_img_data(arr[0]),
      dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  ((int, int), Uint8List)
      dco_decode_record_record_u_32_u_32_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_record_u_32_u_32(arr[0]),
      dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  (String, McpPattern) dco_decode_record_string_mcp_pattern(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_mcp_pattern(arr[1]),
    );
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_String(arr[1]),
    );
  }

  @protected
  (String, WdbValue) dco_decode_record_string_wdb_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_wdb_value(arr[1]),
    );
  }

  @protected
  (int, int) dco_decode_record_u_32_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_u_32(arr[0]),
      dco_decode_u_32(arr[1]),
    );
  }

  @protected
  TargetType dco_decode_target_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TargetType.values[raw as int];
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  U32Array4 dco_decode_u_32_array_4(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U32Array4(dco_decode_list_prim_u_32_strict(raw));
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  Vec3 dco_decode_vec_3(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Vec3(
      x: dco_decode_f_32(arr[0]),
      y: dco_decode_f_32(arr[1]),
      z: dco_decode_f_32(arr[2]),
    );
  }

  @protected
  VfxAnimation dco_decode_vfx_animation(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return VfxAnimation(
      name: dco_decode_String(arr[0]),
      dataSize: dco_decode_u_32(arr[1]),
      durationFrames: dco_decode_opt_box_autoadd_u_32(arr[2]),
      keyframeCount: dco_decode_opt_box_autoadd_u_32(arr[3]),
    );
  }

  @protected
  VfxData dco_decode_vfx_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return VfxData(
      sourcePath: dco_decode_String(arr[0]),
      textures: dco_decode_list_vfx_texture(arr[1]),
      models: dco_decode_list_vfx_model(arr[2]),
      animations: dco_decode_list_vfx_animation(arr[3]),
      effects: dco_decode_list_vfx_effect(arr[4]),
    );
  }

  @protected
  VfxEffect dco_decode_vfx_effect(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return VfxEffect(
      name: dco_decode_String(arr[0]),
      dataSize: dco_decode_u_32(arr[1]),
      controllerPaths: dco_decode_list_String(arr[2]),
      modelRefs: dco_decode_list_String(arr[3]),
      textureRefs: dco_decode_list_String(arr[4]),
    );
  }

  @protected
  VfxMaterial dco_decode_vfx_material(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return VfxMaterial(
      ambientColor: dco_decode_f_32_array_4(arr[0]),
      diffuseColor: dco_decode_f_32_array_4(arr[1]),
      specularColor: dco_decode_f_32_array_4(arr[2]),
      shininess: dco_decode_f_32(arr[3]),
      fogParam: dco_decode_f_32_array_4(arr[4]),
      fogColor: dco_decode_f_32_array_4(arr[5]),
      alphaThreshold: dco_decode_f_32(arr[6]),
      blendEnabled: dco_decode_bool(arr[7]),
      alphaTestEnabled: dco_decode_bool(arr[8]),
      backFaceCulling: dco_decode_bool(arr[9]),
      depthMaskEnabled: dco_decode_bool(arr[10]),
      lightingEnabled: dco_decode_bool(arr[11]),
    );
  }

  @protected
  VfxMesh dco_decode_vfx_mesh(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return VfxMesh(
      vertices: dco_decode_list_vfx_vertex(arr[0]),
      indices: dco_decode_list_prim_u_16_strict(arr[1]),
      primitiveType: dco_decode_vfx_primitive_type(arr[2]),
    );
  }

  @protected
  VfxModel dco_decode_vfx_model(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return VfxModel(
      name: dco_decode_String(arr[0]),
      dataSize: dco_decode_u_32(arr[1]),
      vertexCount: dco_decode_opt_box_autoadd_u_32(arr[2]),
      indexCount: dco_decode_opt_box_autoadd_u_32(arr[3]),
      material: dco_decode_vfx_material(arr[4]),
      textureRefs: dco_decode_list_String(arr[5]),
      hasShader: dco_decode_bool(arr[6]),
      techniqueName: dco_decode_opt_String(arr[7]),
      mesh: dco_decode_opt_box_autoadd_vfx_mesh(arr[8]),
    );
  }

  @protected
  VfxPrimitiveType dco_decode_vfx_primitive_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VfxPrimitiveType.values[raw as int];
  }

  @protected
  VfxSummary dco_decode_vfx_summary(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return VfxSummary(
      sourcePath: dco_decode_String(arr[0]),
      textureCount: dco_decode_usize(arr[1]),
      modelCount: dco_decode_usize(arr[2]),
      animationCount: dco_decode_usize(arr[3]),
      effectCount: dco_decode_usize(arr[4]),
      totalSize: dco_decode_u_64(arr[5]),
      effectNames: dco_decode_list_String(arr[6]),
    );
  }

  @protected
  VfxTexture dco_decode_vfx_texture(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return VfxTexture(
      name: dco_decode_String(arr[0]),
      width: dco_decode_u_16(arr[1]),
      height: dco_decode_u_16(arr[2]),
      format: dco_decode_u_8(arr[3]),
      formatName: dco_decode_String(arr[4]),
      mipCount: dco_decode_u_8(arr[5]),
      imageType: dco_decode_u_8(arr[6]),
      depth: dco_decode_u_16(arr[7]),
      imgbOffset: dco_decode_u_32(arr[8]),
      imgbSize: dco_decode_u_32(arr[9]),
    );
  }

  @protected
  VfxVertex dco_decode_vfx_vertex(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return VfxVertex(
      position: dco_decode_f_32_array_3(arr[0]),
      uv: dco_decode_f_32_array_2(arr[1]),
    );
  }

  @protected
  WbtFileEntry dco_decode_wbt_file_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return WbtFileEntry(
      index: dco_decode_usize(arr[0]),
      offset: dco_decode_u_64(arr[1]),
      uncompressedSize: dco_decode_u_32(arr[2]),
      compressedSize: dco_decode_u_32(arr[3]),
      path: dco_decode_String(arr[4]),
    );
  }

  @protected
  WdbData dco_decode_wdb_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return WdbData(
      header: dco_decode_Map_String_wdb_value_None(arr[0]),
      records: dco_decode_list_Map_String_wdb_value_None(arr[1]),
    );
  }

  @protected
  WdbValue dco_decode_wdb_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return WdbValue_Int(
          dco_decode_i_32(raw[1]),
        );
      case 1:
        return WdbValue_UInt(
          dco_decode_u_32(raw[1]),
        );
      case 2:
        return WdbValue_Float(
          dco_decode_f_32(raw[1]),
        );
      case 3:
        return WdbValue_String(
          dco_decode_String(raw[1]),
        );
      case 4:
        return WdbValue_Bool(
          dco_decode_bool(raw[1]),
        );
      case 5:
        return WdbValue_IntArray(
          dco_decode_list_prim_i_32_strict(raw[1]),
        );
      case 6:
        return WdbValue_UIntArray(
          dco_decode_list_prim_u_32_strict(raw[1]),
        );
      case 7:
        return WdbValue_StringArray(
          dco_decode_list_String(raw[1]),
        );
      case 8:
        return WdbValue_CrystalRole(
          dco_decode_crystal_role(raw[1]),
        );
      case 9:
        return WdbValue_CrystalNodeType(
          dco_decode_crystal_node_type(raw[1]),
        );
      case 10:
        return WdbValue_Unknown();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  WpdData dco_decode_wpd_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return WpdData(
      records: dco_decode_list_wpd_record(arr[0]),
    );
  }

  @protected
  WpdRecord dco_decode_wpd_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return WpdRecord(
      name: dco_decode_String(arr[0]),
      extension_: dco_decode_String(arr[1]),
      data: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  ZtrData dco_decode_ztr_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ZtrData(
      entries: dco_decode_list_ztr_entry(arr[0]),
      mappings: dco_decode_list_ztr_map_entry(arr[1]),
    );
  }

  @protected
  ZtrDirectoryResult dco_decode_ztr_directory_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ZtrDirectoryResult(
      entries: dco_decode_list_ztr_entry_with_source(arr[0]),
      parsedFiles: dco_decode_list_String(arr[1]),
      failedFiles: dco_decode_list_ztr_file_error(arr[2]),
      totalFiles: dco_decode_usize(arr[3]),
    );
  }

  @protected
  ZtrEntry dco_decode_ztr_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ZtrEntry(
      id: dco_decode_String(arr[0]),
      text: dco_decode_String(arr[1]),
    );
  }

  @protected
  ZtrEntryWithSource dco_decode_ztr_entry_with_source(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ZtrEntryWithSource(
      id: dco_decode_String(arr[0]),
      text: dco_decode_String(arr[1]),
      sourceFile: dco_decode_String(arr[2]),
    );
  }

  @protected
  ZtrFileError dco_decode_ztr_file_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ZtrFileError(
      filePath: dco_decode_String(arr[0]),
      error: dco_decode_String(arr[1]),
    );
  }

  @protected
  ZtrMapEntry dco_decode_ztr_map_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ZtrMapEntry(
      key: dco_decode_String(arr[0]),
      value: dco_decode_String(arr[1]),
    );
  }

  @protected
  ZtrParseProgress dco_decode_ztr_parse_progress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ZtrParseProgress(
      totalFiles: dco_decode_usize(arr[0]),
      processedFiles: dco_decode_usize(arr[1]),
      successCount: dco_decode_usize(arr[2]),
      errorCount: dco_decode_usize(arr[3]),
      currentFile: dco_decode_String(arr[4]),
      stage: dco_decode_String(arr[5]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  Map<String, McpPattern> sse_decode_Map_String_mcp_pattern_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_mcp_pattern(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<String, WdbValue> sse_decode_Map_String_wdb_value_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_wdb_value(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  RustStreamSink<String> sse_decode_StreamSink_String_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<ZtrParseProgress> sse_decode_StreamSink_ztr_parse_progress_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  Action sse_decode_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Action.values[inner];
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  CgtFile sse_decode_box_autoadd_cgt_file(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_cgt_file(deserializer));
  }

  @protected
  McpFile sse_decode_box_autoadd_mcp_file(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_mcp_file(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  VfxMesh sse_decode_box_autoadd_vfx_mesh(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_vfx_mesh(deserializer));
  }

  @protected
  WdbData sse_decode_box_autoadd_wdb_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_wdb_data(deserializer));
  }

  @protected
  ZtrData sse_decode_box_autoadd_ztr_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ztr_data(deserializer));
  }

  @protected
  CgtFile sse_decode_cgt_file(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_version = sse_decode_u_32(deserializer);
    var var_entryCount = sse_decode_u_32(deserializer);
    var var_totalNodes = sse_decode_u_32(deserializer);
    var var_reserved = sse_decode_u_32(deserializer);
    var var_entries = sse_decode_list_crystarium_entry(deserializer);
    var var_nodes = sse_decode_list_crystarium_node(deserializer);
    return CgtFile(
        version: var_version,
        entryCount: var_entryCount,
        totalNodes: var_totalNodes,
        reserved: var_reserved,
        entries: var_entries,
        nodes: var_nodes);
  }

  @protected
  CrystalNodeType sse_decode_crystal_node_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return CrystalNodeType.values[inner];
  }

  @protected
  CrystalRole sse_decode_crystal_role(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return CrystalRole.values[inner];
  }

  @protected
  CrystariumEntry sse_decode_crystarium_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_u_32(deserializer);
    var var_patternName = sse_decode_String(deserializer);
    var var_position = sse_decode_vec_3(deserializer);
    var var_scale = sse_decode_f_32(deserializer);
    var var_rotation = sse_decode_vec_3(deserializer);
    var var_rotationW = sse_decode_f_32(deserializer);
    var var_nodeScale = sse_decode_f_32(deserializer);
    var var_roleId = sse_decode_u_8(deserializer);
    var var_stage = sse_decode_u_8(deserializer);
    var var_entryType = sse_decode_u_8(deserializer);
    var var_reserved = sse_decode_u_8(deserializer);
    var var_nodeIds = sse_decode_list_prim_u_32_strict(deserializer);
    var var_linkPosition = sse_decode_vec_3(deserializer);
    var var_linkW = sse_decode_f_32(deserializer);
    return CrystariumEntry(
        index: var_index,
        patternName: var_patternName,
        position: var_position,
        scale: var_scale,
        rotation: var_rotation,
        rotationW: var_rotationW,
        nodeScale: var_nodeScale,
        roleId: var_roleId,
        stage: var_stage,
        entryType: var_entryType,
        reserved: var_reserved,
        nodeIds: var_nodeIds,
        linkPosition: var_linkPosition,
        linkW: var_linkW);
  }

  @protected
  CrystariumNode sse_decode_crystarium_node(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_u_32(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_parentIndex = sse_decode_i_32(deserializer);
    var var_unknown = sse_decode_u_32_array_4(deserializer);
    var var_scales = sse_decode_f_32_array_4(deserializer);
    return CrystariumNode(
        index: var_index,
        name: var_name,
        parentIndex: var_parentIndex,
        unknown: var_unknown,
        scales: var_scales);
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  F32Array2 sse_decode_f_32_array_2(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_f_32_strict(deserializer);
    return F32Array2(inner);
  }

  @protected
  F32Array3 sse_decode_f_32_array_3(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_f_32_strict(deserializer);
    return F32Array3(inner);
  }

  @protected
  F32Array4 sse_decode_f_32_array_4(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_f_32_strict(deserializer);
    return F32Array4(inner);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  ImgData sse_decode_img_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_width = sse_decode_u_16(deserializer);
    var var_height = sse_decode_u_16(deserializer);
    var var_mipCount = sse_decode_u_8(deserializer);
    var var_format = sse_decode_String(deserializer);
    return ImgData(
        width: var_width,
        height: var_height,
        mipCount: var_mipCount,
        format: var_format);
  }

  @protected
  List<Map<String, WdbValue>> sse_decode_list_Map_String_wdb_value_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Map<String, WdbValue>>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_Map_String_wdb_value_None(deserializer));
    }
    return ans_;
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<CrystariumEntry> sse_decode_list_crystarium_entry(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <CrystariumEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_crystarium_entry(deserializer));
    }
    return ans_;
  }

  @protected
  List<CrystariumNode> sse_decode_list_crystarium_node(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <CrystariumNode>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_crystarium_node(deserializer));
    }
    return ans_;
  }

  @protected
  Float32List sse_decode_list_prim_f_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat32List(len_);
  }

  @protected
  Int32List sse_decode_list_prim_i_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getInt32List(len_);
  }

  @protected
  Uint16List sse_decode_list_prim_u_16_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint16List(len_);
  }

  @protected
  Uint32List sse_decode_list_prim_u_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint32List(len_);
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint64List sse_decode_list_prim_usize_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint64List(len_);
  }

  @protected
  List<(String, McpPattern)> sse_decode_list_record_string_mcp_pattern(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, McpPattern)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_mcp_pattern(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, WdbValue)> sse_decode_list_record_string_wdb_value(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, WdbValue)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_wdb_value(deserializer));
    }
    return ans_;
  }

  @protected
  List<Vec3> sse_decode_list_vec_3(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Vec3>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_vec_3(deserializer));
    }
    return ans_;
  }

  @protected
  List<VfxAnimation> sse_decode_list_vfx_animation(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <VfxAnimation>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_vfx_animation(deserializer));
    }
    return ans_;
  }

  @protected
  List<VfxEffect> sse_decode_list_vfx_effect(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <VfxEffect>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_vfx_effect(deserializer));
    }
    return ans_;
  }

  @protected
  List<VfxModel> sse_decode_list_vfx_model(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <VfxModel>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_vfx_model(deserializer));
    }
    return ans_;
  }

  @protected
  List<VfxTexture> sse_decode_list_vfx_texture(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <VfxTexture>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_vfx_texture(deserializer));
    }
    return ans_;
  }

  @protected
  List<VfxVertex> sse_decode_list_vfx_vertex(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <VfxVertex>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_vfx_vertex(deserializer));
    }
    return ans_;
  }

  @protected
  List<WbtFileEntry> sse_decode_list_wbt_file_entry(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WbtFileEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wbt_file_entry(deserializer));
    }
    return ans_;
  }

  @protected
  List<WpdRecord> sse_decode_list_wpd_record(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WpdRecord>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wpd_record(deserializer));
    }
    return ans_;
  }

  @protected
  List<ZtrEntry> sse_decode_list_ztr_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ZtrEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ztr_entry(deserializer));
    }
    return ans_;
  }

  @protected
  List<ZtrEntryWithSource> sse_decode_list_ztr_entry_with_source(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ZtrEntryWithSource>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ztr_entry_with_source(deserializer));
    }
    return ans_;
  }

  @protected
  List<ZtrFileError> sse_decode_list_ztr_file_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ZtrFileError>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ztr_file_error(deserializer));
    }
    return ans_;
  }

  @protected
  List<ZtrMapEntry> sse_decode_list_ztr_map_entry(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ZtrMapEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ztr_map_entry(deserializer));
    }
    return ans_;
  }

  @protected
  McpFile sse_decode_mcp_file(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_version = sse_decode_u_32(deserializer);
    var var_patternCount = sse_decode_u_32(deserializer);
    var var_reserved = sse_decode_u_32(deserializer);
    var var_patterns = sse_decode_Map_String_mcp_pattern_None(deserializer);
    return McpFile(
        version: var_version,
        patternCount: var_patternCount,
        reserved: var_reserved,
        patterns: var_patterns);
  }

  @protected
  McpPattern sse_decode_mcp_pattern(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_nodes = sse_decode_list_vec_3(deserializer);
    var var_count = sse_decode_usize(deserializer);
    return McpPattern(name: var_name, nodes: var_nodes, count: var_count);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  VfxMesh? sse_decode_opt_box_autoadd_vfx_mesh(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_vfx_mesh(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (ImgData, Uint8List) sse_decode_record_img_data_list_prim_u_8_strict(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_img_data(deserializer);
    var var_field1 = sse_decode_list_prim_u_8_strict(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  ((int, int), Uint8List)
      sse_decode_record_record_u_32_u_32_list_prim_u_8_strict(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_record_u_32_u_32(deserializer);
    var var_field1 = sse_decode_list_prim_u_8_strict(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, McpPattern) sse_decode_record_string_mcp_pattern(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_mcp_pattern(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, String) sse_decode_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, WdbValue) sse_decode_record_string_wdb_value(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_wdb_value(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (int, int) sse_decode_record_u_32_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_32(deserializer);
    var var_field1 = sse_decode_u_32(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  TargetType sse_decode_target_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return TargetType.values[inner];
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  U32Array4 sse_decode_u_32_array_4(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_32_strict(deserializer);
    return U32Array4(inner);
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  Vec3 sse_decode_vec_3(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_x = sse_decode_f_32(deserializer);
    var var_y = sse_decode_f_32(deserializer);
    var var_z = sse_decode_f_32(deserializer);
    return Vec3(x: var_x, y: var_y, z: var_z);
  }

  @protected
  VfxAnimation sse_decode_vfx_animation(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_dataSize = sse_decode_u_32(deserializer);
    var var_durationFrames = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_keyframeCount = sse_decode_opt_box_autoadd_u_32(deserializer);
    return VfxAnimation(
        name: var_name,
        dataSize: var_dataSize,
        durationFrames: var_durationFrames,
        keyframeCount: var_keyframeCount);
  }

  @protected
  VfxData sse_decode_vfx_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sourcePath = sse_decode_String(deserializer);
    var var_textures = sse_decode_list_vfx_texture(deserializer);
    var var_models = sse_decode_list_vfx_model(deserializer);
    var var_animations = sse_decode_list_vfx_animation(deserializer);
    var var_effects = sse_decode_list_vfx_effect(deserializer);
    return VfxData(
        sourcePath: var_sourcePath,
        textures: var_textures,
        models: var_models,
        animations: var_animations,
        effects: var_effects);
  }

  @protected
  VfxEffect sse_decode_vfx_effect(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_dataSize = sse_decode_u_32(deserializer);
    var var_controllerPaths = sse_decode_list_String(deserializer);
    var var_modelRefs = sse_decode_list_String(deserializer);
    var var_textureRefs = sse_decode_list_String(deserializer);
    return VfxEffect(
        name: var_name,
        dataSize: var_dataSize,
        controllerPaths: var_controllerPaths,
        modelRefs: var_modelRefs,
        textureRefs: var_textureRefs);
  }

  @protected
  VfxMaterial sse_decode_vfx_material(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ambientColor = sse_decode_f_32_array_4(deserializer);
    var var_diffuseColor = sse_decode_f_32_array_4(deserializer);
    var var_specularColor = sse_decode_f_32_array_4(deserializer);
    var var_shininess = sse_decode_f_32(deserializer);
    var var_fogParam = sse_decode_f_32_array_4(deserializer);
    var var_fogColor = sse_decode_f_32_array_4(deserializer);
    var var_alphaThreshold = sse_decode_f_32(deserializer);
    var var_blendEnabled = sse_decode_bool(deserializer);
    var var_alphaTestEnabled = sse_decode_bool(deserializer);
    var var_backFaceCulling = sse_decode_bool(deserializer);
    var var_depthMaskEnabled = sse_decode_bool(deserializer);
    var var_lightingEnabled = sse_decode_bool(deserializer);
    return VfxMaterial(
        ambientColor: var_ambientColor,
        diffuseColor: var_diffuseColor,
        specularColor: var_specularColor,
        shininess: var_shininess,
        fogParam: var_fogParam,
        fogColor: var_fogColor,
        alphaThreshold: var_alphaThreshold,
        blendEnabled: var_blendEnabled,
        alphaTestEnabled: var_alphaTestEnabled,
        backFaceCulling: var_backFaceCulling,
        depthMaskEnabled: var_depthMaskEnabled,
        lightingEnabled: var_lightingEnabled);
  }

  @protected
  VfxMesh sse_decode_vfx_mesh(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_vertices = sse_decode_list_vfx_vertex(deserializer);
    var var_indices = sse_decode_list_prim_u_16_strict(deserializer);
    var var_primitiveType = sse_decode_vfx_primitive_type(deserializer);
    return VfxMesh(
        vertices: var_vertices,
        indices: var_indices,
        primitiveType: var_primitiveType);
  }

  @protected
  VfxModel sse_decode_vfx_model(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_dataSize = sse_decode_u_32(deserializer);
    var var_vertexCount = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_indexCount = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_material = sse_decode_vfx_material(deserializer);
    var var_textureRefs = sse_decode_list_String(deserializer);
    var var_hasShader = sse_decode_bool(deserializer);
    var var_techniqueName = sse_decode_opt_String(deserializer);
    var var_mesh = sse_decode_opt_box_autoadd_vfx_mesh(deserializer);
    return VfxModel(
        name: var_name,
        dataSize: var_dataSize,
        vertexCount: var_vertexCount,
        indexCount: var_indexCount,
        material: var_material,
        textureRefs: var_textureRefs,
        hasShader: var_hasShader,
        techniqueName: var_techniqueName,
        mesh: var_mesh);
  }

  @protected
  VfxPrimitiveType sse_decode_vfx_primitive_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return VfxPrimitiveType.values[inner];
  }

  @protected
  VfxSummary sse_decode_vfx_summary(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sourcePath = sse_decode_String(deserializer);
    var var_textureCount = sse_decode_usize(deserializer);
    var var_modelCount = sse_decode_usize(deserializer);
    var var_animationCount = sse_decode_usize(deserializer);
    var var_effectCount = sse_decode_usize(deserializer);
    var var_totalSize = sse_decode_u_64(deserializer);
    var var_effectNames = sse_decode_list_String(deserializer);
    return VfxSummary(
        sourcePath: var_sourcePath,
        textureCount: var_textureCount,
        modelCount: var_modelCount,
        animationCount: var_animationCount,
        effectCount: var_effectCount,
        totalSize: var_totalSize,
        effectNames: var_effectNames);
  }

  @protected
  VfxTexture sse_decode_vfx_texture(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_width = sse_decode_u_16(deserializer);
    var var_height = sse_decode_u_16(deserializer);
    var var_format = sse_decode_u_8(deserializer);
    var var_formatName = sse_decode_String(deserializer);
    var var_mipCount = sse_decode_u_8(deserializer);
    var var_imageType = sse_decode_u_8(deserializer);
    var var_depth = sse_decode_u_16(deserializer);
    var var_imgbOffset = sse_decode_u_32(deserializer);
    var var_imgbSize = sse_decode_u_32(deserializer);
    return VfxTexture(
        name: var_name,
        width: var_width,
        height: var_height,
        format: var_format,
        formatName: var_formatName,
        mipCount: var_mipCount,
        imageType: var_imageType,
        depth: var_depth,
        imgbOffset: var_imgbOffset,
        imgbSize: var_imgbSize);
  }

  @protected
  VfxVertex sse_decode_vfx_vertex(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_position = sse_decode_f_32_array_3(deserializer);
    var var_uv = sse_decode_f_32_array_2(deserializer);
    return VfxVertex(position: var_position, uv: var_uv);
  }

  @protected
  WbtFileEntry sse_decode_wbt_file_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_usize(deserializer);
    var var_offset = sse_decode_u_64(deserializer);
    var var_uncompressedSize = sse_decode_u_32(deserializer);
    var var_compressedSize = sse_decode_u_32(deserializer);
    var var_path = sse_decode_String(deserializer);
    return WbtFileEntry(
        index: var_index,
        offset: var_offset,
        uncompressedSize: var_uncompressedSize,
        compressedSize: var_compressedSize,
        path: var_path);
  }

  @protected
  WdbData sse_decode_wdb_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_header = sse_decode_Map_String_wdb_value_None(deserializer);
    var var_records = sse_decode_list_Map_String_wdb_value_None(deserializer);
    return WdbData(header: var_header, records: var_records);
  }

  @protected
  WdbValue sse_decode_wdb_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_i_32(deserializer);
        return WdbValue_Int(var_field0);
      case 1:
        var var_field0 = sse_decode_u_32(deserializer);
        return WdbValue_UInt(var_field0);
      case 2:
        var var_field0 = sse_decode_f_32(deserializer);
        return WdbValue_Float(var_field0);
      case 3:
        var var_field0 = sse_decode_String(deserializer);
        return WdbValue_String(var_field0);
      case 4:
        var var_field0 = sse_decode_bool(deserializer);
        return WdbValue_Bool(var_field0);
      case 5:
        var var_field0 = sse_decode_list_prim_i_32_strict(deserializer);
        return WdbValue_IntArray(var_field0);
      case 6:
        var var_field0 = sse_decode_list_prim_u_32_strict(deserializer);
        return WdbValue_UIntArray(var_field0);
      case 7:
        var var_field0 = sse_decode_list_String(deserializer);
        return WdbValue_StringArray(var_field0);
      case 8:
        var var_field0 = sse_decode_crystal_role(deserializer);
        return WdbValue_CrystalRole(var_field0);
      case 9:
        var var_field0 = sse_decode_crystal_node_type(deserializer);
        return WdbValue_CrystalNodeType(var_field0);
      case 10:
        return WdbValue_Unknown();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  WpdData sse_decode_wpd_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_records = sse_decode_list_wpd_record(deserializer);
    return WpdData(records: var_records);
  }

  @protected
  WpdRecord sse_decode_wpd_record(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_extension_ = sse_decode_String(deserializer);
    var var_data = sse_decode_list_prim_u_8_strict(deserializer);
    return WpdRecord(
        name: var_name, extension_: var_extension_, data: var_data);
  }

  @protected
  ZtrData sse_decode_ztr_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_entries = sse_decode_list_ztr_entry(deserializer);
    var var_mappings = sse_decode_list_ztr_map_entry(deserializer);
    return ZtrData(entries: var_entries, mappings: var_mappings);
  }

  @protected
  ZtrDirectoryResult sse_decode_ztr_directory_result(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_entries = sse_decode_list_ztr_entry_with_source(deserializer);
    var var_parsedFiles = sse_decode_list_String(deserializer);
    var var_failedFiles = sse_decode_list_ztr_file_error(deserializer);
    var var_totalFiles = sse_decode_usize(deserializer);
    return ZtrDirectoryResult(
        entries: var_entries,
        parsedFiles: var_parsedFiles,
        failedFiles: var_failedFiles,
        totalFiles: var_totalFiles);
  }

  @protected
  ZtrEntry sse_decode_ztr_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_text = sse_decode_String(deserializer);
    return ZtrEntry(id: var_id, text: var_text);
  }

  @protected
  ZtrEntryWithSource sse_decode_ztr_entry_with_source(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_text = sse_decode_String(deserializer);
    var var_sourceFile = sse_decode_String(deserializer);
    return ZtrEntryWithSource(
        id: var_id, text: var_text, sourceFile: var_sourceFile);
  }

  @protected
  ZtrFileError sse_decode_ztr_file_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_filePath = sse_decode_String(deserializer);
    var var_error = sse_decode_String(deserializer);
    return ZtrFileError(filePath: var_filePath, error: var_error);
  }

  @protected
  ZtrMapEntry sse_decode_ztr_map_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_key = sse_decode_String(deserializer);
    var var_value = sse_decode_String(deserializer);
    return ZtrMapEntry(key: var_key, value: var_value);
  }

  @protected
  ZtrParseProgress sse_decode_ztr_parse_progress(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_totalFiles = sse_decode_usize(deserializer);
    var var_processedFiles = sse_decode_usize(deserializer);
    var var_successCount = sse_decode_usize(deserializer);
    var var_errorCount = sse_decode_usize(deserializer);
    var var_currentFile = sse_decode_String(deserializer);
    var var_stage = sse_decode_String(deserializer);
    return ZtrParseProgress(
        totalFiles: var_totalFiles,
        processedFiles: var_processedFiles,
        successCount: var_successCount,
        errorCount: var_errorCount,
        currentFile: var_currentFile,
        stage: var_stage);
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_Map_String_mcp_pattern_None(
      Map<String, McpPattern> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_mcp_pattern(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_Map_String_wdb_value_None(
      Map<String, WdbValue> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_wdb_value(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_StreamSink_String_Sse(
      RustStreamSink<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_ztr_parse_progress_Sse(
      RustStreamSink<ZtrParseProgress> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_ztr_parse_progress,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_action(Action self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_cgt_file(CgtFile self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_cgt_file(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_mcp_file(McpFile self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_mcp_file(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_vfx_mesh(VfxMesh self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_vfx_mesh(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_wdb_data(WdbData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_wdb_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ztr_data(ZtrData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ztr_data(self, serializer);
  }

  @protected
  void sse_encode_cgt_file(CgtFile self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.version, serializer);
    sse_encode_u_32(self.entryCount, serializer);
    sse_encode_u_32(self.totalNodes, serializer);
    sse_encode_u_32(self.reserved, serializer);
    sse_encode_list_crystarium_entry(self.entries, serializer);
    sse_encode_list_crystarium_node(self.nodes, serializer);
  }

  @protected
  void sse_encode_crystal_node_type(
      CrystalNodeType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_crystal_role(CrystalRole self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_crystarium_entry(
      CrystariumEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.index, serializer);
    sse_encode_String(self.patternName, serializer);
    sse_encode_vec_3(self.position, serializer);
    sse_encode_f_32(self.scale, serializer);
    sse_encode_vec_3(self.rotation, serializer);
    sse_encode_f_32(self.rotationW, serializer);
    sse_encode_f_32(self.nodeScale, serializer);
    sse_encode_u_8(self.roleId, serializer);
    sse_encode_u_8(self.stage, serializer);
    sse_encode_u_8(self.entryType, serializer);
    sse_encode_u_8(self.reserved, serializer);
    sse_encode_list_prim_u_32_strict(self.nodeIds, serializer);
    sse_encode_vec_3(self.linkPosition, serializer);
    sse_encode_f_32(self.linkW, serializer);
  }

  @protected
  void sse_encode_crystarium_node(
      CrystariumNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.index, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_i_32(self.parentIndex, serializer);
    sse_encode_u_32_array_4(self.unknown, serializer);
    sse_encode_f_32_array_4(self.scales, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_f_32_array_2(F32Array2 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_f_32_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_f_32_array_3(F32Array3 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_f_32_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_f_32_array_4(F32Array4 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_f_32_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_img_data(ImgData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self.width, serializer);
    sse_encode_u_16(self.height, serializer);
    sse_encode_u_8(self.mipCount, serializer);
    sse_encode_String(self.format, serializer);
  }

  @protected
  void sse_encode_list_Map_String_wdb_value_None(
      List<Map<String, WdbValue>> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Map_String_wdb_value_None(item, serializer);
    }
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_crystarium_entry(
      List<CrystariumEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_crystarium_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_list_crystarium_node(
      List<CrystariumNode> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_crystarium_node(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_f_32_strict(
      Float32List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat32List(self);
  }

  @protected
  void sse_encode_list_prim_i_32_strict(
      Int32List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putInt32List(self);
  }

  @protected
  void sse_encode_list_prim_u_16_strict(
      Uint16List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint16List(self);
  }

  @protected
  void sse_encode_list_prim_u_32_strict(
      Uint32List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint32List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_prim_usize_strict(
      Uint64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint64List(self);
  }

  @protected
  void sse_encode_list_record_string_mcp_pattern(
      List<(String, McpPattern)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_mcp_pattern(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_string(
      List<(String, String)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_wdb_value(
      List<(String, WdbValue)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_wdb_value(item, serializer);
    }
  }

  @protected
  void sse_encode_list_vec_3(List<Vec3> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_vec_3(item, serializer);
    }
  }

  @protected
  void sse_encode_list_vfx_animation(
      List<VfxAnimation> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_vfx_animation(item, serializer);
    }
  }

  @protected
  void sse_encode_list_vfx_effect(
      List<VfxEffect> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_vfx_effect(item, serializer);
    }
  }

  @protected
  void sse_encode_list_vfx_model(
      List<VfxModel> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_vfx_model(item, serializer);
    }
  }

  @protected
  void sse_encode_list_vfx_texture(
      List<VfxTexture> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_vfx_texture(item, serializer);
    }
  }

  @protected
  void sse_encode_list_vfx_vertex(
      List<VfxVertex> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_vfx_vertex(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wbt_file_entry(
      List<WbtFileEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wbt_file_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wpd_record(
      List<WpdRecord> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wpd_record(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ztr_entry(
      List<ZtrEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ztr_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ztr_entry_with_source(
      List<ZtrEntryWithSource> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ztr_entry_with_source(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ztr_file_error(
      List<ZtrFileError> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ztr_file_error(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ztr_map_entry(
      List<ZtrMapEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ztr_map_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_mcp_file(McpFile self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.version, serializer);
    sse_encode_u_32(self.patternCount, serializer);
    sse_encode_u_32(self.reserved, serializer);
    sse_encode_Map_String_mcp_pattern_None(self.patterns, serializer);
  }

  @protected
  void sse_encode_mcp_pattern(McpPattern self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_list_vec_3(self.nodes, serializer);
    sse_encode_usize(self.count, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_vfx_mesh(
      VfxMesh? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_vfx_mesh(self, serializer);
    }
  }

  @protected
  void sse_encode_record_img_data_list_prim_u_8_strict(
      (ImgData, Uint8List) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_img_data(self.$1, serializer);
    sse_encode_list_prim_u_8_strict(self.$2, serializer);
  }

  @protected
  void sse_encode_record_record_u_32_u_32_list_prim_u_8_strict(
      ((int, int), Uint8List) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_record_u_32_u_32(self.$1, serializer);
    sse_encode_list_prim_u_8_strict(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_mcp_pattern(
      (String, McpPattern) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_mcp_pattern(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_string(
      (String, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_wdb_value(
      (String, WdbValue) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_wdb_value(self.$2, serializer);
  }

  @protected
  void sse_encode_record_u_32_u_32((int, int) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.$1, serializer);
    sse_encode_u_32(self.$2, serializer);
  }

  @protected
  void sse_encode_target_type(TargetType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_32_array_4(U32Array4 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_32_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_vec_3(Vec3 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self.x, serializer);
    sse_encode_f_32(self.y, serializer);
    sse_encode_f_32(self.z, serializer);
  }

  @protected
  void sse_encode_vfx_animation(VfxAnimation self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_u_32(self.dataSize, serializer);
    sse_encode_opt_box_autoadd_u_32(self.durationFrames, serializer);
    sse_encode_opt_box_autoadd_u_32(self.keyframeCount, serializer);
  }

  @protected
  void sse_encode_vfx_data(VfxData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.sourcePath, serializer);
    sse_encode_list_vfx_texture(self.textures, serializer);
    sse_encode_list_vfx_model(self.models, serializer);
    sse_encode_list_vfx_animation(self.animations, serializer);
    sse_encode_list_vfx_effect(self.effects, serializer);
  }

  @protected
  void sse_encode_vfx_effect(VfxEffect self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_u_32(self.dataSize, serializer);
    sse_encode_list_String(self.controllerPaths, serializer);
    sse_encode_list_String(self.modelRefs, serializer);
    sse_encode_list_String(self.textureRefs, serializer);
  }

  @protected
  void sse_encode_vfx_material(VfxMaterial self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32_array_4(self.ambientColor, serializer);
    sse_encode_f_32_array_4(self.diffuseColor, serializer);
    sse_encode_f_32_array_4(self.specularColor, serializer);
    sse_encode_f_32(self.shininess, serializer);
    sse_encode_f_32_array_4(self.fogParam, serializer);
    sse_encode_f_32_array_4(self.fogColor, serializer);
    sse_encode_f_32(self.alphaThreshold, serializer);
    sse_encode_bool(self.blendEnabled, serializer);
    sse_encode_bool(self.alphaTestEnabled, serializer);
    sse_encode_bool(self.backFaceCulling, serializer);
    sse_encode_bool(self.depthMaskEnabled, serializer);
    sse_encode_bool(self.lightingEnabled, serializer);
  }

  @protected
  void sse_encode_vfx_mesh(VfxMesh self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_vfx_vertex(self.vertices, serializer);
    sse_encode_list_prim_u_16_strict(self.indices, serializer);
    sse_encode_vfx_primitive_type(self.primitiveType, serializer);
  }

  @protected
  void sse_encode_vfx_model(VfxModel self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_u_32(self.dataSize, serializer);
    sse_encode_opt_box_autoadd_u_32(self.vertexCount, serializer);
    sse_encode_opt_box_autoadd_u_32(self.indexCount, serializer);
    sse_encode_vfx_material(self.material, serializer);
    sse_encode_list_String(self.textureRefs, serializer);
    sse_encode_bool(self.hasShader, serializer);
    sse_encode_opt_String(self.techniqueName, serializer);
    sse_encode_opt_box_autoadd_vfx_mesh(self.mesh, serializer);
  }

  @protected
  void sse_encode_vfx_primitive_type(
      VfxPrimitiveType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_vfx_summary(VfxSummary self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.sourcePath, serializer);
    sse_encode_usize(self.textureCount, serializer);
    sse_encode_usize(self.modelCount, serializer);
    sse_encode_usize(self.animationCount, serializer);
    sse_encode_usize(self.effectCount, serializer);
    sse_encode_u_64(self.totalSize, serializer);
    sse_encode_list_String(self.effectNames, serializer);
  }

  @protected
  void sse_encode_vfx_texture(VfxTexture self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_u_16(self.width, serializer);
    sse_encode_u_16(self.height, serializer);
    sse_encode_u_8(self.format, serializer);
    sse_encode_String(self.formatName, serializer);
    sse_encode_u_8(self.mipCount, serializer);
    sse_encode_u_8(self.imageType, serializer);
    sse_encode_u_16(self.depth, serializer);
    sse_encode_u_32(self.imgbOffset, serializer);
    sse_encode_u_32(self.imgbSize, serializer);
  }

  @protected
  void sse_encode_vfx_vertex(VfxVertex self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32_array_3(self.position, serializer);
    sse_encode_f_32_array_2(self.uv, serializer);
  }

  @protected
  void sse_encode_wbt_file_entry(WbtFileEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.index, serializer);
    sse_encode_u_64(self.offset, serializer);
    sse_encode_u_32(self.uncompressedSize, serializer);
    sse_encode_u_32(self.compressedSize, serializer);
    sse_encode_String(self.path, serializer);
  }

  @protected
  void sse_encode_wdb_data(WdbData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Map_String_wdb_value_None(self.header, serializer);
    sse_encode_list_Map_String_wdb_value_None(self.records, serializer);
  }

  @protected
  void sse_encode_wdb_value(WdbValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case WdbValue_Int(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_i_32(field0, serializer);
      case WdbValue_UInt(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_32(field0, serializer);
      case WdbValue_Float(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_f_32(field0, serializer);
      case WdbValue_String(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_String(field0, serializer);
      case WdbValue_Bool(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_bool(field0, serializer);
      case WdbValue_IntArray(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_list_prim_i_32_strict(field0, serializer);
      case WdbValue_UIntArray(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_list_prim_u_32_strict(field0, serializer);
      case WdbValue_StringArray(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_list_String(field0, serializer);
      case WdbValue_CrystalRole(field0: final field0):
        sse_encode_i_32(8, serializer);
        sse_encode_crystal_role(field0, serializer);
      case WdbValue_CrystalNodeType(field0: final field0):
        sse_encode_i_32(9, serializer);
        sse_encode_crystal_node_type(field0, serializer);
      case WdbValue_Unknown():
        sse_encode_i_32(10, serializer);
    }
  }

  @protected
  void sse_encode_wpd_data(WpdData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_wpd_record(self.records, serializer);
  }

  @protected
  void sse_encode_wpd_record(WpdRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.extension_, serializer);
    sse_encode_list_prim_u_8_strict(self.data, serializer);
  }

  @protected
  void sse_encode_ztr_data(ZtrData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_ztr_entry(self.entries, serializer);
    sse_encode_list_ztr_map_entry(self.mappings, serializer);
  }

  @protected
  void sse_encode_ztr_directory_result(
      ZtrDirectoryResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_ztr_entry_with_source(self.entries, serializer);
    sse_encode_list_String(self.parsedFiles, serializer);
    sse_encode_list_ztr_file_error(self.failedFiles, serializer);
    sse_encode_usize(self.totalFiles, serializer);
  }

  @protected
  void sse_encode_ztr_entry(ZtrEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.text, serializer);
  }

  @protected
  void sse_encode_ztr_entry_with_source(
      ZtrEntryWithSource self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.text, serializer);
    sse_encode_String(self.sourceFile, serializer);
  }

  @protected
  void sse_encode_ztr_file_error(ZtrFileError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.filePath, serializer);
    sse_encode_String(self.error, serializer);
  }

  @protected
  void sse_encode_ztr_map_entry(ZtrMapEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.key, serializer);
    sse_encode_String(self.value, serializer);
  }

  @protected
  void sse_encode_ztr_parse_progress(
      ZtrParseProgress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.totalFiles, serializer);
    sse_encode_usize(self.processedFiles, serializer);
    sse_encode_usize(self.successCount, serializer);
    sse_encode_usize(self.errorCount, serializer);
    sse_encode_String(self.currentFile, serializer);
    sse_encode_String(self.stage, serializer);
  }
}

// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'lib.dart';
import 'modules/crystalium/structs.dart';
import 'modules/event/structs.dart';
import 'modules/img/structs.dart';
import 'modules/scd/structs.dart';
import 'modules/vfx/structs.dart';
import 'modules/wct.dart';
import 'modules/wdb/enums.dart';
import 'modules/wdb/structs.dart';
import 'modules/wpd/structs.dart';
import 'modules/ztr/structs.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `determine_wdb_game_code`, `map_game_code`

/// Creates a log stream using StreamSink (original pattern).
/// NOTE: This may not work well with hot restart. Prefer using fetch_logs() instead.
Stream<String> createLogStream() =>
    RustLib.instance.api.crateApiCreateLogStream();

Future<void> initApp() => RustLib.instance.api.crateApiInitApp();

/// Sets the log level for the Rust logger.
///
/// # Arguments
/// * `level` - Log level (0=Off, 1=Error, 2=Warn, 3=Info, 4=Debug, 5=Trace)
Future<void> setLogLevel({required int level}) =>
    RustLib.instance.api.crateApiSetLogLevel(level: level);

/// Gets the current log level.
///
/// # Returns
/// Log level as integer (0=Off, 1=Error, 2=Warn, 3=Info, 4=Debug, 5=Trace)
Future<int> getLogLevel() => RustLib.instance.api.crateApiGetLogLevel();

Future<void> testLog({required String message}) =>
    RustLib.instance.api.crateApiTestLog(message: message);

/// Clears the log callback to prevent dangling references on hot reload.
/// Call this before reinitializing the Dart side.
Future<void> clearLogCallback() =>
    RustLib.instance.api.crateApiClearLogCallback();

/// Fetches all new logs since the last fetch.
/// This is safe to call after hot restart - the Rust log buffer survives.
/// Returns an empty vector if no new logs are available.
Future<List<String>> fetchLogs() => RustLib.instance.api.crateApiFetchLogs();

/// Gets all logs currently in the buffer.
/// Use this on initialization to get historical logs.
Future<List<String>> getAllBufferedLogs() =>
    RustLib.instance.api.crateApiGetAllBufferedLogs();

/// Resets the log read index so the next fetch_logs() returns all buffered logs.
/// Call this after hot restart to ensure you don't miss logs.
Future<void> resetLogReadIndex() =>
    RustLib.instance.api.crateApiResetLogReadIndex();

/// Extracts ZTR file to a text file.
///
/// # Arguments
/// * `in_file` - Path to the source .ztr file.
/// * `out_file` - Path to the destination .txt file.
/// * `game_code` - Game version (0: FF13, 1: FF13-2, 2: LR).
Future<void> ztrExtractToText(
        {required String inFile,
        required String outFile,
        required int gameCode}) =>
    RustLib.instance.api.crateApiZtrExtractToText(
        inFile: inFile, outFile: outFile, gameCode: gameCode);

/// Parses ZTR file into memory structure.
Future<ZtrData> ztrParse({required String inFile, required int gameCode}) =>
    RustLib.instance.api.crateApiZtrParse(inFile: inFile, gameCode: gameCode);

/// Parses ZTR from memory buffer into memory structure.
Future<ZtrData> ztrParseFromMemory(
        {required List<int> data, required int gameCode}) =>
    RustLib.instance.api
        .crateApiZtrParseFromMemory(data: data, gameCode: gameCode);

/// Packs in-memory entries (ID, Text) into a ZTR file.
Future<void> ztrPackFromData(
        {required List<(String, String)> entries,
        required String outFile,
        required int gameCode}) =>
    RustLib.instance.api.crateApiZtrPackFromData(
        entries: entries, outFile: outFile, gameCode: gameCode);

/// Packs ZtrData structure into a ZTR file.
Future<void> ztrPackFromStruct(
        {required ZtrData data,
        required String outFile,
        required int gameCode}) =>
    RustLib.instance.api.crateApiZtrPackFromStruct(
        data: data, outFile: outFile, gameCode: gameCode);

/// Converts memory structure to formatted text string.
Future<String> ztrToTextString({required ZtrData data}) =>
    RustLib.instance.api.crateApiZtrToTextString(data: data);

/// Parses all ZTR files in a directory recursively with progress streaming.
///
/// # Arguments
/// * `dir_path` - Path to the directory to scan recursively.
/// * `game_code` - Game version (0: FF13, 1: FF13-2, 2: LR).
/// * `progress_sink` - StreamSink for progress updates.
///
/// # Returns
/// A `ZtrDirectoryResult` containing all parsed entries and error information.
Stream<ZtrParseProgress> ztrParseDirectory(
        {required String dirPath, required int gameCode}) =>
    RustLib.instance.api
        .crateApiZtrParseDirectory(dirPath: dirPath, gameCode: gameCode);

/// Parses all ZTR files in a directory recursively (simple version without progress).
///
/// # Arguments
/// * `dir_path` - Path to the directory to scan recursively.
/// * `game_code` - Game version (0: FF13, 1: FF13-2, 2: LR).
///
/// # Returns
/// A `ZtrDirectoryResult` containing all parsed entries and error information.
Future<ZtrDirectoryResult> ztrParseDirectorySimple(
        {required String dirPath, required int gameCode}) =>
    RustLib.instance.api
        .crateApiZtrParseDirectorySimple(dirPath: dirPath, gameCode: gameCode);

/// Extracts all files from a WhiteBinTools archive.
///
/// # Arguments
/// * `filelist_path` - Path to the filelistu.win32.bin file.
/// * `container_path` - Path to the white_imgu.win32.bin file.
/// * `out_dir` - Directory where files will be extracted.
/// * `game_code` - Game version (0: FF13, 1: FF13-2, 2: LR).
Future<void> wbtExtract(
        {required String filelistPath,
        required String containerPath,
        required String outDir,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtExtract(
        filelistPath: filelistPath,
        containerPath: containerPath,
        outDir: outDir,
        gameCode: gameCode);

/// Repacks files from a directory into a WhiteBinTools archive.
Future<void> wbtRepack(
        {required String filelistPath,
        required String containerPath,
        required String extractedDir,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtRepack(
        filelistPath: filelistPath,
        containerPath: containerPath,
        extractedDir: extractedDir,
        gameCode: gameCode);

/// Repacks a single file into a WhiteBinTools archive.
Future<void> wbtRepackSingle(
        {required String filelistPath,
        required String containerPath,
        required String targetPathInArchive,
        required String fileToInject,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtRepackSingle(
        filelistPath: filelistPath,
        containerPath: containerPath,
        targetPathInArchive: targetPathInArchive,
        fileToInject: fileToInject,
        gameCode: gameCode);

/// Repacks multiple files into a WhiteBinTools archive.
Future<void> wbtRepackMultiple(
        {required String filelistPath,
        required String containerPath,
        required List<(String, String)> filesToPatch,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtRepackMultiple(
        filelistPath: filelistPath,
        containerPath: containerPath,
        filesToPatch: filesToPatch,
        gameCode: gameCode);

/// Returns the file list metadata from a WBT archive.
/// Use this to display a file tree in Flutter without extracting files.
Future<List<WbtFileEntry>> wbtGetFileList(
        {required String filelistPath, required int gameCode}) =>
    RustLib.instance.api
        .crateApiWbtGetFileList(filelistPath: filelistPath, gameCode: gameCode);

/// Extracts a single file from the WBT archive by its virtual path.
Future<void> wbtExtractSingleFile(
        {required String filelistPath,
        required String containerPath,
        required String virtualPath,
        required String outputPath,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtExtractSingleFile(
        filelistPath: filelistPath,
        containerPath: containerPath,
        virtualPath: virtualPath,
        outputPath: outputPath,
        gameCode: gameCode);

/// Extracts a single file from the WBT archive by its index.
Future<void> wbtExtractFileByIndex(
        {required String filelistPath,
        required String containerPath,
        required BigInt fileIndex,
        required String outputDir,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtExtractFileByIndex(
        filelistPath: filelistPath,
        containerPath: containerPath,
        fileIndex: fileIndex,
        outputDir: outputDir,
        gameCode: gameCode);

/// Extracts all files matching a virtual directory prefix.
/// Returns the number of files extracted.
Future<BigInt> wbtExtractDirectory(
        {required String filelistPath,
        required String containerPath,
        required String dirPrefix,
        required String outputDir,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtExtractDirectory(
        filelistPath: filelistPath,
        containerPath: containerPath,
        dirPrefix: dirPrefix,
        outputDir: outputDir,
        gameCode: gameCode);

/// Extracts multiple files by their indices.
/// Returns the number of files extracted.
Future<BigInt> wbtExtractFilesByIndices(
        {required String filelistPath,
        required String containerPath,
        required Uint64List indices,
        required String outputDir,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtExtractFilesByIndices(
        filelistPath: filelistPath,
        containerPath: containerPath,
        indices: indices,
        outputDir: outputDir,
        gameCode: gameCode);

/// Unpacks WPD archive to a directory. Returns the WpdData structure.
Future<WpdData> wpdUnpack({required String inFile, required String outDir}) =>
    RustLib.instance.api.crateApiWpdUnpack(inFile: inFile, outDir: outDir);

/// Repacks directory into a WPD archive.
Future<void> wpdRepack({required String inDir, required String outFile}) =>
    RustLib.instance.api.crateApiWpdRepack(inDir: inDir, outFile: outFile);

/// Performs encryption/decryption on supported files (FileList or CLB).
///
/// # Arguments
/// * `target` - Target file type (0: FileList, 1: CLB).
/// * `action` - Crypt action (0: Decrypt, 1: Encrypt).
/// * `input_file` - Path to the file to process.
Future<void> wctProcess(
        {required TargetType target,
        required Action action,
        required String inputFile}) =>
    RustLib.instance.api.crateApiWctProcess(
        target: target, action: action, inputFile: inputFile);

/// Unpacks IMGB to a DDS file using XGR/IMG header.
Future<ImgData> imgUnpack(
        {required String headerFile,
        required String imgbFile,
        required String outDds}) =>
    RustLib.instance.api.crateApiImgUnpack(
        headerFile: headerFile, imgbFile: imgbFile, outDds: outDds);

/// Unpacks IMGB to memory using XGR/IMG header.
Future<(ImgData, Uint8List)> imgUnpackToMemory(
        {required String headerFile, required String imgbFile}) =>
    RustLib.instance.api
        .crateApiImgUnpackToMemory(headerFile: headerFile, imgbFile: imgbFile);

/// Repacks DDS back to IMGB (strict size parity).
Future<void> imgRepackStrict(
        {required String headerFile,
        required String imgbFile,
        required String inDds}) =>
    RustLib.instance.api.crateApiImgRepackStrict(
        headerFile: headerFile, imgbFile: imgbFile, inDds: inDds);

/// Parses WDB file into memory structure.
Future<WdbData> wdbParse({required String inFile, required int gameCode}) =>
    RustLib.instance.api.crateApiWdbParse(inFile: inFile, gameCode: gameCode);

/// Packs memory structure into a WDB file.
Future<void> wdbRepack({required WdbData data, required String outFile}) =>
    RustLib.instance.api.crateApiWdbRepack(data: data, outFile: outFile);

/// Converts WDB memory structure to JSON string.
Future<String> wdbToJson({required WdbData data}) =>
    RustLib.instance.api.crateApiWdbToJson(data: data);

/// Parses JSON string into WDB memory structure.
Future<WdbData> wdbFromJson({required String json}) =>
    RustLib.instance.api.crateApiWdbFromJson(json: json);

/// Parses a CGT (Crystal Graph Tree) file from disk.
///
/// # Arguments
/// * `in_file` - Path to the CGT file
///
/// # Returns
/// * `Ok(CgtFile)` - Parsed CGT data with entries and nodes
Future<CgtFile> cgtParse({required String inFile}) =>
    RustLib.instance.api.crateApiCgtParse(inFile: inFile);

/// Parses a CGT file from memory.
///
/// # Arguments
/// * `data` - Raw CGT file bytes
///
/// # Returns
/// * `Ok(CgtFile)` - Parsed CGT data
Future<CgtFile> cgtParseFromMemory({required List<int> data}) =>
    RustLib.instance.api.crateApiCgtParseFromMemory(data: data);

/// Writes a CGT file to disk.
///
/// # Arguments
/// * `cgt` - The CGT data to write
/// * `out_file` - Output file path
Future<void> cgtWrite({required CgtFile cgt, required String outFile}) =>
    RustLib.instance.api.crateApiCgtWrite(cgt: cgt, outFile: outFile);

/// Writes a CGT file to memory.
///
/// # Arguments
/// * `cgt` - The CGT data to serialize
///
/// # Returns
/// * `Ok(Vec<u8>)` - Serialized CGT bytes
Future<Uint8List> cgtWriteToMemory({required CgtFile cgt}) =>
    RustLib.instance.api.crateApiCgtWriteToMemory(cgt: cgt);

/// Converts a CGT file to JSON string.
Future<String> cgtToJson({required CgtFile cgt}) =>
    RustLib.instance.api.crateApiCgtToJson(cgt: cgt);

/// Parses a CGT file from JSON string.
Future<CgtFile> cgtFromJson({required String json}) =>
    RustLib.instance.api.crateApiCgtFromJson(json: json);

/// Validates a CGT file structure and returns warnings.
///
/// # Returns
/// * `Vec<String>` - List of validation warnings (empty if valid)
Future<List<String>> cgtValidate({required CgtFile cgt}) =>
    RustLib.instance.api.crateApiCgtValidate(cgt: cgt);

/// Parses an MCP (Master Crystal Pattern) file from disk.
///
/// # Arguments
/// * `in_file` - Path to the MCP file
///
/// # Returns
/// * `Ok(McpFile)` - Parsed MCP data with patterns
Future<McpFile> mcpParse({required String inFile}) =>
    RustLib.instance.api.crateApiMcpParse(inFile: inFile);

/// Parses an MCP file from memory.
///
/// # Arguments
/// * `data` - Raw MCP file bytes
///
/// # Returns
/// * `Ok(McpFile)` - Parsed MCP data
Future<McpFile> mcpParseFromMemory({required List<int> data}) =>
    RustLib.instance.api.crateApiMcpParseFromMemory(data: data);

/// Converts an MCP file to JSON string.
Future<String> mcpToJson({required McpFile mcp}) =>
    RustLib.instance.api.crateApiMcpToJson(mcp: mcp);

/// Parses an MCP file from JSON string.
Future<McpFile> mcpFromJson({required String json}) =>
    RustLib.instance.api.crateApiMcpFromJson(json: json);

/// Parses a VFX XFV file and returns all effect data.
///
/// # Arguments
/// * `in_file` - Path to the XFV file
///
/// # Returns
/// Complete VFX data including textures, models, animations, and effects.
Future<VfxData> vfxParse({required String inFile}) =>
    RustLib.instance.api.crateApiVfxParse(inFile: inFile);

/// Gets a quick summary of VFX file contents.
///
/// # Arguments
/// * `in_file` - Path to the XFV file
///
/// # Returns
/// Summary with counts and effect names.
Future<VfxSummary> vfxGetSummary({required String inFile}) =>
    RustLib.instance.api.crateApiVfxGetSummary(inFile: inFile);

/// Lists all effect names in a VFX file.
///
/// # Arguments
/// * `in_file` - Path to the XFV file
///
/// # Returns
/// List of effect names.
Future<List<String>> vfxListEffects({required String inFile}) =>
    RustLib.instance.api.crateApiVfxListEffects(inFile: inFile);

/// Lists all textures in a VFX file.
///
/// # Arguments
/// * `in_file` - Path to the XFV file
///
/// # Returns
/// List of texture info (name, dimensions, format).
Future<List<VfxTexture>> vfxListTextures({required String inFile}) =>
    RustLib.instance.api.crateApiVfxListTextures(inFile: inFile);

/// Exports VFX data to JSON string.
///
/// # Arguments
/// * `in_file` - Path to the XFV file
///
/// # Returns
/// JSON string representation of VFX data.
Future<String> vfxExportJson({required String inFile}) =>
    RustLib.instance.api.crateApiVfxExportJson(inFile: inFile);

/// Extracts VFX textures to DDS files.
///
/// Requires the paired IMGB file to be present.
///
/// # Arguments
/// * `xfv_path` - Path to the XFV file
/// * `output_dir` - Directory to write DDS files
///
/// # Returns
/// List of extracted DDS file paths.
Future<List<String>> vfxExtractTextures(
        {required String xfvPath, required String outputDir}) =>
    RustLib.instance.api
        .crateApiVfxExtractTextures(xfvPath: xfvPath, outputDir: outputDir);

/// Extracts a single VFX texture as PNG bytes in memory.
///
/// This function loads only the specified texture without writing to disk.
/// Ideal for on-demand texture preview in the UI.
///
/// # Arguments
/// * `xfv_path` - Path to the XFV file
/// * `texture_name` - Name of the texture (e.g., "v04fdfc11828acd")
///
/// # Returns
/// Tuple of ((width, height), png_bytes).
Future<((int, int), Uint8List)> vfxExtractTextureAsPng(
        {required String xfvPath, required String textureName}) =>
    RustLib.instance.api.crateApiVfxExtractTextureAsPng(
        xfvPath: xfvPath, textureName: textureName);

/// Converts a DDS file to PNG format.
///
/// Supports DXT1, DXT3, DXT5, and uncompressed RGBA formats.
///
/// # Arguments
/// * `dds_path` - Path to input DDS file
/// * `png_path` - Path to output PNG file
///
/// # Returns
/// Tuple of (width, height) of the converted image.
Future<(int, int)> convertDdsToPng(
        {required String ddsPath, required String pngPath}) =>
    RustLib.instance.api
        .crateApiConvertDdsToPng(ddsPath: ddsPath, pngPath: pngPath);

/// Converts a DDS file to PNG and returns the PNG data as bytes.
///
/// Useful for displaying textures directly in Flutter.
///
/// # Arguments
/// * `dds_path` - Path to input DDS file
///
/// # Returns
/// Tuple of ((width, height), png_bytes).
Future<((int, int), Uint8List)> convertDdsToPngBytes(
        {required String ddsPath}) =>
    RustLib.instance.api.crateApiConvertDdsToPngBytes(ddsPath: ddsPath);

/// Parses an event file and extracts metadata (in-memory, no extraction).
///
/// This is the primary function for quick viewing of cutscene contents.
/// It loads the file, parses the structure, and returns actors, blocks,
/// resources, and dialogue entry references.
///
/// # Arguments
/// * `in_file` - Path to the event file (`.white.win32.xwb`)
///
/// # Returns
/// Complete event metadata.
///
/// # Example
/// ```dart
/// final meta = await api.eventParse('ev_ddaa_080.white.win32.xwb');
/// print('Actors: ${meta.actors.length}');
/// print('Blocks: ${meta.blocks.length}');
/// ```
Future<EventMetadata> eventParse({required String inFile}) =>
    RustLib.instance.api.crateApiEventParse(inFile: inFile);

/// Parses event metadata from raw bytes.
///
/// Useful when the data is already in memory (e.g., from archive extraction).
///
/// # Arguments
/// * `data` - Raw bytes of the event file
/// * `name` - Optional name for the event
Future<EventMetadata> eventParseFromMemory(
        {required List<int> data, String? name}) =>
    RustLib.instance.api.crateApiEventParseFromMemory(data: data, name: name);

/// Gets a quick summary of event contents.
///
/// # Arguments
/// * `in_file` - Path to the event file
///
/// # Returns
/// Summary with counts and total duration.
Future<EventSummary> eventGetSummary({required String inFile}) =>
    RustLib.instance.api.crateApiEventGetSummary(inFile: inFile);

/// Extracts an event file to a directory and returns metadata.
///
/// This combines WPD extraction with metadata parsing, giving you
/// both the extracted files and the parsed structure.
///
/// # Arguments
/// * `in_file` - Path to the event file
/// * `out_dir` - Directory to extract files to
///
/// # Returns
/// Extraction result with metadata and file list.
Future<ExtractedEvent> eventExtract(
        {required String inFile, required String outDir}) =>
    RustLib.instance.api.crateApiEventExtract(inFile: inFile, outDir: outDir);

/// Exports event metadata to JSON string.
///
/// Useful for external tools or debugging.
///
/// # Arguments
/// * `in_file` - Path to the event file
///
/// # Returns
/// JSON string representation of event metadata.
Future<String> eventExportJson({required String inFile}) =>
    RustLib.instance.api.crateApiEventExportJson(inFile: inFile);

/// Parses an event from a directory (including DataSet if present).
///
/// This is the preferred method when you have the full event directory
/// structure, as it will also parse the DataSet folder containing
/// motion and camera control blocks for animation data.
///
/// # Directory Structure
/// ```text
/// ev_xxxx_xxx/
/// ├── bin/
/// │   └── ev_xxxx_xxx.white.win32.xwb
/// └── DataSet/  (optional)
///     ├── a00.white.win32.bin
///     ├── a01.white.win32.bin
///     └── ...
/// ```
///
/// # Arguments
/// * `dir_path` - Path to the event directory
///
/// # Returns
/// Event metadata with `dataset` field populated if DataSet exists.
///
/// # Example
/// ```dart
/// final meta = await api.eventParseDirectory('./ev_yuaa_360');
/// if (meta.dataset != null) {
///   print('Motion blocks: ${meta.dataset!.motionBlocks.length}');
///   print('Camera blocks: ${meta.dataset!.cameraBlocks.length}');
/// }
/// ```
Future<EventMetadata> eventParseDirectory({required String dirPath}) =>
    RustLib.instance.api.crateApiEventParseDirectory(dirPath: dirPath);

/// Parses SCD file metadata without decoding audio.
///
/// Use this for quick inspection of sound file properties.
///
/// # Arguments
/// * `in_file` - Path to the SCD file
///
/// # Returns
/// Metadata including stream count, codec types, sample rates.
///
/// # Example
/// ```dart
/// final meta = await api.scdParse('sound.scd');
/// for (final stream in meta.streams) {
///   print('Stream ${stream.index}: ${stream.codec} @ ${stream.sampleRate}Hz');
/// }
/// ```
Future<ScdMetadata> scdParse({required String inFile}) =>
    RustLib.instance.api.crateApiScdParse(inFile: inFile);

/// Parses SCD metadata from raw bytes.
///
/// # Arguments
/// * `data` - Raw SCD file bytes
/// * `name` - Name for identification
Future<ScdMetadata> scdParseFromMemory(
        {required List<int> data, required String name}) =>
    RustLib.instance.api.crateApiScdParseFromMemory(data: data, name: name);

/// Decodes all audio streams from an SCD file.
///
/// Returns decoded PCM audio data ready for playback.
///
/// # Arguments
/// * `in_file` - Path to the SCD file
///
/// # Returns
/// Extract result with metadata and decoded audio streams.
Future<ScdExtractResult> scdDecode({required String inFile}) =>
    RustLib.instance.api.crateApiScdDecode(inFile: inFile);

/// Decodes all audio streams from SCD bytes.
///
/// # Arguments
/// * `data` - Raw SCD file bytes
/// * `name` - Name for identification
Future<ScdExtractResult> scdDecodeFromMemory(
        {required List<int> data, required String name}) =>
    RustLib.instance.api.crateApiScdDecodeFromMemory(data: data, name: name);

/// Decodes a specific audio stream from an SCD file.
///
/// # Arguments
/// * `in_file` - Path to the SCD file
/// * `stream_index` - Index of the stream to decode
///
/// # Returns
/// Decoded audio data (PCM, ready for playback).
Future<DecodedAudio> scdDecodeStream(
        {required String inFile, required int streamIndex}) =>
    RustLib.instance.api
        .crateApiScdDecodeStream(inFile: inFile, streamIndex: streamIndex);

/// Converts SCD file to WAV bytes (first stream).
///
/// Returns complete WAV file data that can be played directly
/// or written to a file.
///
/// # Arguments
/// * `in_file` - Path to the SCD file
///
/// # Returns
/// WAV file bytes (RIFF format, PCM audio).
///
/// # Example
/// ```dart
/// final wavBytes = await api.scdToWav('sound.scd');
/// // Play wavBytes using an audio player
/// ```
Future<Uint8List> scdToWav({required String inFile}) =>
    RustLib.instance.api.crateApiScdToWav(inFile: inFile);

/// Converts SCD bytes to WAV bytes (first stream).
///
/// # Arguments
/// * `data` - Raw SCD file bytes
/// * `name` - Name for identification
///
/// # Returns
/// WAV file bytes.
Future<Uint8List> scdBytesToWav(
        {required List<int> data, required String name}) =>
    RustLib.instance.api.crateApiScdBytesToWav(data: data, name: name);

/// Extracts SCD to WAV file on disk.
///
/// # Arguments
/// * `scd_path` - Path to input SCD file
/// * `wav_path` - Path to output WAV file
Future<void> scdExtractToWav(
        {required String scdPath, required String wavPath}) =>
    RustLib.instance.api
        .crateApiScdExtractToWav(scdPath: scdPath, wavPath: wavPath);

/// Convert WAV file to SCD format
///
/// Creates an SCD container with MS-ADPCM encoded audio.
///
/// # Arguments
/// * `wav_path` - Path to input WAV file
/// * `scd_path` - Path to output SCD file
Future<void> wavToScd({required String wavPath, required String scdPath}) =>
    RustLib.instance.api.crateApiWavToScd(wavPath: wavPath, scdPath: scdPath);

/// File metadata for a single entry in a WBT archive.
/// Mirrors the Rust struct for flutter_rust_bridge serialization.
class WbtFileEntry {
  /// File index in the archive (0-based)
  final BigInt index;

  /// Byte offset in the container file
  final BigInt offset;

  /// Original uncompressed file size
  final int uncompressedSize;

  /// Compressed file size
  final int compressedSize;

  /// Virtual path within the archive
  final String path;

  const WbtFileEntry({
    required this.index,
    required this.offset,
    required this.uncompressedSize,
    required this.compressedSize,
    required this.path,
  });

  @override
  int get hashCode =>
      index.hashCode ^
      offset.hashCode ^
      uncompressedSize.hashCode ^
      compressedSize.hashCode ^
      path.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WbtFileEntry &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          offset == other.offset &&
          uncompressedSize == other.uncompressedSize &&
          compressedSize == other.compressedSize &&
          path == other.path;
}

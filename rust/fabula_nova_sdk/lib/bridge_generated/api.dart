// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'lib.dart';
import 'modules/crystalium/structs.dart';
import 'modules/img/structs.dart';
import 'modules/vfx/structs.dart';
import 'modules/wct.dart';
import 'modules/wdb/enums.dart';
import 'modules/wdb/structs.dart';
import 'modules/wpd/structs.dart';
import 'modules/ztr/structs.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `determine_wdb_game_code`, `map_game_code`

/// Creates a log stream using StreamSink (original pattern).
/// NOTE: This may not work well with hot restart. Prefer using fetch_logs() instead.
Stream<String> createLogStream() =>
    RustLib.instance.api.crateApiCreateLogStream();

Future<void> initApp() => RustLib.instance.api.crateApiInitApp();

/// Sets the log level for the Rust logger.
///
/// # Arguments
/// * `level` - Log level (0=Off, 1=Error, 2=Warn, 3=Info, 4=Debug, 5=Trace)
Future<void> setLogLevel({required int level}) =>
    RustLib.instance.api.crateApiSetLogLevel(level: level);

/// Gets the current log level.
///
/// # Returns
/// Log level as integer (0=Off, 1=Error, 2=Warn, 3=Info, 4=Debug, 5=Trace)
Future<int> getLogLevel() => RustLib.instance.api.crateApiGetLogLevel();

Future<void> testLog({required String message}) =>
    RustLib.instance.api.crateApiTestLog(message: message);

/// Clears the log callback to prevent dangling references on hot reload.
/// Call this before reinitializing the Dart side.
Future<void> clearLogCallback() =>
    RustLib.instance.api.crateApiClearLogCallback();

/// Fetches all new logs since the last fetch.
/// This is safe to call after hot restart - the Rust log buffer survives.
/// Returns an empty vector if no new logs are available.
Future<List<String>> fetchLogs() => RustLib.instance.api.crateApiFetchLogs();

/// Gets all logs currently in the buffer.
/// Use this on initialization to get historical logs.
Future<List<String>> getAllBufferedLogs() =>
    RustLib.instance.api.crateApiGetAllBufferedLogs();

/// Resets the log read index so the next fetch_logs() returns all buffered logs.
/// Call this after hot restart to ensure you don't miss logs.
Future<void> resetLogReadIndex() =>
    RustLib.instance.api.crateApiResetLogReadIndex();

/// Extracts ZTR file to a text file.
///
/// # Arguments
/// * `in_file` - Path to the source .ztr file.
/// * `out_file` - Path to the destination .txt file.
/// * `game_code` - Game version (0: FF13, 1: FF13-2, 2: LR).
Future<void> ztrExtractToText(
        {required String inFile,
        required String outFile,
        required int gameCode}) =>
    RustLib.instance.api.crateApiZtrExtractToText(
        inFile: inFile, outFile: outFile, gameCode: gameCode);

/// Parses ZTR file into memory structure.
Future<ZtrData> ztrParse({required String inFile, required int gameCode}) =>
    RustLib.instance.api.crateApiZtrParse(inFile: inFile, gameCode: gameCode);

/// Parses ZTR from memory buffer into memory structure.
Future<ZtrData> ztrParseFromMemory(
        {required List<int> data, required int gameCode}) =>
    RustLib.instance.api
        .crateApiZtrParseFromMemory(data: data, gameCode: gameCode);

/// Packs in-memory entries (ID, Text) into a ZTR file.
Future<void> ztrPackFromData(
        {required List<(String, String)> entries,
        required String outFile,
        required int gameCode}) =>
    RustLib.instance.api.crateApiZtrPackFromData(
        entries: entries, outFile: outFile, gameCode: gameCode);

/// Packs ZtrData structure into a ZTR file.
Future<void> ztrPackFromStruct(
        {required ZtrData data,
        required String outFile,
        required int gameCode}) =>
    RustLib.instance.api.crateApiZtrPackFromStruct(
        data: data, outFile: outFile, gameCode: gameCode);

/// Converts memory structure to formatted text string.
Future<String> ztrToTextString({required ZtrData data}) =>
    RustLib.instance.api.crateApiZtrToTextString(data: data);

/// Parses all ZTR files in a directory recursively with progress streaming.
///
/// # Arguments
/// * `dir_path` - Path to the directory to scan recursively.
/// * `game_code` - Game version (0: FF13, 1: FF13-2, 2: LR).
/// * `progress_sink` - StreamSink for progress updates.
///
/// # Returns
/// A `ZtrDirectoryResult` containing all parsed entries and error information.
Stream<ZtrParseProgress> ztrParseDirectory(
        {required String dirPath, required int gameCode}) =>
    RustLib.instance.api
        .crateApiZtrParseDirectory(dirPath: dirPath, gameCode: gameCode);

/// Parses all ZTR files in a directory recursively (simple version without progress).
///
/// # Arguments
/// * `dir_path` - Path to the directory to scan recursively.
/// * `game_code` - Game version (0: FF13, 1: FF13-2, 2: LR).
///
/// # Returns
/// A `ZtrDirectoryResult` containing all parsed entries and error information.
Future<ZtrDirectoryResult> ztrParseDirectorySimple(
        {required String dirPath, required int gameCode}) =>
    RustLib.instance.api
        .crateApiZtrParseDirectorySimple(dirPath: dirPath, gameCode: gameCode);

/// Extracts all files from a WhiteBinTools archive.
///
/// # Arguments
/// * `filelist_path` - Path to the filelistu.win32.bin file.
/// * `container_path` - Path to the white_imgu.win32.bin file.
/// * `out_dir` - Directory where files will be extracted.
/// * `game_code` - Game version (0: FF13, 1: FF13-2, 2: LR).
Future<void> wbtExtract(
        {required String filelistPath,
        required String containerPath,
        required String outDir,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtExtract(
        filelistPath: filelistPath,
        containerPath: containerPath,
        outDir: outDir,
        gameCode: gameCode);

/// Repacks files from a directory into a WhiteBinTools archive.
Future<void> wbtRepack(
        {required String filelistPath,
        required String containerPath,
        required String extractedDir,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtRepack(
        filelistPath: filelistPath,
        containerPath: containerPath,
        extractedDir: extractedDir,
        gameCode: gameCode);

/// Repacks a single file into a WhiteBinTools archive.
Future<void> wbtRepackSingle(
        {required String filelistPath,
        required String containerPath,
        required String targetPathInArchive,
        required String fileToInject,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtRepackSingle(
        filelistPath: filelistPath,
        containerPath: containerPath,
        targetPathInArchive: targetPathInArchive,
        fileToInject: fileToInject,
        gameCode: gameCode);

/// Repacks multiple files into a WhiteBinTools archive.
Future<void> wbtRepackMultiple(
        {required String filelistPath,
        required String containerPath,
        required List<(String, String)> filesToPatch,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtRepackMultiple(
        filelistPath: filelistPath,
        containerPath: containerPath,
        filesToPatch: filesToPatch,
        gameCode: gameCode);

/// Returns the file list metadata from a WBT archive.
/// Use this to display a file tree in Flutter without extracting files.
Future<List<WbtFileEntry>> wbtGetFileList(
        {required String filelistPath, required int gameCode}) =>
    RustLib.instance.api
        .crateApiWbtGetFileList(filelistPath: filelistPath, gameCode: gameCode);

/// Extracts a single file from the WBT archive by its virtual path.
Future<void> wbtExtractSingleFile(
        {required String filelistPath,
        required String containerPath,
        required String virtualPath,
        required String outputPath,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtExtractSingleFile(
        filelistPath: filelistPath,
        containerPath: containerPath,
        virtualPath: virtualPath,
        outputPath: outputPath,
        gameCode: gameCode);

/// Extracts a single file from the WBT archive by its index.
Future<void> wbtExtractFileByIndex(
        {required String filelistPath,
        required String containerPath,
        required BigInt fileIndex,
        required String outputDir,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtExtractFileByIndex(
        filelistPath: filelistPath,
        containerPath: containerPath,
        fileIndex: fileIndex,
        outputDir: outputDir,
        gameCode: gameCode);

/// Extracts all files matching a virtual directory prefix.
/// Returns the number of files extracted.
Future<BigInt> wbtExtractDirectory(
        {required String filelistPath,
        required String containerPath,
        required String dirPrefix,
        required String outputDir,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtExtractDirectory(
        filelistPath: filelistPath,
        containerPath: containerPath,
        dirPrefix: dirPrefix,
        outputDir: outputDir,
        gameCode: gameCode);

/// Extracts multiple files by their indices.
/// Returns the number of files extracted.
Future<BigInt> wbtExtractFilesByIndices(
        {required String filelistPath,
        required String containerPath,
        required Uint64List indices,
        required String outputDir,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtExtractFilesByIndices(
        filelistPath: filelistPath,
        containerPath: containerPath,
        indices: indices,
        outputDir: outputDir,
        gameCode: gameCode);

/// Unpacks WPD archive to a directory. Returns the WpdData structure.
Future<WpdData> wpdUnpack({required String inFile, required String outDir}) =>
    RustLib.instance.api.crateApiWpdUnpack(inFile: inFile, outDir: outDir);

/// Repacks directory into a WPD archive.
Future<void> wpdRepack({required String inDir, required String outFile}) =>
    RustLib.instance.api.crateApiWpdRepack(inDir: inDir, outFile: outFile);

/// Performs encryption/decryption on supported files (FileList or CLB).
///
/// # Arguments
/// * `target` - Target file type (0: FileList, 1: CLB).
/// * `action` - Crypt action (0: Decrypt, 1: Encrypt).
/// * `input_file` - Path to the file to process.
Future<void> wctProcess(
        {required TargetType target,
        required Action action,
        required String inputFile}) =>
    RustLib.instance.api.crateApiWctProcess(
        target: target, action: action, inputFile: inputFile);

/// Unpacks IMGB to a DDS file using XGR/IMG header.
Future<ImgData> imgUnpack(
        {required String headerFile,
        required String imgbFile,
        required String outDds}) =>
    RustLib.instance.api.crateApiImgUnpack(
        headerFile: headerFile, imgbFile: imgbFile, outDds: outDds);

/// Unpacks IMGB to memory using XGR/IMG header.
Future<(ImgData, Uint8List)> imgUnpackToMemory(
        {required String headerFile, required String imgbFile}) =>
    RustLib.instance.api
        .crateApiImgUnpackToMemory(headerFile: headerFile, imgbFile: imgbFile);

/// Repacks DDS back to IMGB (strict size parity).
Future<void> imgRepackStrict(
        {required String headerFile,
        required String imgbFile,
        required String inDds}) =>
    RustLib.instance.api.crateApiImgRepackStrict(
        headerFile: headerFile, imgbFile: imgbFile, inDds: inDds);

/// Parses WDB file into memory structure.
Future<WdbData> wdbParse({required String inFile, required int gameCode}) =>
    RustLib.instance.api.crateApiWdbParse(inFile: inFile, gameCode: gameCode);

/// Packs memory structure into a WDB file.
Future<void> wdbRepack({required WdbData data, required String outFile}) =>
    RustLib.instance.api.crateApiWdbRepack(data: data, outFile: outFile);

/// Converts WDB memory structure to JSON string.
Future<String> wdbToJson({required WdbData data}) =>
    RustLib.instance.api.crateApiWdbToJson(data: data);

/// Parses JSON string into WDB memory structure.
Future<WdbData> wdbFromJson({required String json}) =>
    RustLib.instance.api.crateApiWdbFromJson(json: json);

/// Parses a CGT (Crystal Graph Tree) file from disk.
///
/// # Arguments
/// * `in_file` - Path to the CGT file
///
/// # Returns
/// * `Ok(CgtFile)` - Parsed CGT data with entries and nodes
Future<CgtFile> cgtParse({required String inFile}) =>
    RustLib.instance.api.crateApiCgtParse(inFile: inFile);

/// Parses a CGT file from memory.
///
/// # Arguments
/// * `data` - Raw CGT file bytes
///
/// # Returns
/// * `Ok(CgtFile)` - Parsed CGT data
Future<CgtFile> cgtParseFromMemory({required List<int> data}) =>
    RustLib.instance.api.crateApiCgtParseFromMemory(data: data);

/// Writes a CGT file to disk.
///
/// # Arguments
/// * `cgt` - The CGT data to write
/// * `out_file` - Output file path
Future<void> cgtWrite({required CgtFile cgt, required String outFile}) =>
    RustLib.instance.api.crateApiCgtWrite(cgt: cgt, outFile: outFile);

/// Writes a CGT file to memory.
///
/// # Arguments
/// * `cgt` - The CGT data to serialize
///
/// # Returns
/// * `Ok(Vec<u8>)` - Serialized CGT bytes
Future<Uint8List> cgtWriteToMemory({required CgtFile cgt}) =>
    RustLib.instance.api.crateApiCgtWriteToMemory(cgt: cgt);

/// Converts a CGT file to JSON string.
Future<String> cgtToJson({required CgtFile cgt}) =>
    RustLib.instance.api.crateApiCgtToJson(cgt: cgt);

/// Parses a CGT file from JSON string.
Future<CgtFile> cgtFromJson({required String json}) =>
    RustLib.instance.api.crateApiCgtFromJson(json: json);

/// Validates a CGT file structure and returns warnings.
///
/// # Returns
/// * `Vec<String>` - List of validation warnings (empty if valid)
Future<List<String>> cgtValidate({required CgtFile cgt}) =>
    RustLib.instance.api.crateApiCgtValidate(cgt: cgt);

/// Parses an MCP (Master Crystal Pattern) file from disk.
///
/// # Arguments
/// * `in_file` - Path to the MCP file
///
/// # Returns
/// * `Ok(McpFile)` - Parsed MCP data with patterns
Future<McpFile> mcpParse({required String inFile}) =>
    RustLib.instance.api.crateApiMcpParse(inFile: inFile);

/// Parses an MCP file from memory.
///
/// # Arguments
/// * `data` - Raw MCP file bytes
///
/// # Returns
/// * `Ok(McpFile)` - Parsed MCP data
Future<McpFile> mcpParseFromMemory({required List<int> data}) =>
    RustLib.instance.api.crateApiMcpParseFromMemory(data: data);

/// Converts an MCP file to JSON string.
Future<String> mcpToJson({required McpFile mcp}) =>
    RustLib.instance.api.crateApiMcpToJson(mcp: mcp);

/// Parses an MCP file from JSON string.
Future<McpFile> mcpFromJson({required String json}) =>
    RustLib.instance.api.crateApiMcpFromJson(json: json);

/// Parses a VFX XFV file and returns all effect data.
///
/// # Arguments
/// * `in_file` - Path to the XFV file
///
/// # Returns
/// Complete VFX data including textures, models, animations, and effects.
Future<VfxData> vfxParse({required String inFile}) =>
    RustLib.instance.api.crateApiVfxParse(inFile: inFile);

/// Gets a quick summary of VFX file contents.
///
/// # Arguments
/// * `in_file` - Path to the XFV file
///
/// # Returns
/// Summary with counts and effect names.
Future<VfxSummary> vfxGetSummary({required String inFile}) =>
    RustLib.instance.api.crateApiVfxGetSummary(inFile: inFile);

/// Lists all effect names in a VFX file.
///
/// # Arguments
/// * `in_file` - Path to the XFV file
///
/// # Returns
/// List of effect names.
Future<List<String>> vfxListEffects({required String inFile}) =>
    RustLib.instance.api.crateApiVfxListEffects(inFile: inFile);

/// Lists all textures in a VFX file.
///
/// # Arguments
/// * `in_file` - Path to the XFV file
///
/// # Returns
/// List of texture info (name, dimensions, format).
Future<List<VfxTexture>> vfxListTextures({required String inFile}) =>
    RustLib.instance.api.crateApiVfxListTextures(inFile: inFile);

/// Exports VFX data to JSON string.
///
/// # Arguments
/// * `in_file` - Path to the XFV file
///
/// # Returns
/// JSON string representation of VFX data.
Future<String> vfxExportJson({required String inFile}) =>
    RustLib.instance.api.crateApiVfxExportJson(inFile: inFile);

/// Extracts VFX textures to DDS files.
///
/// Requires the paired IMGB file to be present.
///
/// # Arguments
/// * `xfv_path` - Path to the XFV file
/// * `output_dir` - Directory to write DDS files
///
/// # Returns
/// List of extracted DDS file paths.
Future<List<String>> vfxExtractTextures(
        {required String xfvPath, required String outputDir}) =>
    RustLib.instance.api
        .crateApiVfxExtractTextures(xfvPath: xfvPath, outputDir: outputDir);

/// Extracts a single VFX texture as PNG bytes in memory.
///
/// This function loads only the specified texture without writing to disk.
/// Ideal for on-demand texture preview in the UI.
///
/// # Arguments
/// * `xfv_path` - Path to the XFV file
/// * `texture_name` - Name of the texture (e.g., "v04fdfc11828acd")
///
/// # Returns
/// Tuple of ((width, height), png_bytes).
Future<((int, int), Uint8List)> vfxExtractTextureAsPng(
        {required String xfvPath, required String textureName}) =>
    RustLib.instance.api.crateApiVfxExtractTextureAsPng(
        xfvPath: xfvPath, textureName: textureName);

/// Converts a DDS file to PNG format.
///
/// Supports DXT1, DXT3, DXT5, and uncompressed RGBA formats.
///
/// # Arguments
/// * `dds_path` - Path to input DDS file
/// * `png_path` - Path to output PNG file
///
/// # Returns
/// Tuple of (width, height) of the converted image.
Future<(int, int)> convertDdsToPng(
        {required String ddsPath, required String pngPath}) =>
    RustLib.instance.api
        .crateApiConvertDdsToPng(ddsPath: ddsPath, pngPath: pngPath);

/// Converts a DDS file to PNG and returns the PNG data as bytes.
///
/// Useful for displaying textures directly in Flutter.
///
/// # Arguments
/// * `dds_path` - Path to input DDS file
///
/// # Returns
/// Tuple of ((width, height), png_bytes).
Future<((int, int), Uint8List)> convertDdsToPngBytes(
        {required String ddsPath}) =>
    RustLib.instance.api.crateApiConvertDdsToPngBytes(ddsPath: ddsPath);

/// Initializes the VFX player with specified render dimensions.
///
/// Must be called before loading models or rendering frames.
///
/// # Arguments
/// * `width` - Render width in pixels
/// * `height` - Render height in pixels
///
/// # Returns
/// Ok(()) on success.
Future<void> vfxPlayerInit({required int width, required int height}) =>
    RustLib.instance.api.crateApiVfxPlayerInit(width: width, height: height);

/// Loads a test quad with specified color for debugging.
///
/// # Arguments
/// * `r`, `g`, `b`, `a` - RGBA color (0.0 to 1.0)
///
/// # Returns
/// Ok(()) on success.
Future<void> vfxPlayerLoadTest(
        {required double r,
        required double g,
        required double b,
        required double a}) =>
    RustLib.instance.api.crateApiVfxPlayerLoadTest(r: r, g: g, b: b, a: a);

/// Loads a VFX model for rendering.
///
/// The model must exist in the VFX file, and a texture must be provided as RGBA bytes.
///
/// # Arguments
/// * `xfv_path` - Path to the XFV file
/// * `model_name` - Name of the model to load
/// * `texture_name` - Name of the texture to use (or empty for first texture)
///
/// # Returns
/// Ok(()) on success.
Future<void> vfxPlayerLoadModel(
        {required String xfvPath,
        required String modelName,
        required String textureName}) =>
    RustLib.instance.api.crateApiVfxPlayerLoadModel(
        xfvPath: xfvPath, modelName: modelName, textureName: textureName);

/// Renders a single frame and returns RGBA pixel data.
///
/// # Arguments
/// * `delta_time` - Time elapsed since last frame (in seconds)
///
/// # Returns
/// RGBA pixel data (width * height * 4 bytes).
Future<Uint8List> vfxPlayerRenderFrame({required double deltaTime}) =>
    RustLib.instance.api.crateApiVfxPlayerRenderFrame(deltaTime: deltaTime);

/// Gets the current animation time.
///
/// # Returns
/// Current animation time in seconds.
Future<double> vfxPlayerGetTime() =>
    RustLib.instance.api.crateApiVfxPlayerGetTime();

/// Resets the animation to the beginning.
Future<void> vfxPlayerReset() => RustLib.instance.api.crateApiVfxPlayerReset();

/// Disposes of the VFX player and releases GPU resources.
Future<void> vfxPlayerDispose() =>
    RustLib.instance.api.crateApiVfxPlayerDispose();

/// Checks if the VFX player is initialized.
///
/// # Returns
/// True if initialized, false otherwise.
Future<bool> vfxPlayerIsInitialized() =>
    RustLib.instance.api.crateApiVfxPlayerIsInitialized();

/// Gets the render dimensions.
///
/// # Returns
/// Tuple of (width, height) in pixels.
Future<(int, int)> vfxPlayerGetDimensions() =>
    RustLib.instance.api.crateApiVfxPlayerGetDimensions();

/// File metadata for a single entry in a WBT archive.
/// Mirrors the Rust struct for flutter_rust_bridge serialization.
class WbtFileEntry {
  /// File index in the archive (0-based)
  final BigInt index;

  /// Byte offset in the container file
  final BigInt offset;

  /// Original uncompressed file size
  final int uncompressedSize;

  /// Compressed file size
  final int compressedSize;

  /// Virtual path within the archive
  final String path;

  const WbtFileEntry({
    required this.index,
    required this.offset,
    required this.uncompressedSize,
    required this.compressedSize,
    required this.path,
  });

  @override
  int get hashCode =>
      index.hashCode ^
      offset.hashCode ^
      uncompressedSize.hashCode ^
      compressedSize.hashCode ^
      path.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WbtFileEntry &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          offset == other.offset &&
          uncompressedSize == other.uncompressedSize &&
          compressedSize == other.compressedSize &&
          path == other.path;
}

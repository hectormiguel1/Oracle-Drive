// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'modules/img/structs.dart';
import 'modules/wct.dart';
import 'modules/wdb/enums.dart';
import 'modules/wdb/structs.dart';
import 'modules/wpd/structs.dart';
import 'modules/ztr/structs.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `determine_wdb_game_code`, `map_game_code`

/// Creates a log stream using StreamSink (original pattern).
/// NOTE: This may not work well with hot restart. Prefer using fetch_logs() instead.
Stream<String> createLogStream() =>
    RustLib.instance.api.crateApiCreateLogStream();

Future<void> initApp() => RustLib.instance.api.crateApiInitApp();

/// Sets the log level for the Rust logger.
///
/// # Arguments
/// * `level` - Log level (0=Off, 1=Error, 2=Warn, 3=Info, 4=Debug, 5=Trace)
Future<void> setLogLevel({required int level}) =>
    RustLib.instance.api.crateApiSetLogLevel(level: level);

/// Gets the current log level.
///
/// # Returns
/// Log level as integer (0=Off, 1=Error, 2=Warn, 3=Info, 4=Debug, 5=Trace)
Future<int> getLogLevel() => RustLib.instance.api.crateApiGetLogLevel();

Future<void> testLog({required String message}) =>
    RustLib.instance.api.crateApiTestLog(message: message);

/// Clears the log callback to prevent dangling references on hot reload.
/// Call this before reinitializing the Dart side.
Future<void> clearLogCallback() =>
    RustLib.instance.api.crateApiClearLogCallback();

/// Fetches all new logs since the last fetch.
/// This is safe to call after hot restart - the Rust log buffer survives.
/// Returns an empty vector if no new logs are available.
Future<List<String>> fetchLogs() => RustLib.instance.api.crateApiFetchLogs();

/// Gets all logs currently in the buffer.
/// Use this on initialization to get historical logs.
Future<List<String>> getAllBufferedLogs() =>
    RustLib.instance.api.crateApiGetAllBufferedLogs();

/// Resets the log read index so the next fetch_logs() returns all buffered logs.
/// Call this after hot restart to ensure you don't miss logs.
Future<void> resetLogReadIndex() =>
    RustLib.instance.api.crateApiResetLogReadIndex();

/// Extracts ZTR file to a text file.
///
/// # Arguments
/// * `in_file` - Path to the source .ztr file.
/// * `out_file` - Path to the destination .txt file.
/// * `game_code` - Game version (0: FF13, 1: FF13-2, 2: LR).
Future<void> ztrExtractToText(
        {required String inFile,
        required String outFile,
        required int gameCode}) =>
    RustLib.instance.api.crateApiZtrExtractToText(
        inFile: inFile, outFile: outFile, gameCode: gameCode);

/// Parses ZTR file into memory structure.
Future<ZtrData> ztrParse({required String inFile, required int gameCode}) =>
    RustLib.instance.api.crateApiZtrParse(inFile: inFile, gameCode: gameCode);

/// Parses ZTR from memory buffer into memory structure.
Future<ZtrData> ztrParseFromMemory(
        {required List<int> data, required int gameCode}) =>
    RustLib.instance.api
        .crateApiZtrParseFromMemory(data: data, gameCode: gameCode);

/// Packs in-memory entries (ID, Text) into a ZTR file.
Future<void> ztrPackFromData(
        {required List<(String, String)> entries,
        required String outFile,
        required int gameCode}) =>
    RustLib.instance.api.crateApiZtrPackFromData(
        entries: entries, outFile: outFile, gameCode: gameCode);

/// Packs ZtrData structure into a ZTR file.
Future<void> ztrPackFromStruct(
        {required ZtrData data,
        required String outFile,
        required int gameCode}) =>
    RustLib.instance.api.crateApiZtrPackFromStruct(
        data: data, outFile: outFile, gameCode: gameCode);

/// Converts memory structure to formatted text string.
Future<String> ztrToTextString({required ZtrData data}) =>
    RustLib.instance.api.crateApiZtrToTextString(data: data);

/// Parses all ZTR files in a directory recursively with progress streaming.
///
/// # Arguments
/// * `dir_path` - Path to the directory to scan recursively.
/// * `game_code` - Game version (0: FF13, 1: FF13-2, 2: LR).
/// * `progress_sink` - StreamSink for progress updates.
///
/// # Returns
/// A `ZtrDirectoryResult` containing all parsed entries and error information.
Stream<ZtrParseProgress> ztrParseDirectory(
        {required String dirPath, required int gameCode}) =>
    RustLib.instance.api
        .crateApiZtrParseDirectory(dirPath: dirPath, gameCode: gameCode);

/// Parses all ZTR files in a directory recursively (simple version without progress).
///
/// # Arguments
/// * `dir_path` - Path to the directory to scan recursively.
/// * `game_code` - Game version (0: FF13, 1: FF13-2, 2: LR).
///
/// # Returns
/// A `ZtrDirectoryResult` containing all parsed entries and error information.
Future<ZtrDirectoryResult> ztrParseDirectorySimple(
        {required String dirPath, required int gameCode}) =>
    RustLib.instance.api
        .crateApiZtrParseDirectorySimple(dirPath: dirPath, gameCode: gameCode);

/// Extracts all files from a WhiteBinTools archive.
///
/// # Arguments
/// * `filelist_path` - Path to the filelistu.win32.bin file.
/// * `container_path` - Path to the white_imgu.win32.bin file.
/// * `out_dir` - Directory where files will be extracted.
/// * `game_code` - Game version (0: FF13, 1: FF13-2, 2: LR).
Future<void> wbtExtract(
        {required String filelistPath,
        required String containerPath,
        required String outDir,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtExtract(
        filelistPath: filelistPath,
        containerPath: containerPath,
        outDir: outDir,
        gameCode: gameCode);

/// Repacks files from a directory into a WhiteBinTools archive.
Future<void> wbtRepack(
        {required String filelistPath,
        required String containerPath,
        required String extractedDir,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtRepack(
        filelistPath: filelistPath,
        containerPath: containerPath,
        extractedDir: extractedDir,
        gameCode: gameCode);

/// Repacks a single file into a WhiteBinTools archive.
Future<void> wbtRepackSingle(
        {required String filelistPath,
        required String containerPath,
        required String targetPathInArchive,
        required String fileToInject,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtRepackSingle(
        filelistPath: filelistPath,
        containerPath: containerPath,
        targetPathInArchive: targetPathInArchive,
        fileToInject: fileToInject,
        gameCode: gameCode);

/// Repacks multiple files into a WhiteBinTools archive.
Future<void> wbtRepackMultiple(
        {required String filelistPath,
        required String containerPath,
        required List<(String, String)> filesToPatch,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtRepackMultiple(
        filelistPath: filelistPath,
        containerPath: containerPath,
        filesToPatch: filesToPatch,
        gameCode: gameCode);

/// Returns the file list metadata from a WBT archive.
/// Use this to display a file tree in Flutter without extracting files.
Future<List<WbtFileEntry>> wbtGetFileList(
        {required String filelistPath, required int gameCode}) =>
    RustLib.instance.api
        .crateApiWbtGetFileList(filelistPath: filelistPath, gameCode: gameCode);

/// Extracts a single file from the WBT archive by its virtual path.
Future<void> wbtExtractSingleFile(
        {required String filelistPath,
        required String containerPath,
        required String virtualPath,
        required String outputPath,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtExtractSingleFile(
        filelistPath: filelistPath,
        containerPath: containerPath,
        virtualPath: virtualPath,
        outputPath: outputPath,
        gameCode: gameCode);

/// Extracts a single file from the WBT archive by its index.
Future<void> wbtExtractFileByIndex(
        {required String filelistPath,
        required String containerPath,
        required BigInt fileIndex,
        required String outputDir,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtExtractFileByIndex(
        filelistPath: filelistPath,
        containerPath: containerPath,
        fileIndex: fileIndex,
        outputDir: outputDir,
        gameCode: gameCode);

/// Extracts all files matching a virtual directory prefix.
/// Returns the number of files extracted.
Future<BigInt> wbtExtractDirectory(
        {required String filelistPath,
        required String containerPath,
        required String dirPrefix,
        required String outputDir,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtExtractDirectory(
        filelistPath: filelistPath,
        containerPath: containerPath,
        dirPrefix: dirPrefix,
        outputDir: outputDir,
        gameCode: gameCode);

/// Extracts multiple files by their indices.
/// Returns the number of files extracted.
Future<BigInt> wbtExtractFilesByIndices(
        {required String filelistPath,
        required String containerPath,
        required Uint64List indices,
        required String outputDir,
        required int gameCode}) =>
    RustLib.instance.api.crateApiWbtExtractFilesByIndices(
        filelistPath: filelistPath,
        containerPath: containerPath,
        indices: indices,
        outputDir: outputDir,
        gameCode: gameCode);

/// Unpacks WPD archive to a directory. Returns the WpdData structure.
Future<WpdData> wpdUnpack({required String inFile, required String outDir}) =>
    RustLib.instance.api.crateApiWpdUnpack(inFile: inFile, outDir: outDir);

/// Repacks directory into a WPD archive.
Future<void> wpdRepack({required String inDir, required String outFile}) =>
    RustLib.instance.api.crateApiWpdRepack(inDir: inDir, outFile: outFile);

/// Performs encryption/decryption on supported files (FileList or CLB).
///
/// # Arguments
/// * `target` - Target file type (0: FileList, 1: CLB).
/// * `action` - Crypt action (0: Decrypt, 1: Encrypt).
/// * `input_file` - Path to the file to process.
Future<void> wctProcess(
        {required TargetType target,
        required Action action,
        required String inputFile}) =>
    RustLib.instance.api.crateApiWctProcess(
        target: target, action: action, inputFile: inputFile);

/// Unpacks IMGB to a DDS file using XGR/IMG header.
Future<ImgData> imgUnpack(
        {required String headerFile,
        required String imgbFile,
        required String outDds}) =>
    RustLib.instance.api.crateApiImgUnpack(
        headerFile: headerFile, imgbFile: imgbFile, outDds: outDds);

/// Unpacks IMGB to memory using XGR/IMG header.
Future<(ImgData, Uint8List)> imgUnpackToMemory(
        {required String headerFile, required String imgbFile}) =>
    RustLib.instance.api
        .crateApiImgUnpackToMemory(headerFile: headerFile, imgbFile: imgbFile);

/// Repacks DDS back to IMGB (strict size parity).
Future<void> imgRepackStrict(
        {required String headerFile,
        required String imgbFile,
        required String inDds}) =>
    RustLib.instance.api.crateApiImgRepackStrict(
        headerFile: headerFile, imgbFile: imgbFile, inDds: inDds);

/// Parses WDB file into memory structure.
Future<WdbData> wdbParse({required String inFile, required int gameCode}) =>
    RustLib.instance.api.crateApiWdbParse(inFile: inFile, gameCode: gameCode);

/// Packs memory structure into a WDB file.
Future<void> wdbRepack({required WdbData data, required String outFile}) =>
    RustLib.instance.api.crateApiWdbRepack(data: data, outFile: outFile);

/// Converts WDB memory structure to JSON string.
Future<String> wdbToJson({required WdbData data}) =>
    RustLib.instance.api.crateApiWdbToJson(data: data);

/// Parses JSON string into WDB memory structure.
Future<WdbData> wdbFromJson({required String json}) =>
    RustLib.instance.api.crateApiWdbFromJson(json: json);

/// File metadata for a single entry in a WBT archive.
/// Mirrors the Rust struct for flutter_rust_bridge serialization.
class WbtFileEntry {
  /// File index in the archive (0-based)
  final BigInt index;

  /// Byte offset in the container file
  final BigInt offset;

  /// Original uncompressed file size
  final int uncompressedSize;

  /// Compressed file size
  final int compressedSize;

  /// Virtual path within the archive
  final String path;

  const WbtFileEntry({
    required this.index,
    required this.offset,
    required this.uncompressedSize,
    required this.compressedSize,
    required this.path,
  });

  @override
  int get hashCode =>
      index.hashCode ^
      offset.hashCode ^
      uncompressedSize.hashCode ^
      compressedSize.hashCode ^
      path.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WbtFileEntry &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          offset == other.offset &&
          uncompressedSize == other.uncompressedSize &&
          compressedSize == other.compressedSize &&
          path == other.path;
}

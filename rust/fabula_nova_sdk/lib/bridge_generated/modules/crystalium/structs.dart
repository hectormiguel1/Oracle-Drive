// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// A complete CGT (Crystal Graph Tree) file.
///
/// CGT files define character-specific Crystarium layouts for FF13.
class CgtFile {
  /// File version (typically 1 or 2).
  final int version;

  /// Number of entries in the file.
  final int entryCount;

  /// Total number of nodes across all entries.
  final int totalNodes;

  /// Reserved field (usually 0).
  final int reserved;

  /// Pattern entries defining layout sections.
  final List<CrystariumEntry> entries;

  /// Node records with parent connections.
  final List<CrystariumNode> nodes;

  const CgtFile({
    required this.version,
    required this.entryCount,
    required this.totalNodes,
    required this.reserved,
    required this.entries,
    required this.nodes,
  });

  @override
  int get hashCode =>
      version.hashCode ^
      entryCount.hashCode ^
      totalNodes.hashCode ^
      reserved.hashCode ^
      entries.hashCode ^
      nodes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CgtFile &&
          runtimeType == other.runtimeType &&
          version == other.version &&
          entryCount == other.entryCount &&
          totalNodes == other.totalNodes &&
          reserved == other.reserved &&
          entries == other.entries &&
          nodes == other.nodes;
}

/// A Crystarium entry representing a pattern instance.
///
/// Each entry places a geometric pattern at a specific position with
/// associated nodes belonging to a particular role and stage.
class CrystariumEntry {
  /// Entry index in the file.
  final int index;

  /// Name of the MCP pattern to use (e.g., "test3", "test7").
  final String patternName;

  /// World position of the entry center.
  final Vec3 position;

  /// Overall scale factor.
  final double scale;

  /// Rotation quaternion (XYZ components).
  final Vec3 rotation;

  /// Rotation quaternion W component.
  final double rotationW;

  /// Scale for individual nodes.
  final double nodeScale;

  /// Role ID (0=SYN, 1=COM, 2=RAV, 3=SAB, 4=SEN, 5=MED).
  final int roleId;

  /// Stage number (1-10).
  final int stage;

  /// Entry type (0=Hub with multiple nodes, 255=Leaf with single node).
  final int entryType;

  /// Reserved byte (usually 0).
  final int reserved;

  /// Node IDs belonging to this entry.
  final Uint32List nodeIds;

  /// Link position (for connecting to parent).
  final Vec3 linkPosition;

  /// Link position W component.
  final double linkW;

  const CrystariumEntry({
    required this.index,
    required this.patternName,
    required this.position,
    required this.scale,
    required this.rotation,
    required this.rotationW,
    required this.nodeScale,
    required this.roleId,
    required this.stage,
    required this.entryType,
    required this.reserved,
    required this.nodeIds,
    required this.linkPosition,
    required this.linkW,
  });

  @override
  int get hashCode =>
      index.hashCode ^
      patternName.hashCode ^
      position.hashCode ^
      scale.hashCode ^
      rotation.hashCode ^
      rotationW.hashCode ^
      nodeScale.hashCode ^
      roleId.hashCode ^
      stage.hashCode ^
      entryType.hashCode ^
      reserved.hashCode ^
      nodeIds.hashCode ^
      linkPosition.hashCode ^
      linkW.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CrystariumEntry &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          patternName == other.patternName &&
          position == other.position &&
          scale == other.scale &&
          rotation == other.rotation &&
          rotationW == other.rotationW &&
          nodeScale == other.nodeScale &&
          roleId == other.roleId &&
          stage == other.stage &&
          entryType == other.entryType &&
          reserved == other.reserved &&
          nodeIds == other.nodeIds &&
          linkPosition == other.linkPosition &&
          linkW == other.linkW;
}

/// A Crystarium node representing a single point in the tree.
///
/// Nodes form a tree structure via parent_index references.
/// The root node has parent_index = -1.
class CrystariumNode {
  /// Unique node index.
  final int index;

  /// Node name (up to 16 characters, null-padded).
  /// Format: "cr_XXatYYZZZZ0000" where XX=char, YY=stage, ZZZZ=id.
  final String name;

  /// Parent node index (-1 for root node).
  final int parentIndex;

  /// Unknown fields (4 x u32, typically all zeros).
  final U32Array4 unknown;

  /// Scale values (4 x f32, typically all 1.0).
  final F32Array4 scales;

  const CrystariumNode({
    required this.index,
    required this.name,
    required this.parentIndex,
    required this.unknown,
    required this.scales,
  });

  @override
  int get hashCode =>
      index.hashCode ^
      name.hashCode ^
      parentIndex.hashCode ^
      unknown.hashCode ^
      scales.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CrystariumNode &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          name == other.name &&
          parentIndex == other.parentIndex &&
          unknown == other.unknown &&
          scales == other.scales;
}

/// A complete MCP (Master Crystal Pattern) file.
///
/// MCP files define geometric patterns that CGT entries reference.
class McpFile {
  /// File version.
  final int version;

  /// Number of patterns in the file.
  final int patternCount;

  /// Reserved field.
  final int reserved;

  /// Patterns indexed by name for quick lookup.
  final Map<String, McpPattern> patterns;

  const McpFile({
    required this.version,
    required this.patternCount,
    required this.reserved,
    required this.patterns,
  });

  @override
  int get hashCode =>
      version.hashCode ^
      patternCount.hashCode ^
      reserved.hashCode ^
      patterns.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is McpFile &&
          runtimeType == other.runtimeType &&
          version == other.version &&
          patternCount == other.patternCount &&
          reserved == other.reserved &&
          patterns == other.patterns;
}

/// A geometric pattern used by Crystarium entries.
///
/// Patterns define relative node positions that get transformed
/// by the entry's position, rotation, and scale.
class McpPattern {
  /// Pattern name (e.g., "test3", "test7").
  final String name;

  /// Relative node positions (up to 16).
  final List<Vec3> nodes;

  /// Number of valid nodes in the pattern.
  final BigInt count;

  const McpPattern({
    required this.name,
    required this.nodes,
    required this.count,
  });

  @override
  int get hashCode => name.hashCode ^ nodes.hashCode ^ count.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is McpPattern &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          nodes == other.nodes &&
          count == other.count;
}

/// 3D vector used for positions.
class Vec3 {
  final double x;
  final double y;
  final double z;

  const Vec3({
    required this.x,
    required this.y,
    required this.z,
  });

  @override
  int get hashCode => x.hashCode ^ y.hashCode ^ z.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Vec3 &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y &&
          z == other.z;
}

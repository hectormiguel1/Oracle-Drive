// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Vertex animation from SEDBvanm block.
class VfxAnimation {
  /// Record name (hash-based)
  final String name;

  /// Total data size
  final int dataSize;

  /// Duration in frames (if parseable)
  final int? durationFrames;

  /// Number of keyframes (if parseable)
  final int? keyframeCount;

  const VfxAnimation({
    required this.name,
    required this.dataSize,
    this.durationFrames,
    this.keyframeCount,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      dataSize.hashCode ^
      durationFrames.hashCode ^
      keyframeCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VfxAnimation &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          dataSize == other.dataSize &&
          durationFrames == other.durationFrames &&
          keyframeCount == other.keyframeCount;
}

/// Parsed VFX file containing all effects data.
///
/// This is the main output structure returned by [`parse_vfx`].
class VfxData {
  /// Source file path
  final String sourcePath;

  /// All texture references in the VFX
  final List<VfxTexture> textures;

  /// All 3D models in the VFX
  final List<VfxModel> models;

  /// All vertex animations
  final List<VfxAnimation> animations;

  /// All effect definitions
  final List<VfxEffect> effects;

  const VfxData({
    required this.sourcePath,
    required this.textures,
    required this.models,
    required this.animations,
    required this.effects,
  });

  @override
  int get hashCode =>
      sourcePath.hashCode ^
      textures.hashCode ^
      models.hashCode ^
      animations.hashCode ^
      effects.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VfxData &&
          runtimeType == other.runtimeType &&
          sourcePath == other.sourcePath &&
          textures == other.textures &&
          models == other.models &&
          animations == other.animations &&
          effects == other.effects;
}

/// Effect definition from SEDBveff block.
///
/// Main controller defining how particles/meshes behave.
class VfxEffect {
  /// Effect name (human-readable, e.g., "ev_loc_thanks")
  final String name;

  /// Total data size
  final int dataSize;

  /// Controller paths found (SQEX/CDev/Engine/Vfx/...)
  final List<String> controllerPaths;

  /// Model references (vmdl hashes)
  final List<String> modelRefs;

  /// Texture references (vtex hashes)
  final List<String> textureRefs;

  const VfxEffect({
    required this.name,
    required this.dataSize,
    required this.controllerPaths,
    required this.modelRefs,
    required this.textureRefs,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      dataSize.hashCode ^
      controllerPaths.hashCode ^
      modelRefs.hashCode ^
      textureRefs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VfxEffect &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          dataSize == other.dataSize &&
          controllerPaths == other.controllerPaths &&
          modelRefs == other.modelRefs &&
          textureRefs == other.textureRefs;
}

/// Material properties extracted from vmdl block.
class VfxMaterial {
  /// Ambient color (RGBA)
  final F32Array4 ambientColor;

  /// Diffuse color (RGBA)
  final F32Array4 diffuseColor;

  /// Specular color (RGBA)
  final F32Array4 specularColor;

  /// Shininess/specular power
  final double shininess;

  /// Fog parameters
  final F32Array4 fogParam;

  /// Fog color
  final F32Array4 fogColor;

  /// Alpha test threshold
  final double alphaThreshold;

  /// Blend mode enabled
  final bool blendEnabled;

  /// Alpha test enabled
  final bool alphaTestEnabled;

  /// Back-face culling enabled
  final bool backFaceCulling;

  /// Depth mask enabled
  final bool depthMaskEnabled;

  /// Lighting enabled
  final bool lightingEnabled;

  const VfxMaterial({
    required this.ambientColor,
    required this.diffuseColor,
    required this.specularColor,
    required this.shininess,
    required this.fogParam,
    required this.fogColor,
    required this.alphaThreshold,
    required this.blendEnabled,
    required this.alphaTestEnabled,
    required this.backFaceCulling,
    required this.depthMaskEnabled,
    required this.lightingEnabled,
  });

  @override
  int get hashCode =>
      ambientColor.hashCode ^
      diffuseColor.hashCode ^
      specularColor.hashCode ^
      shininess.hashCode ^
      fogParam.hashCode ^
      fogColor.hashCode ^
      alphaThreshold.hashCode ^
      blendEnabled.hashCode ^
      alphaTestEnabled.hashCode ^
      backFaceCulling.hashCode ^
      depthMaskEnabled.hashCode ^
      lightingEnabled.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VfxMaterial &&
          runtimeType == other.runtimeType &&
          ambientColor == other.ambientColor &&
          diffuseColor == other.diffuseColor &&
          specularColor == other.specularColor &&
          shininess == other.shininess &&
          fogParam == other.fogParam &&
          fogColor == other.fogColor &&
          alphaThreshold == other.alphaThreshold &&
          blendEnabled == other.blendEnabled &&
          alphaTestEnabled == other.alphaTestEnabled &&
          backFaceCulling == other.backFaceCulling &&
          depthMaskEnabled == other.depthMaskEnabled &&
          lightingEnabled == other.lightingEnabled;
}

/// Mesh geometry data for VFX models.
///
/// VFX models are typically billboard quads (4 vertices) or simple shapes.
class VfxMesh {
  /// Vertex positions and UVs
  final List<VfxVertex> vertices;

  /// Triangle indices (3 per triangle)
  final Uint16List indices;

  /// Primitive type
  final VfxPrimitiveType primitiveType;

  const VfxMesh({
    required this.vertices,
    required this.indices,
    required this.primitiveType,
  });

  @override
  int get hashCode =>
      vertices.hashCode ^ indices.hashCode ^ primitiveType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VfxMesh &&
          runtimeType == other.runtimeType &&
          vertices == other.vertices &&
          indices == other.indices &&
          primitiveType == other.primitiveType;
}

/// 3D mesh model from SEDBvmdl block.
///
/// Contains mesh geometry and material properties.
/// Shader bytecode is D3D9 (ps_3_0) and cannot be directly executed.
class VfxModel {
  /// Record name (hash-based)
  final String name;

  /// Total data size
  final int dataSize;

  /// Vertex count (if parseable)
  final int? vertexCount;

  /// Index count (if parseable)
  final int? indexCount;

  /// Material properties
  final VfxMaterial material;

  /// Texture references found in shader
  final List<String> textureRefs;

  /// Whether compiled shader is present
  final bool hasShader;

  /// Shader technique name (if found)
  final String? techniqueName;

  /// Mesh geometry (vertices and indices)
  final VfxMesh? mesh;

  const VfxModel({
    required this.name,
    required this.dataSize,
    this.vertexCount,
    this.indexCount,
    required this.material,
    required this.textureRefs,
    required this.hasShader,
    this.techniqueName,
    this.mesh,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      dataSize.hashCode ^
      vertexCount.hashCode ^
      indexCount.hashCode ^
      material.hashCode ^
      textureRefs.hashCode ^
      hasShader.hashCode ^
      techniqueName.hashCode ^
      mesh.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VfxModel &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          dataSize == other.dataSize &&
          vertexCount == other.vertexCount &&
          indexCount == other.indexCount &&
          material == other.material &&
          textureRefs == other.textureRefs &&
          hasShader == other.hasShader &&
          techniqueName == other.techniqueName &&
          mesh == other.mesh;
}

/// Type of primitive for rendering.
enum VfxPrimitiveType {
  /// Triangle list (3 indices per triangle)
  triangleList,

  /// Triangle strip
  triangleStrip,

  /// Point sprites/billboards
  pointSprite,
  ;
}

/// Summary of VFX file contents for quick display.
class VfxSummary {
  /// Source file path
  final String sourcePath;

  /// Number of textures
  final BigInt textureCount;

  /// Number of models
  final BigInt modelCount;

  /// Number of animations
  final BigInt animationCount;

  /// Number of effects
  final BigInt effectCount;

  /// Total file size
  final BigInt totalSize;

  /// Effect names (human-readable)
  final List<String> effectNames;

  const VfxSummary({
    required this.sourcePath,
    required this.textureCount,
    required this.modelCount,
    required this.animationCount,
    required this.effectCount,
    required this.totalSize,
    required this.effectNames,
  });

  @override
  int get hashCode =>
      sourcePath.hashCode ^
      textureCount.hashCode ^
      modelCount.hashCode ^
      animationCount.hashCode ^
      effectCount.hashCode ^
      totalSize.hashCode ^
      effectNames.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VfxSummary &&
          runtimeType == other.runtimeType &&
          sourcePath == other.sourcePath &&
          textureCount == other.textureCount &&
          modelCount == other.modelCount &&
          animationCount == other.animationCount &&
          effectCount == other.effectCount &&
          totalSize == other.totalSize &&
          effectNames == other.effectNames;
}

/// Texture reference from SEDBvtex block.
///
/// Contains GTEX header metadata. Actual pixel data is in paired IMGB file.
class VfxTexture {
  /// Record name (hash-based, e.g., "v04fdfc11828acd")
  final String name;

  /// Texture width in pixels
  final int width;

  /// Texture height in pixels
  final int height;

  /// Pixel format code (24=DXT1, 25=DXT3, 26=DXT5, 3-4=RGBA)
  final int format;

  /// Format name for display
  final String formatName;

  /// Number of mipmap levels
  final int mipCount;

  /// Image type (2D, 3D, cube)
  final int imageType;

  /// Depth (for 3D textures)
  final int depth;

  /// Offset in IMGB file
  final int imgbOffset;

  /// Size in IMGB file
  final int imgbSize;

  const VfxTexture({
    required this.name,
    required this.width,
    required this.height,
    required this.format,
    required this.formatName,
    required this.mipCount,
    required this.imageType,
    required this.depth,
    required this.imgbOffset,
    required this.imgbSize,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      width.hashCode ^
      height.hashCode ^
      format.hashCode ^
      formatName.hashCode ^
      mipCount.hashCode ^
      imageType.hashCode ^
      depth.hashCode ^
      imgbOffset.hashCode ^
      imgbSize.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VfxTexture &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          width == other.width &&
          height == other.height &&
          format == other.format &&
          formatName == other.formatName &&
          mipCount == other.mipCount &&
          imageType == other.imageType &&
          depth == other.depth &&
          imgbOffset == other.imgbOffset &&
          imgbSize == other.imgbSize;
}

/// Single vertex with position and UV coordinates.
class VfxVertex {
  /// Position (x, y, z)
  final F32Array3 position;

  /// Texture coordinates (u, v)
  final F32Array2 uv;

  const VfxVertex({
    required this.position,
    required this.uv,
  });

  @override
  int get hashCode => position.hashCode ^ uv.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VfxVertex &&
          runtimeType == other.runtimeType &&
          position == other.position &&
          uv == other.uv;
}

// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Complete parsed ZTR file data.
///
/// This structure represents a fully parsed ZTR file, ready for viewing,
/// editing, or repacking. It's the primary interface for ZTR operations.
///
/// # Usage
/// ```rust,ignore
/// // Parse a ZTR file
/// let data = parse_ztr("dialogue.ztr", GameCode::FF13_1)?;
///
/// // Modify entries
/// data.entries[0].text = "Modified text".to_string();
///
/// // Save changes
/// pack_ztr_from_struct(&data, "dialogue_mod.ztr", GameCode::FF13_1)?;
/// ```
class ZtrData {
  /// All text entries in the file, in order.
  final List<ZtrEntry> entries;

  /// Control code mappings used during decoding.
  /// Currently empty; reserved for future use.
  final List<ZtrMapEntry> mappings;

  const ZtrData({
    required this.entries,
    required this.mappings,
  });

  @override
  int get hashCode => entries.hashCode ^ mappings.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ZtrData &&
          runtimeType == other.runtimeType &&
          entries == other.entries &&
          mappings == other.mappings;
}

/// Result of parsing all ZTR files in a directory.
class ZtrDirectoryResult {
  /// All entries from all parsed files.
  final List<ZtrEntryWithSource> entries;

  /// List of files that were successfully parsed.
  final List<String> parsedFiles;

  /// List of files that failed to parse, with error messages.
  final List<ZtrFileError> failedFiles;

  /// Total number of ZTR files found.
  final BigInt totalFiles;

  const ZtrDirectoryResult({
    required this.entries,
    required this.parsedFiles,
    required this.failedFiles,
    required this.totalFiles,
  });

  @override
  int get hashCode =>
      entries.hashCode ^
      parsedFiles.hashCode ^
      failedFiles.hashCode ^
      totalFiles.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ZtrDirectoryResult &&
          runtimeType == other.runtimeType &&
          entries == other.entries &&
          parsedFiles == other.parsedFiles &&
          failedFiles == other.failedFiles &&
          totalFiles == other.totalFiles;
}

/// A single text entry from a ZTR file.
///
/// Each entry consists of a unique string ID and its associated text content.
/// The text may contain control codes represented as `{Tag}` placeholders.
///
/// # Example
/// ```rust,ignore
/// let entry = ZtrEntry {
///     id: "txtres_0001".to_string(),
///     text: "{Color White}Hello, traveler!".to_string(),
/// };
/// ```
class ZtrEntry {
  /// Unique identifier for this text entry.
  /// Used by the game engine to look up specific strings.
  /// Examples: "txtres_0001", "btl_001_001", "menu_save_confirm"
  final String id;

  /// The decoded text content with control codes as `{Tag}` placeholders.
  /// Examples:
  /// - "{Color Gold}Lightning{Color White} joined the party!"
  /// - "Press {Btn A} to continue"
  /// - "HP restored by {Counter Type 1} points"
  final String text;

  const ZtrEntry({
    required this.id,
    required this.text,
  });

  @override
  int get hashCode => id.hashCode ^ text.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ZtrEntry &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          text == other.text;
}

/// A text entry with its source file path for batch loading.
///
/// Used when loading multiple ZTR files from a directory, allowing
/// tracking of which file each entry came from.
class ZtrEntryWithSource {
  /// Unique identifier for this text entry.
  final String id;

  /// The decoded text content.
  final String text;

  /// Relative path to the source ZTR file (relative to the scanned directory).
  final String sourceFile;

  const ZtrEntryWithSource({
    required this.id,
    required this.text,
    required this.sourceFile,
  });

  @override
  int get hashCode => id.hashCode ^ text.hashCode ^ sourceFile.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ZtrEntryWithSource &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          text == other.text &&
          sourceFile == other.sourceFile;
}

/// Error information for a failed ZTR file parse.
class ZtrFileError {
  /// Path to the file that failed.
  final String filePath;

  /// Error message describing what went wrong.
  final String error;

  const ZtrFileError({
    required this.filePath,
    required this.error,
  });

  @override
  int get hashCode => filePath.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ZtrFileError &&
          runtimeType == other.runtimeType &&
          filePath == other.filePath &&
          error == other.error;
}

/// Key-value mapping for control code dictionaries.
///
/// Used to export the mapping between tag names and their meanings.
/// Primarily for debugging and documentation purposes.
class ZtrMapEntry {
  /// The tag name as it appears in decoded text (e.g., "{Color White}")
  final String key;

  /// Description or hex representation of the control code
  final String value;

  const ZtrMapEntry({
    required this.key,
    required this.value,
  });

  @override
  int get hashCode => key.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ZtrMapEntry &&
          runtimeType == other.runtimeType &&
          key == other.key &&
          value == other.value;
}

/// Progress update during directory parsing.
class ZtrParseProgress {
  /// Total number of ZTR files found.
  final BigInt totalFiles;

  /// Number of files processed so far.
  final BigInt processedFiles;

  /// Number of successfully parsed files.
  final BigInt successCount;

  /// Number of failed files.
  final BigInt errorCount;

  /// Path to the file currently being processed.
  final String currentFile;

  /// Current stage: "scanning", "parsing", "complete".
  final String stage;

  const ZtrParseProgress({
    required this.totalFiles,
    required this.processedFiles,
    required this.successCount,
    required this.errorCount,
    required this.currentFile,
    required this.stage,
  });

  @override
  int get hashCode =>
      totalFiles.hashCode ^
      processedFiles.hashCode ^
      successCount.hashCode ^
      errorCount.hashCode ^
      currentFile.hashCode ^
      stage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ZtrParseProgress &&
          runtimeType == other.runtimeType &&
          totalFiles == other.totalFiles &&
          processedFiles == other.processedFiles &&
          successCount == other.successCount &&
          errorCount == other.errorCount &&
          currentFile == other.currentFile &&
          stage == other.stage;
}

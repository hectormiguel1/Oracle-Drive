// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Decoded audio data ready for playback.
class DecodedAudio {
  /// Sample rate in Hz
  final int sampleRate;

  /// Number of channels (1=mono, 2=stereo)
  final int channels;

  /// Bits per sample (usually 16)
  final int bitsPerSample;

  /// Raw PCM data as bytes (little-endian signed 16-bit samples)
  final Uint8List pcmData;

  /// Duration in seconds
  final double durationSeconds;

  /// Original codec that was decoded
  final String originalCodec;

  const DecodedAudio({
    required this.sampleRate,
    required this.channels,
    required this.bitsPerSample,
    required this.pcmData,
    required this.durationSeconds,
    required this.originalCodec,
  });

  @override
  int get hashCode =>
      sampleRate.hashCode ^
      channels.hashCode ^
      bitsPerSample.hashCode ^
      pcmData.hashCode ^
      durationSeconds.hashCode ^
      originalCodec.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DecodedAudio &&
          runtimeType == other.runtimeType &&
          sampleRate == other.sampleRate &&
          channels == other.channels &&
          bitsPerSample == other.bitsPerSample &&
          pcmData == other.pcmData &&
          durationSeconds == other.durationSeconds &&
          originalCodec == other.originalCodec;
}

/// Audio codec types used in SCD files.
enum ScdCodec {
  /// PCM signed 16-bit big-endian
  pcmBe,

  /// PCM signed 16-bit little-endian
  pcmLe,

  /// PlayStation ADPCM
  psAdpcm,

  /// Ogg Vorbis (may be XOR encrypted in FF13-2/LR)
  oggVorbis,

  /// MPEG Audio (MP3, used on PS3)
  mpeg,

  /// MS-ADPCM (common in FF13 PC)
  msAdpcm,

  /// XMA2 (Xbox 360)
  xma2,

  /// ATRAC3/ATRAC3plus
  atrac,

  /// Unknown codec
  unknown,
  ;
}

/// Result of extracting audio from an SCD file.
class ScdExtractResult {
  /// Metadata about the SCD file
  final ScdMetadata metadata;

  /// Decoded audio streams (one per stream in the SCD)
  final List<DecodedAudio> audioStreams;

  const ScdExtractResult({
    required this.metadata,
    required this.audioStreams,
  });

  @override
  int get hashCode => metadata.hashCode ^ audioStreams.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScdExtractResult &&
          runtimeType == other.runtimeType &&
          metadata == other.metadata &&
          audioStreams == other.audioStreams;
}

/// Main SCD file header (SEDBSSCF).
class ScdHeader {
  /// File version (usually 3)
  final int version;

  /// Whether file is big-endian
  final bool bigEndian;

  /// Offset to tables section
  final int tablesOffset;

  /// Total file size
  final BigInt fileSize;

  const ScdHeader({
    required this.version,
    required this.bigEndian,
    required this.tablesOffset,
    required this.fileSize,
  });

  @override
  int get hashCode =>
      version.hashCode ^
      bigEndian.hashCode ^
      tablesOffset.hashCode ^
      fileSize.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScdHeader &&
          runtimeType == other.runtimeType &&
          version == other.version &&
          bigEndian == other.bigEndian &&
          tablesOffset == other.tablesOffset &&
          fileSize == other.fileSize;
}

/// Metadata for an SCD file.
class ScdMetadata {
  /// Source file name
  final String name;

  /// File header info
  final ScdHeader header;

  /// Stream information
  final List<ScdStreamInfo> streams;

  /// Total duration in seconds (estimated)
  final double durationSeconds;

  const ScdMetadata({
    required this.name,
    required this.header,
    required this.streams,
    required this.durationSeconds,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      header.hashCode ^
      streams.hashCode ^
      durationSeconds.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScdMetadata &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          header == other.header &&
          streams == other.streams &&
          durationSeconds == other.durationSeconds;
}

/// Information about a single audio stream.
class ScdStreamInfo {
  /// Index of this stream
  final int index;

  /// Size of the audio data in bytes
  final int dataSize;

  /// Number of audio channels
  final int channels;

  /// Sample rate in Hz
  final int sampleRate;

  /// Audio codec type
  final ScdCodec codec;

  /// Loop start sample (0 if no loop)
  final int loopStart;

  /// Loop end sample (0 if no loop)
  final int loopEnd;

  /// Size of extra codec-specific data
  final int extraDataSize;

  /// Number of auxiliary chunks
  final int auxChunkCount;

  /// Offset to the audio data from stream header
  final int dataOffset;

  const ScdStreamInfo({
    required this.index,
    required this.dataSize,
    required this.channels,
    required this.sampleRate,
    required this.codec,
    required this.loopStart,
    required this.loopEnd,
    required this.extraDataSize,
    required this.auxChunkCount,
    required this.dataOffset,
  });

  @override
  int get hashCode =>
      index.hashCode ^
      dataSize.hashCode ^
      channels.hashCode ^
      sampleRate.hashCode ^
      codec.hashCode ^
      loopStart.hashCode ^
      loopEnd.hashCode ^
      extraDataSize.hashCode ^
      auxChunkCount.hashCode ^
      dataOffset.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScdStreamInfo &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          dataSize == other.dataSize &&
          channels == other.channels &&
          sampleRate == other.sampleRate &&
          codec == other.codec &&
          loopStart == other.loopStart &&
          loopEnd == other.loopEnd &&
          extraDataSize == other.extraDataSize &&
          auxChunkCount == other.auxChunkCount &&
          dataOffset == other.dataOffset;
}
